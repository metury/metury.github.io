<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Personal page</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Personal page</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-my-personal-page"><a class="header" href="#welcome-to-my-personal-page">Welcome, to my personal page.</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut interests : Vec&lt;&amp;str&gt; = vec!["Computer science",
                                         "Travel",
                                         "Music",
                                         "Movies"];

    println!("Welcome to my personal webpage.");
    println!("");
    println!("Here you may find some things I enjoy or do.");

    for int in &amp;interests {
        println!("\t- {}", int);
    }

    interests.push("Advent of code");

    println!("And also I cannot forget: {}", interests[interests.len() - 1]);

    let url = "github.com/metury/metury.github.io";
    let tools = vec!["Github pages", "MdBook"];

    println!("");
    println!("Source of this page can be found at the link: {}", url);
    println!("");
    println!("For the proper usecase I used {}.", tools.join(" and "));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="about-this-page"><a class="header" href="#about-this-page">About this page</a></h2>
<p>This is my own personal page. Feel free to see the pages.</p>
<h2 id="about-me"><a class="header" href="#about-me">About me</a></h2>
<p>I am a student at Charles University studying computer science. My CV can be found here:</p>
<ul>
<li><a href="./resources/CV_cs.pdf">Životopis</a></li>
<li><a href="./resources/CV_en.pdf">Resumé</a></li>
</ul>
<p>Also I am great fan of <a href="/adventofcode.html">Advent of Code</a> and I have all my (partial) solutions listed here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matfyz"><a class="header" href="#matfyz">Matfyz</a></h1>
<p>Tady je menší rozcestník pro matfyzácké věci. Jak už moje zápisky nebo odkazy na předměty, které mám zapsané.</p>
<h2 id="zápisky"><a class="header" href="#zápisky">Zápisky</a></h2>
<p>Občas stihnu sepsat nějaké zápisky z přednášky a pokud stojí (aspoň trochu) za to, tak se tady budou nacházet. Veškeré texty lze najív v repozitáři na <a href="https://github.com/metury/notes">GitHubu</a>.</p>
<ul>
<li><a href="./mff/fpc.pdf">Flows, paths and cuts</a></li>
<li><a href="./mff/grg.pdf">Geometric Representations of Graphs</a></li>
<li><a href="./mff/kg.pdf">Kombinatorika a grafy</a></li>
<li><a href="./mff/past-ii.pdf">Probability and statistics 2</a></li>
<li><a href="./mff/polyhedra.pdf">Polyhedral combinatorics</a></li>
<li><a href="./mff/temno.pdf">Teorie množin</a></li>
<li><a href="./mff/selected-chapters-kg.pdf">Selected chapters from kombinatorics</a></li>
</ul>
<h2 id="odkazy-na-předměty"><a class="header" href="#odkazy-na-předměty">Odkazy na předměty</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Předmět</th><th style="text-align: center">Odkazy</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>2425 - Zimní semestr</strong></td><td style="text-align: center"><strong>--</strong></td></tr>
<tr><td style="text-align: center">Constraint programming</td><td style="text-align: center"><a href="https://ktiml.mff.cuni.cz/~bartak/podminky/">Web</a> <a href="https://jbulin.github.io/teaching/fall/nopt042/">Cvičení</a> <a href="https://picat-lang.org/download/picat_guide.pdf">Picat Docs</a></td></tr>
<tr><td style="text-align: center">Introduction to Parameterized Algorithms</td><td style="text-align: center"><a href="https://research.koutecky.name/db/teaching:intro_par_alg2324">Web</a> <a href="https://www.mimuw.edu.pl/~malcin/book/parameterized-algorithms.pdf">Kniha</a> <a href="https://iuuk.mff.cuni.cz/~tung/teaching/fpt-ws2324/">Cvičení</a></td></tr>
<tr><td style="text-align: center">Programování v jazyce Rust</td><td style="text-align: center"><a href="https://d3s.mff.cuni.cz/teaching/nprg082/">Web</a></td></tr>
<tr><td style="text-align: center">Vybrané kapitoly z kombinatoriky 1</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Základy teorie kategorií</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Úvod do teorie čísel</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~klazar/UTC24.html">Web</a></td></tr>
<tr><td style="text-align: center"><strong>2324 - Letní semestr</strong></td><td style="text-align: center"><strong>--</strong></td></tr>
<tr><td style="text-align: center">Teorie Matroidů</td><td style="text-align: center"><a href="https://iuuk.mff.cuni.cz/~pangrac/vyuka/">Web</a> <a href="https://kam.mff.cuni.cz/~cerny/teach/23-24/matroids.html">Cviceni</a></td></tr>
<tr><td style="text-align: center">Datove struktury 2</td><td style="text-align: center"><a href="https://mj.ucw.cz/vyuka/2324/ds2/">Web</a> <a href="https://mj.ucw.cz/vyuka/dsnotes/ds.pdf">Skripta</a></td></tr>
<tr><td style="text-align: center">Matematické programování a polyedrální kombinatorika</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~kolman/matprog23.html">Web</a> <a href="https://iti.mff.cuni.cz/series/2013/601.pdf">úkol</a></td></tr>
<tr><td style="text-align: center">Matematické struktury</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~klazar/MSTR24.html">Web</a></td></tr>
<tr><td style="text-align: center">Grafové minory a stromové dekompozice</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~fiala/index.shtml.cs">Web</a> <a href="https://kam.mff.cuni.cz/~fiala/tw.pdf">Skripta</a></td></tr>
<tr><td style="text-align: center">Grafové algoritmy 2</td><td style="text-align: center"><a href="https://mj.ucw.cz/vyuka/2324/ga2/">Web</a> <a href="https://mj.ucw.cz/vyuka/ga/ga.pdf">Skripta</a> a <a href="http://adambuchsbaum.com/papers/ptrs-stoc98.pdf">Linear-Time Pointer-Machine Algorithms </a></td></tr>
<tr><td style="text-align: center">Geometrická reprezentace grafů 2</td><td style="text-align: center"><a href="https://dl1.cuni.cz/course/view.php?id=16103">Moodle</a></td></tr>
<tr><td style="text-align: center"><strong>2324 - Zimní semestr</strong></td><td style="text-align: center"><strong>--</strong></td></tr>
<tr><td style="text-align: center"><del>Pravděpodobnostní techniky</del></td><td style="text-align: center"><del><a href="https://kam.mff.cuni.cz/~tyomkyn/teaching/PT/PT.html">Web</a> <a href="https://www.cs.cmu.edu/~15850/handouts/matousek-vondrak-prob-ln.pdf">Skripta</a> <a href="https://kam.mff.cuni.cz/~dbulavka/teaching/ws2324/pt.html">Úkoly</a></del></td></tr>
<tr><td style="text-align: center">Barevnost grafů</td><td style="text-align: center"><a href="https://iuuk.mff.cuni.cz/~rakdver/index.php?which=uceni&amp;subject=bar">Web</a></td></tr>
<tr><td style="text-align: center">Geometrická reprezentace grafů</td><td style="text-align: center"><a href="https://is.cuni.cz/studium/predmety/index.php?id=b1110fec60a34e4c9eff4fbd6f73920d&amp;tid=&amp;do=predmet&amp;kod=NDMI037&amp;skr=2023&amp;fak=11320">Zápisky na SISu</a></td></tr>
<tr><td style="text-align: center">Datove struktury</td><td style="text-align: center"><a href="https://mj.ucw.cz/vyuka/2324/ds1/">Web</a> <a href="https://mj.ucw.cz/vyuka/dsnotes/ds.pdf">Skripta</a></td></tr>
<tr><td style="text-align: center">Základy složitosti a vyčíslitelnosti</td><td style="text-align: center"><a href="https://ktiml.mff.cuni.cz/~kucerap/NTIN090/NTIN090-poznamky.pdf">Skripta</a> <a href="https://kti.mff.cuni.cz/~maj/">Cvičení</a> <a href="https://dl1.cuni.cz/course/view.php?id=10131">Moodle</a></td></tr>
<tr><td style="text-align: center">Grafové algoritmy</td><td style="text-align: center"><a href="https://mj.ucw.cz/vyuka/2324/ga/">Web</a> <a href="https://mj.ucw.cz/vyuka/ga/ga.pdf">Skripta</a> a <a href="%5B90%5D(https://mj.ucw.cz/papers/saga/saga.pdf#page=90)">ET</a></td></tr>
<tr><td style="text-align: center">Kombinatorika a grafy 3</td><td style="text-align: center"><a href="https://iuuk.mff.cuni.cz/~rakdver/index.php?which=uceni&amp;subject=kg3">Web</a> <a href="http://gaubian.xyz/">úkoly</a></td></tr>
<tr><td style="text-align: center">Intervalove metody</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~hladik/IA/">Web</a> <a href="https://kam.mff.cuni.cz/~hladik/IA/text_ia.pdf">Skripta</a></td></tr>
<tr><td style="text-align: center">Toky, cesty a řezy</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~kolman/tokyrezy23.html">Web</a></td></tr>
</tbody></table>
</div>
<h2 id="další-užitečné-odkazy"><a class="header" href="#další-užitečné-odkazy">Další užitečné odkazy</a></h2>
<ul>
<li><a href="https://pruvodce.ucw.cz/">Průvodce labyrintem algoritmů</a></li>
<li>Dobré poznámky má také <a href="https://slama.dev/">Tomáš Sláma</a></li>
<li>Některé odkazy lze najít na <a href="https://wiki.matfyz.cz/Home">Matfyzácké wiki</a></li>
</ul>
<h2 id="cvrp"><a class="header" href="#cvrp">CVRP</a></h2>
<ul>
<li><a href="./mff/cvrp/cvrp-presentation.pdf">Presentation</a></li>
<li><a href="./mff/cvrp/cvrp.pdf">Text describing the solution</a></li>
<li><a href="./mff/cvrp/solver.zip">Created solver</a></li>
</ul>
<h2 id="thesis-links"><a class="header" href="#thesis-links">Thesis links</a></h2>
<ul>
<li><a href="./mff/connected-cuts.pdf">My notes on connected cuts</a></li>
</ul>
<h3 id="other-links"><a class="header" href="#other-links">Other links</a></h3>
<ul>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/195058.195216">Max cut</a></li>
<li><a href="https://www.researchgate.net/publication/2513735_Multicommodity_Flows_and_Approximation_Algorithms">\(s-t\) connected cuts</a></li>
<li><a href="https://arxiv.org/abs/1807.07143v2">\(k\) cuts</a> a <a href="https://arxiv.org/pdf/1807.07143v2">PDF</a></li>
<li><a href="https://kam.mff.cuni.cz/~kolman/papers/STC-2024.pdf">Petr Kolman STC</a></li>
<li><a href="https://kam.mff.cuni.cz/~kolman/papers/stc-ext-arx.pdf">Petr Kolman - other aproximation</a></li>
<li><a href="https://sites.cs.ucsb.edu/~daniello/papers/maximum_minimal_cut__Journal.pdf">Maximum connected cut</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project"><a class="header" href="#project">Project</a></h1>
<p>There is a small list of my projects.</p>
<h2 id="rodoc"><a class="header" href="#rodoc"><a href="https://github.com/rodoc-app">rodoc</a></a></h2>
<p>My own bachelors project that is for organizing your own family tree.</p>
<p><a href="https://github.com/rodoc-app/rodoc-app">GitHub</a> and <a href="https://rodoc-app.github.io/">Page</a> for more information.</p>
<h2 id="graphs"><a class="header" href="#graphs">graphs</a></h2>
<p>Library for graphs that is written in <code>Java</code>. There are some basic algorithms implemented as well.</p>
<p><a href="https://github.com/metury/graphs">GitHub</a> and <a href="../resources/docs/graphs/index.html">Documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="my-programming-sandbox"><a class="header" href="#my-programming-sandbox">My programming sandbox</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-exercises"><a class="header" href="#programming-exercises">Programming exercises</a></h1>
<p>There are some more or less easy programming exercises that will get you into a programming. Yet I have not work out the exact style of these pages, now there is just a list of solutions to typical problems.</p>
<h2 id="ceaser-cipher"><a class="header" href="#ceaser-cipher">Ceaser cipher</a></h2>
<pre><code class="language-py"># Assume only whitespace and lovercase alphabet is present.

shift = int(input("Zadej posun: "))
word = input("Zadej zprávu: ")

for c in word:
	if ord(c) &gt;= ord('a') and ord(c) &lt;= ord('z'):
		print(chr(((ord(c) - ord('a') + shift) % (ord('z') - ord('a') + 1)) + ord('a')), end = "")
	else:
		print(c, end="")

print()
</code></pre>
<h1 id="k-th-min"><a class="header" href="#k-th-min">k-th min</a></h1>
<pre><code class="language-py">number = 0
array = list()
c = 100

def cap():
	if len(array) &gt; c: # Když to pole je moc velké
		array.pop(0) # Vyhoď na pozici x = 0
		# len(array) = c * 2 -&gt; tohle se nemůže stát
		# len(array) &lt;= c + 1

# array.pop(0) vs array.pop(len(array)-1)
# to prvni podstatne pomalejsi

def add(value):
	for i in range(len(array)): # Přes všechny indexy
		if array[i] &gt;= value:
			array.insert(i, value) # Vlož na i prvek value [0, 1, 2, 3] insert(1,50) -&gt; [0, 50, 1, 2, 3]
			cap()
			return
	array.append(value) # Přidej prvek na konec
	cap()

while number != -1:
	number = int(input())
	if number != -1:
		add(number)

k = int(input())

print(array[len(array) - k])
</code></pre>
<h2 id="linked-list"><a class="header" href="#linked-list">linked list</a></h2>
<pre><code class="language-py"># This is implementation of K-capped linked list.

class node:
	value = 0
	next_node = None
	def __init__(self, value, next_node):
		self.value = value
		self.next_node = next_node
	def setnext(self, next_node):
		self.next_node = next_node

class linked_list:
	head = None
	tail = None
	k = 100
	size = 0
	def __init__(self, k):
		self.k = k
		self.size = 0
	def remove(self):
		if self.size &gt;= self.k:
			counter = 0
			tmp = self.head
			for i in range(self.k - 1):
				tmp = tmp.next_node
			tmp.next_node = None
			self.size -= 1
	def add(self, value):
		if self.size &gt;= self.k and self.tail != None and self.tail.value &lt;= value:
			return
		elif self.head == None:
			self.tail = self.head = node(value, None)
			self.size += 1
		else:
			tmp = self.head
			previous = None
			while tmp != None and tmp.value &lt; value:
				previous = tmp
				tmp = tmp.next_node
			if previous == None:
				self.head = node(value, self.head)
			elif tmp == None:
				self.tail = previous.next_node = node(value, None)
			else:
				previous.setnext(node(value, tmp))
			self.size += 1
		self.remove()
	def print(self):
		tmp = self.head
		print("START -&gt; ", end="")
		while tmp != None:
			print(f"{tmp.value} -&gt; ", end = "")
			tmp = tmp.next_node
		print("END")

def main():
	ll = linked_list(4)
	ll.add(2)
	ll.add(3)
	ll.add(5)
	ll.add(1)
	ll.add(6)
	ll.add(8)
	ll.add(4)
	ll.print()

if __name__ == '__main__':
	main()
</code></pre>
<h2 id="k-heap"><a class="header" href="#k-heap">k-heap</a></h2>
<pre><code class="language-py"># Implementation of K-capped max heap.

class max_heap:
	array = list()
	k = 100
	def __init__(self, k):
		self.k = k
	def size(self):
		return len(self.array)
	def remove(self):
		self.array[0], self.array[len(self.array) - 1] = self.array[len(self.array) - 1], self.array[0]
		self.array.remove(self.array[len(self.array) - 1])
		i = 0
		while (2*i+1 &lt; self.size() and self.array[i] &lt; self.array[2 * i + 1]) or (2*i+2 &lt; self.size() and self.array[i] &lt; max(self.array[2 * i + 1], self.array[2 * i + 2])):
			if 2*i+2 &lt; self.size() and self.array[2 * i + 1] &lt; self.array[2 * i + 2]:
				self.array[i], self.array[2 * i + 2] = self.array[2 * i + 2], self.array[i]
				i = 2*i +2
			else:
				self.array[i], self.array[2 * i + 1] = self.array[2 * i + 1], self.array[i]
				i = 2*i +1
	def add(self, value):
		if self.size() &gt; 0 and value &gt;= self.array[0] and self.k == self.size():
			return
		else:
			self.array.append(value)
			i = self.size() - 1
			while i &gt;= 0 and self.array[(i - 1) // 2] &lt; self.array[i]:
				self.array[(i - 1) // 2], self.array[i] = self.array[i], self.array[(i - 1) // 2]
				if i == 0:
					break
		if self.size() &gt; self.k:
			self.remove()

def main():
	h = max_heap(3)
	print(h.size())
	h.add(1)
	h.add(2)
	h.add(3)
	h.add(4)
	h.add(0)
	print(h.size())
	print(h.array)
	h.remove()
	print(h.array)
	print(h.size())

if __name__ == "__main__":
	main()
</code></pre>
<h1 id="work-with-matrix"><a class="header" href="#work-with-matrix">Work with matrix</a></h1>
<pre><code class="language-py">"""
Tohle je přečtení vstupu, rozdělení a převedení do pole čísel.
Protože to pole je délky 2, tak to lze napsat takhle.
"""
height, width = [int(x) for x in input().strip().split(" ")]
matrix = list()

for _ in range(height):
	matrix.append([int(number) for number in input().strip()split(" ")])

"""
Najdi globální minimum.
"""
my_min = min([min(x) for x in matrix])

"""
Odečti minimum od všech.
"""
p_matrix = [[x - my_min for x in l] for l in matrix]

"""
Vytiskni matici.
"""
for row in p_matrix:
	for i in range(len(row)):
		if i == len(row) - 1:
			print(row[i])
		else:
			print(row[i], end=" ")
</code></pre>
<h1 id="trees"><a class="header" href="#trees">Trees</a></h1>
<pre><code class="language-py">"""
Tohle je třeba pro čtení vstupu dokud nezkončí.
Konec je v terminálu pomocí Ctrl+D.
"""
import sys

c = 100 # max size of field - Můžeš si to přepočítat.

"""
Woods je matice stromů. Respektive teček/hvězdiček.
Tento konstrukt vytvoří pole c*c s hodnotami False.
"""
woods = [[False for _ in range(c)] for _ in range(c)]

"""
Hranice vykreslitelného pole.
"""
boundaries = [c, c, 0, 0] # Xmin, Ymin, Xmax, Ymax


"""
Tohle je to pozorování. Ale ve zkratce.
# 0 0 3 1 [Y, X, K, L]
# How to compute this?
# ..*.. &lt;- at this level it is on pos [X, Y+K]
# .***. &lt;- at this level are the positions [X+1,Y+ K-1..K..K+1]
# ***** ... generally it is [X + i,Y+ K-i ... K+i]
# ..*.. &lt;- bottom is just [X + K, Y+K]
"""

"""
Tiskne matici stromů dle hranic.
"""
def print_woods(min_x, min_y, max_x, max_y):
	for i in range(min_x, max_x): # od min do max
		for j in range(min_y, max_y): # od min do max
			if woods[i][j]: # Pokud je True, tak hvězdička
				print("*", end="") # Na konec nic nedávej.
			else:
				print(".", end="")
		print() #Vytiskni konec řádky.

"""
Tady se aktualizují hranice, tedy minima a maxima pro x a y.
Zde možná je těžší se vyznat v daných maximech a minimech, tak si to
kdyžtak pomalu projdi a uprav tak aby to bylo lépe čitelné.
"""
def update(args):
	if boundaries[0] &gt; args[0]: #update xmin
		boundaries[0] = args[0]
	if boundaries[1] &gt; args[1]: #update ymin
		boundaries[1] = args[1]
	if boundaries[2] &lt; args[1] + args[2] + args[3]: #update xmax
		boundaries[2] = args[1] + args[2] + args[3]
	if boundaries[3] &lt; args[0] + 2*args[2] - 1: #update ymax
		boundaries[3] = args[0] + 2*args[2] - 1

"""
Přidej strom do pole. Args je pole [X, Y, K, L]
Tady se použivá celé pozorování a výpočet indexů.
"""
def add_tree(args):
	boundaries = update(args)
	for i in range(args[2]):
		for j in range(i + 1):
			woods[args[1] + i][args[0] + args[2] - j - 1] = True
			woods[args[1] + i][args[0] + args[2] + j - 1] = True
			# Note middle is twice
	for i in range(args[3]):
		woods[args[1]+args[2] + i][args[0]+args[2] - 1] = True

# This is bad. We need to use sys.stdin.
"""
while((l := input()) != None):
	add_tree([int(x) for x in l.split(" ")])
	print_woods(boundaries[0], boundaries[1], boundaries[2], boundaries[3])
"""

"""
Dokud nezkončí vstup čti řádky.
"""
for line in sys.stdin:
	add_tree([int(x) for x in line.split(" ")]) # Tohle je vlastně read z předchozího úkolu.

"""
Už jen vytiskni les.
"""
print_woods(boundaries[0], boundaries[1], boundaries[2], boundaries[3])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jednoduchý-průvodce-po-tenerife"><a class="header" href="#jednoduchý-průvodce-po-tenerife">Jednoduchý průvodce po Tenerife</a></h1>
<p>Zde můžete najít pár tipů a rad ohledně návštěvy Španělského ostrova Tenerife. Mimo samotné cesty můžete zde najít pár zajímavých míst a taky několik konkrétních tras.</p>
<p>Vše berte trochu s ohledem. Ne všechny trasy jsou vhodné pro každého a také se v průběhu času mohou měnit konkrétní mistní podmínky a situace. Tento průvodce je občas aktualizován, ale je to pouze moje volnočasová aktivita.</p>
<p>Všechny typy a rady jsou na Vaše vlastní nebezpečí a tímto nijak neodpovídám, že případné potíže.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cesta"><a class="header" href="#cesta">Cesta</a></h1>
<p>Zde si nejdříve představím doporučení na věci, které by šlo vzít s sebou a následně nějaké komentáře ohledně cesty letadlem.</p>
<p>Závěrem také stručně představím, jak se lze po ostrově pohybovat.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="co-si-vzít-s-sebou"><a class="header" href="#co-si-vzít-s-sebou">Co si vzít s sebou</a></h1>
<p>Koneckonců přesný seznam závisí na potřebách každého z Vás. Nicméně i tak dodám nějaké doporučení, které mi přijde užitečné.</p>
<p>Pokud si budete brát velký kufr, tak tohle není moc potřeba. Většinou stačí jen příruční zavazadlo, které nabývají rozměrů batohu, do kterého se vejde dost potřebných věcí.</p>
<p>Díky dobrému počasí toho člověk zas tak moc nepotřebuje. Jako boty stačí jen nějaké <strong>botasky</strong> na normální chození a pak se hodí nějaké <strong>pořádnější boty</strong> do hor. Do hor se taky málokdy hodí i teplejší oblečení, ale většinou to nebývá třeba (je třeba dodat, že moc na ostrově zima nebývá). Proto pokud letíte někdy v zimních termínech, tak se do letadla oblečte v dlouhém oblečení a jděte v pořádnějších botách a díky tomu věci, které zabírají nejvíce místa nemusíte mít v batohu.</p>
<p>Pak nějaké základní věci jako ručníky bývávají na ubytování (ale záleží kde jste ubytováni). Pak už snad jen plavky a normální oblečení do tepla. Popřípadě se vše dá dokoupit v místních obchodech, které poslední dobou bývají snad i levnější než v Česku.</p>
<p>Detaily psát nechci, jednak bych na něco určitě zapomněl a taky každý chce s sebou něco jiného, takže mi to nedává smysl.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cesta-letadlem"><a class="header" href="#cesta-letadlem">Cesta letadlem</a></h1>
<p>Přijde mi, že ne všichni mají nějaké nedávné zkušenosti s létáním. Pokud ale jo, tak tohle číst nemusíte.</p>
<h2 id="aerolinky"><a class="header" href="#aerolinky">Aerolinky</a></h2>
<p>Doporučené letové trasy za levné peníze jsou z Katowic a Vídně. Postupem času mohou být užitečné i nepřímé spoje z Prahy, ale není to vždy nejlevnější spojení.</p>
<p>Nějaké konkrétní tipy na aerolinky:</p>
<ul>
<li><a href="https://wizzair.com/">WIZZ Air</a></li>
<li><a href="https://www.ryanair.com/">Ryanair</a></li>
<li><a href="https://www.vueling.com/en">Vuelingu</a></li>
</ul>
<h2 id="cesta-na-letiště"><a class="header" href="#cesta-na-letiště">Cesta na letiště</a></h2>
<h3 id="katowice"><a class="header" href="#katowice">Katowice</a></h3>
<p>Klasicky se na letiště lze dostat autem, nicméně to je třeba pak zaparkovat. Například v Katowicích ve vedlejší vesnici <em>Pyrzowice</em> je spoustu domů, které mají místo zahrady parkoviště.</p>
<p>Alternativně se lze dopravit pomocí autobusů a vlaků. Myslím, že na letiště ve Vídní jezdí už přímo linky (minimálně z Brna) ale na letiště do Katowic už moc ne, ale tam jezdí místní <a href="https://rj.metropoliaztm.pl/rozklady/1-ap/76430/1/162106/">MHD</a> z hlavního nádraží na letiště. Lístky se dají koupit (i kartou, ale ne vždy) na nádraží.</p>
<ul>
<li><a href="https://www.flixbus.cz/">FlixBus</a></li>
<li><a href="https://www.studentagency.cz/">Student agency</a></li>
<li><a href="https://www.gepard.com/">Gepard express</a></li>
</ul>
<h3 id="vídeň"><a class="header" href="#vídeň">Vídeň</a></h3>
<p>V případě vídně je lepší použít hromadné dopravy, které jsem již dříve zmínil. Pokud byste chtěli jet autem, tak lze použít oficiální parkoviště, nicméně to bývá dražší. Dostal jsem doporučení na jedno parkoviště, které je celkem blízko a mělo by být levnější.</p>
<ul>
<li><a href="https://www.mazur-parken.at/en">Mazur parking</a></li>
</ul>
<h2 id="samotný-let"><a class="header" href="#samotný-let">Samotný let</a></h2>
<p>Na co je dobré upozornit (z vlastní zkušenosti) je lepší si vzít nějaké jídlo a pak buď na letišti (za kontrolou!) koupit pití anebo si vzít láhev a pak si ji naplnit. Popřípadě si lze občerstvení zakoupit v letadle, ale to si opět připlatíte.</p>
<p>Tohle snad nebude potřeba dodávat, ale na cestu letadlem si s sebou nesmíte do příručního zavazadla brát ostré nebo nebezpečné předměty a také nesmíte brát tekutiny. V případě tekutin je omezení myslím do 100 ml. Takže bacha třeba na kosmetiku.</p>
<p>Potom také v případě odbaveného zavazadla nesmí obsahovat baterie. Ty pak musí být v příručním zavazadle. Mimo jiné existuje i celkové omezení na velikost baterií, ale ty snad nikdo nepřesáhne.</p>
<p>Pokud s sebou budete brát jen normální věci, tak to nejhorší co se může stát je, že vám danou věc vyhodí. Aspoň budete mít pěknou historku.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="jak-se-pohybovat-po-ostrově"><a class="header" href="#jak-se-pohybovat-po-ostrově">Jak se pohybovat po ostrově</a></h2>
<p>Buď se dá půjčit auto. Proto jsou dobré půjčovny jako následující:</p>
<ul>
<li><a href="https://autoreisen.com/car-hire/car-hire.php">AutoReisen</a></li>
<li><a href="https://www.cicar.com/EN">Cicar</a></li>
<li><a href="https://www.pluscar-tenerife.com/booking.php?lang=en">PlusCar</a></li>
</ul>
<p>Jako další možnost je používat místní autobusy. Autobusy nemají až tak přísný řád, ale jezdí docela dost dobře. Pro ně je lepší si zařídit jejich kartičku <a href="https://tenmas.es/">TenMas</a>. Kartička se dá pořídit hned na letišti. Pak je většinou lepší si ji dát jako kreditní (<em>purse</em>) a nabýt si ji. Hlavní výhoda je, že pokud přestupujete, tak cena je o hodně levnější, protože se vlastně počítá celá cesta dohromady a ne dvě separátní cesty. Použití této karty je hodně jednoduché. Při vstupu si pípnete a <strong>PŘI VÝCHODU TAKY</strong> (na to se celkem často zapomíná, potom se bere jako cena až do konečné stanice). Pokud na kartu jede více lidí, tak je třeba předem říct řidiči kolik vás je a kam jedete. Následně pro hledání spojů se dá vyhledat přes <em>google maps</em> anebo použít jejich aplikaci <a href="https://play.google.com/store/apps/details?id=com.diodev.guaguas&amp;gl=US">Guaguas</a> (<em>už není moc funkční</em>) ale nehledal jsem jestli existuje i verze na iOS.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trasy-a-místa"><a class="header" href="#trasy-a-místa">Trasy a místa</a></h1>
<p>V textu zmiňuji <strong>Jih</strong> a <strong>Sever</strong> ostrova. Tato terminologie je tak, jak by člověk očekával. Přesněji to beru vůči Teide.</p>
<p>Také přidám <strong>GPX</strong> soubor s konkrétními místy, které budu v textu zmiňovat.</p>
<ul>
<li>Pár tras už jsem dal do toho co navštívit, ale je možné, že tady taky nějaké přidám. Jako hlavní zdroj doporučuji pro různé trasy pomocí <a href="https://www.geocaching.com/">Geocaching</a> a taky i někdy přímo <a href="https://wherigo.com/">WhereIGo</a>,ale to je vlastně spojené s Geocachingem také.</li>
<li>Takové doporučení jak si naplánovat den je, že ráno se vyjede někam na výlet a odpoledne se zajede na nějakou blízkou pláž a tam si člověk hodně odpočine.</li>
<li>Samozřejmě je potřeba nepřecenit svoje možnosti a taky nejlépe nejít sám a nepodcenit pitný režim. Možná bych ještě doporučil pokrývku hlavy. A taky v nějakých oblastech už není moc dobrý signál. Neznamená to, že máte mít satelitní telefon, ale nespoléhat se na připojení k internetu.</li>
<li>Je asi dobré si naplánovat svoje vlastní trasy, ale jako inspiraci přidám pár tras, které byly celkem pěkné.</li>
<li>Jinak jako aplikaci na mapy doporučuji klasické <a href="https://mapy.cz/">mapy.cz</a> které mají dobré turistické trasy a taky umí import/export gpx.</li>
</ul>
<h2 id="okolí-teide"><a class="header" href="#okolí-teide">Okolí Teide</a></h2>
<ul>
<li>Jedna kratší cesta poblíž výhledu <a href="tenerife/../../resources/Samara.gpx" title="resources/Samara.gpx">Samara</a>.</li>
<li>Pak výlet na horu <a href="tenerife/../../resources/Sombrero.gpx" title="resources/Sombrero.gpx">Sombrero</a> ze které je výhled na park Teide.</li>
<li>Pak ještě <a href="tenerife/../../resources/teide-view.gpx" title="resources/teide-view.gpx">trasa</a> poblíž, ale z opačné strany poblíž Roques de Garcia.</li>
</ul>
<h2 id="pohoří-anaga"><a class="header" href="#pohoří-anaga">Pohoří Anaga</a></h2>
<ul>
<li>Trasa okolo hory <a href="tenerife/../resources/Taborno.gpx" title="resources/Taborno.gpx">Taborno</a>.</li>
</ul>
<h2 id="pohoří-teno"><a class="header" href="#pohoří-teno">Pohoří Teno</a></h2>
<ul>
<li>Tady je jedna pěkná <a href="https://www.geocaching.com/geocache/GC65QKW">Where I Go</a> ohledně pána prstenů. Není potřeba přidat trasu ale popř. je to zhruba <a href="tenerife/../../resources/tlotr.gpx" title="resources/tlotr.gpx">tahle</a>.</li>
<li>Ještě je zajímavé jiné Where I Go také poblíž a to <a href="https://www.geocaching.com/geocache/GC8J7A3">reverzní keš</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="příroda"><a class="header" href="#příroda">Příroda</a></h2>
<p>Na celém ostrově je spoustu zajímavých přírodních úkazů. Při výběru berte v potaz to, jestli se bojíte výšek (nebo dokonce máte závratě). Většinu tras jsem osobně zvládl, ale každý má jiné hranice.\</p>
<h3 id="parque-national-del-teide"><a class="header" href="#parque-national-del-teide">Parque National del Teide</a></h3>
<p>Samozřejmostí je středobod Tenerife <a href="https://goo.gl/maps/qYmkyHaMSfNSbAkY7">Pico del Teide</a>. Pokud by se někdo chtěl dostat až na vrchol, tak je třeba si zajistit včas <a href="https://www.reservasparquesnacionales.es/real/ParquesNac/usu/html/listado-actividades-oapn.aspx?cen=2">permit</a>. A i tak to není zaručené kvůli počasí, protože nahoře můžou být klidně i závěje sněhu. Na samotný vrchol jezdí lanovka, ale lze zvolit i cestu po svých.</p>
<p>Dalším místem je <a href="https://goo.gl/maps/QTHVNU92jzp3gDeBA">Roques de Garcia</a>, což jsou skály uprostřed "pouště". Je tady jeden kratší <a href="tenerife/../../resources/garcia.gpx" title="resources/garcia.gpx">okruh</a>, který se dá jít, ale výrazně doporučuji jít daným směrem, kvůli výškovému profilu.</p>
<h3 id="anaga"><a class="header" href="#anaga">Anaga</a></h3>
<p>Celý sever je také hodně hornatý. Pohoří se jmenuje <a href="https://goo.gl/maps/Y49XMutjRv124ZSr7">Anaga</a>. Tady se dají najít zajímavé trasy. Ale cesta autem už je dost záživnější (jak když polechtáš hada #snake). A trasy už jsou také intenzivnější, ale s pěknými výhledy.</p>
<h3 id="teno"><a class="header" href="#teno">Teno</a></h3>
<p>Dalším pohořím je Teno ve kterém se mimo jiné nachází nejvýše postavená vesnice <a href="https://goo.gl/maps/byGNbp8r4mAbzukL8">Masca</a>. Ve které je taky <a href="tenerife/../../resources/masca.gpx" title="resources/masca.gpx">trasa</a> údolím. Cesta autem bývá jedna z těch nejhorších a to ne kvůli serpentinám, ale protože tam je velký provoz. Lze zvolit autobus a to někdy bývá i větší zážitek než cesta autem.</p>
<p>Součástí pohoří Teno jsou skály vysoce se tyčící přímo z oceánu  <a href="https://goo.gl/maps/oQFcwSWWEjWE9V1k6">Los Gigantes</a>. Pak zase záleží jak blízko chce člověk jít, protože se dá jít <a href="tenerife/../../resources/gigantes.gpx" title="resources/gigantes.gpx">trasa</a> po Los Gigantes.</p>
<h3 id="další"><a class="header" href="#další">Další</a></h3>
<p>Další v pořadí je <a href="https://www.barrancodelinfierno.es/en/">Barranco del Infierno</a>. Jedná se o celkem pěkné údolí akorát kvůli ne zas tak dávné nehodě se vstup hodně hlídá a člověk je nucen koupit si vstup a jít tam z helmou. Řekl bych, že to není zas tak zajímavé. Ale přišlo mi blbé to aspoň neříct.</p>
<p>Co mě ještě napadlo jsou skály známé jako <a href="https://goo.gl/maps/FZuzgERWUWpBjWQT7">Paisaje Lunar</a>("měsíční krajina"). Buď lze zastavit ve Vilafloru a jít celou trasu pěšky anebo se jde i více přiblížit autem, ale pokud dobře vím, tak tam není moc dobrá cesta vzhledem k povrchu.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="města"><a class="header" href="#města">Města</a></h2>
<p>Možná pokud by někdo chtěl navštívit spíše kulturu, tak pak zajímavá města by mohla být.</p>
<h3 id="garachico"><a class="header" href="#garachico">Garachico</a></h3>
<p>Městečko <a href="https://goo.gl/maps/mHCb6RYfBmf5BGFE7">Garachico</a> které kdysi bylo zalité lávou. Také zde jezdíme na <a href="https://goo.gl/maps/Xfbu3stRrEJknuax7">jídlo</a> (králík naložený v místní omáčce) a pak tu jsou přírodní bazénky, ale tam se mockrát nedá plavat, protože to tam je spíše jako v pračce. Pokud si náhodou někdy pamatuje, jak bývalo ve zprávách, že na Tenerife se kvůli bouři ničí baráky z přívalových vln, tak to bylo v těchto oblastech.</p>
<h3 id="candelarioa"><a class="header" href="#candelarioa">Candelarioa</a></h3>
<p>Další město je <a href="https://goo.gl/maps/6e3SA1BZ9FwFJ6JN6">Candelaria</a>. Tady je to hlavně známé svojí katedrálou (nebo co to je) a pokud si to správně pamatuji tak v ní je "černá Madonna".</p>
<h3 id="la-orotava"><a class="header" href="#la-orotava">La Orotava</a></h3>
<p>Dále bych řekl <a href="https://goo.gl/maps/T3zynzWUvovTTgLBA">La Orotava</a>, které je také dost pěkné a to svými parky.</p>
<h3 id="la-laguna"><a class="header" href="#la-laguna">La Laguna</a></h3>
<p>Nesmí chybět ani <a href="https://goo.gl/maps/xEwbv2aDbRi3DyDT6">La Laguna</a>, které je prakticky spojené i s hlavním městem <a href="https://goo.gl/maps/e9t6WvGBUK4GF4To7">Santa Cruz de Tenerife - hlavní město</a>. V La Laguně je hodně kostelů a pěkná architektury.</p>
<h3 id="santa-cruz-de-tenerife"><a class="header" href="#santa-cruz-de-tenerife">Santa Cruz de Tenerife</a></h3>
<h3 id="buenavista-del-norte"><a class="header" href="#buenavista-del-norte">Buenavista del Norte</a></h3>
<p>Jako poslední bych dodal asi <a href="https://goo.gl/maps/aKKuDLBAECqJuccF8">Buenovista del Norte</a> ani ne tím, že by to bylo pěkné město, ale vede odsuď cesta na severní cíp ostrova. To se musí ale už busem.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pláže"><a class="header" href="#pláže">Pláže</a></h2>
<p>Samozřejmě nesmí ani chybět pár známých pláží.</p>
<h3 id="severní-pobřeží"><a class="header" href="#severní-pobřeží">Severní pobřeží</a></h3>
<p>Na severnějším pobřežím pláže spíš bývají kamenité a také více divoké, za to nabízejí pěkné pohledy.</p>
<p>Nebo také se zde občas vyskytují "přírodní" bazénky např. <a href="https://goo.gl/maps/SQPZC5LWMhPEGWzk9">Bajamar</a> anebo v jak jsem říkal i v Garachicu.</p>
<h3 id="jižní-pobřeží"><a class="header" href="#jižní-pobřeží">Jižní pobřeží</a></h3>
<p>Pláže nacházející se na jižním pobřeží bývají spíše písečné a jsou spíše zaměřené pro turisty.</p>
<p>Za hlavním městem je <a href="https://goo.gl/maps/UnD8CAmhuvKnnt7u9">Playa de las Teresitas</a> která je asi největší pláž, nicméně je uměle vytvořená z písku ze Sahary.</p>
<p>Další je taky <a href="https://goo.gl/maps/8buUpg68wUNmJHkE6">Playa de la Tejita</a>, kterou si pamatuji tím, že tam byla asi tak nejteplejší voda (nevím čím to je). Ale bývá tam také větrno a velké vlny. K tomu pak patří i pláže v El Medanu. Tam je to spíše pro windsurfing.</p>
<p>Pak Pláže v <a href="https://goo.gl/maps/bB9e8AdtTUhw9VGE80">Los Cristianos (např.)</a> a také vedlejší <a href="https://goo.gl/maps/p4sZm2meg3KCcwbC9">Las Americas</a>, tady už není co dodat.</p>
<p>Významnou pláží je <a href="https://goo.gl/maps/A3bQHKSqsY8x4aQG7">Playa de la Arena</a> na které je černý písek. To nese i svoji špatnou stránku, protože může být až vařící a nedá se po něm chodit. Také zde bývají vlny. Ale jinak je to celkem menší pláž.</p>
<p>Dodám ještě kamenitou (ne štěrkovou) pláž poblíž žluté hory. Tato pláž je dobrá pro potápění.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vedlejší"><a class="header" href="#vedlejší">Vedlejší</a></h2>
<p>Jednou z nejznámější atrakcí je <a href="https://www.loroparque.com/index.php/en/">Loro Parque</a>, což je jednoduše řečeno velká zoo. Aby se to pořádně vyplatilo a člověk viděl vše, tak je to zhruba na celý den. Protože zde jsou naplánované všemožné show.</p>
<p>Podobný jako Loro Parque je <a href="https://www.siampark.net/index.php/en/">Siam Park</a> akorát tady se jedná o akvapark. Rozhodně se vyplatí jít během nějakého dne kdy není svátek nebo volno aby tam nebylo úplně narváno.</p>
<p>Pokud chcete klidně strávený den, tak jako možnost doporučuji si vyjet směrem k Teide a pak cestou se nachází u cesty "kempy" ve kterých je spousta volně dostupných "grilů". Člověk si musí přinést něco co dobře hoří a jídlo a cokoliv co chce. Pokud si správně pamatuji tak je tam přístup k vodě a také je tam toaleta. Jenom přidám jeden <a href="https://goo.gl/maps/VyYMBCxJ1tVeZEQLA">příklad</a> ale je jich tam více a na vícero cestách.</p>
<p><em>Nejspíše jsem toho spoustu vynechal, ale to už je na vás, abyste to našli sami.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="počasí"><a class="header" href="#počasí">Počasí</a></h1>
<p>Tady není moc co dodat. Během celého roku se teplota pohybuje kolem 25 stupňů. Samozřejmě není vždy zcela konstatní. Občas můžete narazit na studené noci s 16 stupni anebo zažít 40ti stupňové dny.</p>
<p>Je dobré dodat, že tohle se týká jižní části ostrova. Kvůli tomu jak uprostřed ostrova je Teide, tak vzniká to, že na severu častěji prší a také zde bývá trochu nižší teplota, ale ne s nějakým velkým rozdílem. Respektive dobrá rada je, že pokud na jedné části ostrova prší, tak na druhé nejspíše ne.</p>
<p>Ještě bych řekl, že občas nastane něco čemu místní říkají <strong>"Calima"</strong> a to je pro písek, který je kvůli bouři vynesen ze Sahary a dále putuje nejenom na Kanárské ostrovy. Pokud to nastane, tak je poznat, že ve vzduchu je písek a taky se zvýší teplota. Proto se moc nedoporučuje dělat fyzicky náročné aktivity. Jednak protože je hodně horko, ale taky člověk vdechuje písek.</p>
<p>Jako poslední (spíše taková zajímavost) je, že na Teide (popř. i v národním parku okolo Teide někdy může nasněžit. To ale není moc časté. Nicméně pokud se pojedé do národního parku podívat, tak u cest uvidíte dvojbarevné tyče, které slouží k použití pluhu.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="okolí-costa-del-silencio"><a class="header" href="#okolí-costa-del-silencio">Okolí Costa del Silencio</a></h1>
<p>Tady sepíšu to co je v okolí Costa del Silencio a Las Galletas, která se pár čtenářům může hodit.</p>
<h2 id="restaurace"><a class="header" href="#restaurace">Restaurace:</a></h2>
<p>Jednou z nejlevnějších je restaurace <a href="https://goo.gl/maps/3t8R4k3FGjeEEkBL7">3,60</a>. Bacha v pondělí mají zavřeno, ale jak název určuje, tak ceny jsou 3.60 EUR. (Snad se v blízké době neplánují přejmenovat.)</p>
<p>V blízkém okolí ve stejné ulici je spoustu dalších restaurací.</p>
<p>Pak také dobrá <a href="https://g.page/el-patio-del-coral?share">restaurace</a> kde dělají dobré speciality jako např. krevety na víně.</p>
<p>Ale myslím si, že vlastním výběrem nějaké jiné restaurace člověk neudělá chybu.</p>
<h2 id="obchody"><a class="header" href="#obchody">Obchody:</a></h2>
<ul>
<li>Jedním z nejlepších obchodů, který je sice dál je <a href="https://goo.gl/maps/wp2s7g8y9tYnRZYQ8">Mercadonna</a> což je přímo řetězec a existuje vícero míst kde tyhle obchody jsou, ale tenhle je poměrně blízko.</li>
<li>V docházkové vzdálenosti je taky <a href="https://goo.gl/maps/5zCdqZXhgD9STP2s7">HyperDino</a>, což je taky velký řetězec a tyto pobočky bývají skoro všude. A levnější, ale vzdálenější je <a href="https://maps.app.goo.gl/MsiFrkcgy76godm98">Superdino</a>.</li>
<li>A taky <a href="https://goo.gl/maps/7U93xPvPrC4DEchw7">Hermussa</a> kde mývají i jiné potraviny bližší českému.</li>
<li>Podstatný další místo je <a href="https://goo.gl/maps/TH3TqrZP95npKrZW7">rybí market</a>, kde skoro každý ráno mají čerstvé ryby.</li>
<li>Také v centru Las Galletas je místní obchod s ovocem a zeleninou, kde mají místní věci. Přesnou ulici si nepamatuji, ale aspoň si člověk může projít ne tak velké centrum.</li>
<li>Kdo by chtěl spíše obchod, který zná tak i v dojezdové vzdálenosti je <a href="https://goo.gl/maps/ZwaZ35cjsRfCVap1A">Lidl</a>.</li>
<li>Pak ještě na odlet většinou aerolinky vyžadují mít vytištěné letenky. Sice to většinou není zcela třeba, ale jsou zde místa podobné "internetovým kavárnám" kde mají i tiskárny. Jedna je poblíž <a href="https://goo.gl/maps/HvZCsYA1RXkQ9Twm9">tohoto místa</a> a jiná je taky v centrum Las Galletas. (Ani já už si nepamatuji v jaké ulici to přímo je.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fresh-instalation-of-debian-computer"><a class="header" href="#fresh-instalation-of-debian-computer">Fresh instalation of <a href="https://www.debian.org">Debian</a> computer.</a></h1>
<h1 id="my-bashrc"><a class="header" href="#my-bashrc">My <code>.bashrc</code></a></h1>
<pre><code class="language-bash">export EDITOR='nvim'
export VISUAL='nvim'

# Git aliases
alias gtpl='git pull'
alias gtps='git push'
alias gadd='git add .'
alias gcom='git commit'
alias gdif='git diff'

# Meson aliases
alias mess='meson setup build/'
alias mesc='meson compile -C build/'
alias mesi='meson install -C build/'

# Programming languages aliases
alias p='python3'
alias c='g++ -o main *.cpp'
alias h='ghci'
alias gor='go run *.go'
alias gof='go fmt *.go'

# Update and install Rust language.
alias rustinstall="curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"

# Update and install Scala lang.
alias scalainstall="curl -fL https://github.com/coursier/coursier/releases/latest/download/cs-x86_64-pc-linux.gz | gzip -d &gt; cs &amp;&amp; chmod +x cs &amp;&amp; ./cs setup"

# Update and install bun.
alias buninstall="curl -fsSL https://bun.sh/install | bash"
</code></pre>
<h1 id="instalation-of-all-apps"><a class="header" href="#instalation-of-all-apps">Instalation of all apps</a></h1>
<pre><code class="language-bash">apt update
apt upgrade

general="firefox-esr thunderbird vlc freefilesync neovim"
media="gimp inkscape handbrake kid3-qt asunder obs-studio"
chat="telegram-desktop"
kde="kdiff3 kdenlive k3b kate karbon krita krename"

office="texstudio libreoffice texlive-full pandoc ipe xournalpp ghostwriter calligra"
tools="screenfetch htop tree curl exiftool bleachbit"

dev="git python3 ruby"
cpp="cpp cppcheck meson cmake make valgrind doxygen"
java="default-jre default-jdk"
math="sagemath octave jupyter polymake"
go="golang gopls"
perl="perl"
haskell="ghc ghc-prof ghc-doc"
prolog="swi-prolog-full"

apps="$general $media $chat $kde $office $tools $dev $cpp $java $math $go $perl $haskell $prolog"
apt install $apps

rustinstall
scalainstall

cargo install juliaup
cargo install mdbook
rustup install rust-analyzer
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boj-proti-dezinformacím"><a class="header" href="#boj-proti-dezinformacím">Boj proti dezinformacím</a></h1>
<p>Tady je můj menší seznam stránek a zdrojů, které slouží proti šíření dezinformací.</p>
<ul>
<li>Uskupení <a href="https://cesti-elfove.cz/">čeští elfové</a> a jejich projekt <a href="https://eldariel.cesti-elfove.cz/">Eldariel</a> monitorující řetězové maily.</li>
<li>Fact checker <a href="https://demagog.cz/">Demagog</a>.</li>
<li>Informace o dezinformacích:
<ul>
<li><a href="https://www.fakticke.info/">Fakticke info</a></li>
<li><a href="https://manipulatori.cz/">Manipulátoři</a></li>
</ul>
</li>
</ul>
<p>Obecně je dobré se opírat o již plně fungující instituce, jako je třeba <a href="https://www.avcr.cz/cs/">Akademie věd</a>.</p>
<p>Dále také doporučuji si poslechnout <a href="https://www.kanarci.online/">Kanárky v síti</a>.</p>
<p>Dodatečně se zatím jen podporuje a vytváří <a href="https://www.donio.cz/neskakej-jim-na-spek">nový projekt</a>.</p>
<h1 id="satira-sarkasmus-a-ironie"><a class="header" href="#satira-sarkasmus-a-ironie">Satira, sarkasmus a ironie</a></h1>
<p>Pokudněkoho baví používá sarkasmus a satiru, tak si můžete přečíst paper na <a href="./resources/fialova.pdf">fialovou</a> barvu.</p>
<p>Popřípadě doporučuji <a href="https://paralelnilisty.cz/">paralelní listy</a>.</p>
<p>Nebo oproti standardní <a href="https://en.wikipedia.org/wiki/Main_Page">Wikipedii</a> se můžete podívat na informace z <a href="https://necyklopedie.org/">Necyklopedie</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="movies"><a class="header" href="#movies">Movies</a></h1>
<p>There is a list of movies or series.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Links</th></tr></thead><tbody>
<tr><td style="text-align: center">The Big Lebowski</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Dune</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Dune: Part Two</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Inherent Vice</td><td style="text-align: center"><a href="https://www.imdb.com/title/tt1791528/">IMDB</a></td></tr>
<tr><td style="text-align: center">Last Looks</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Kiss Kiss Bang Bang</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Everything Everywhere All at Once</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Grand Budapest Hotel</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">See How They Run</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Seven Psychopaths</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Scott Pilgrim vs. the World</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Big Trouble in Little China</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Man Who Killed Don Quixote</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Godfather</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Godfather part II</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Godfather part III</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Pulp Fiction</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Kill Bill: Vol. 1</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Kill Bill: Vol. 2</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Knives Out</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Glass Onion: A Knives Out Mystery</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Fight club</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Druk</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">American History X</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">12 Angry Men</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Spider-Man: Into the Spider-Verse</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Spider-Man: Across the Spider-Verse</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Puss in Boots: The Last Wish</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Dungeons &amp; Dragons: Honor Among Thieves</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Basic Instinct</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Deadpool &amp; Wolverine</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Hitchhiker's Guide to the Galaxy</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Monty Python and the Holy Grail</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Life of Brian</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Kingsman: The Secret Service</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Kingsman: The Golden Circle</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Argylle</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Bullet Train</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Planet Terror</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Guardians of the Galaxy</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Guardians of the Galaxy Vol. 2</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Guardians of the Galaxy Vol. 3</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Confess Fletch</td><td style="text-align: center"></td></tr>
</tbody></table>
</div><!--
| Willys Wonderland                       |                                               |
| Sfárej a zemřeš: Prokletí důlní chobotnice |                                            |
-->
<h2 id="simple-comedies"><a class="header" href="#simple-comedies">Simple comedies</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Links</th></tr></thead><tbody>
<tr><td style="text-align: center">Dumb and Dumber</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Dumb and Dumber To</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">A Million Ways to Die in the West</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">You Don't Mess with the Zohan</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Napoleon Dynamite</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Top Secret!</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Airplane!</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Airplane II: The Sequel</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Little Nicky</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Zoolander</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Zoolander 2</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sur la piste du Marsupilami</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Poliziotto superpiù</td><td style="text-align: center"><a href="https://www.imdb.com/title/tt0082924/">IMDB</a></td></tr>
<tr><td style="text-align: center">Masterminds</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Spy Hard</td><td style="text-align: center"><a href="https://www.imdb.com/title/tt0117723/">IMDB</a></td></tr>
<tr><td style="text-align: center">Hunt for the Wilderpeople</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Tropic Thunder</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Spaceballs</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Mystery Men</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Hot Rod</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Hot Shots!</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Hot Shots! Part Deux</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Naked Gun: From the Files of Police Squad!</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Naked Gun 2½: The Smell of Fear</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Naked Gun 33⅓: The Final Insult</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Nacho Libre</td><td style="text-align: center"><a href="https://www.imdb.com/title/tt0457510/">IMDB</a></td></tr>
</tbody></table>
</div>
<h2 id="musicals"><a class="header" href="#musicals">Musicals</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Links</th></tr></thead><tbody>
<tr><td style="text-align: center">Corpse Bride</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sweeney Todd: The Demon Barber of Fleet Street</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">West Side Story</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Chicago</td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<h2 id="series"><a class="header" href="#series">Series</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Links</th></tr></thead><tbody>
<tr><td style="text-align: center">Red Dwarf</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">IT Crowd</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Parks and Recreation</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Office</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Toast of London</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Toast of</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Boys</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Invincible</td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<h2 id="shark-b-movies"><a class="header" href="#shark-b-movies">Shark B-movies</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Links</th></tr></thead><tbody>
<tr><td style="text-align: center">Trailer Park Shark</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sharknado</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sharknado 2: The Second One</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sharknado 3: Oh Hell No!</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sharknado 4: The 4th Awakens</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sharknado 5: Global Swarming</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Last Sharknado: It's About Time</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">6-Headed Shark Attack</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Shark Side of the Moon</td><td style="text-align: center"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="books"><a class="header" href="#books">Books</a></h1>
<p>There is a table of books, that I have read. I know not a big list, but it will keep on growing, hopefully.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Author</th><th>ISBN</th></tr></thead><tbody>
<tr><td>Nanos</td><td>Timo Leibig</td><td>978-80-7585-527-5</td></tr>
<tr><td>Práskač</td><td>Jan-Erik Fjell</td><td>978-80-7390-790-7</td></tr>
<tr><td>Pokoj stínů</td><td>Jan-Erik Fjell</td><td>978-80-7585-175-8</td></tr>
<tr><td>Mstitel</td><td>Jan-Erik Fjell</td><td>978-80-7585-190-1</td></tr>
<tr><td>Predátor</td><td>Jan-Erik Fjell</td><td>978-80-7585-191-8</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code"><a class="header" href="#advent-of-code">Advent of code</a></h1>
<p>They are my solutions to <a href="https://adventofcode.com/">advent of code</a> tasks. There are separated to each year and day. All of this can be found on <a href="https://github.com/metury/advent-of-code">GitHub</a>, also with the script that generates these pages.
Plus you may also play a small <a href="https://aoc-bingo.fly.dev/">Bingo</a> that someone made. Also you may consider joining <a href="https://www.reddit.com/r/adventofcode/">Reddit</a> where you may find useful tips, or help someone.</p>
<h3 id="years"><a class="header" href="#years">Years</a></h3>
<ul>
<li><a href="./aoc/2024.html">Year 2024</a></li>
<li><a href="./aoc/2023.html">Year 2023</a></li>
<li><a href="./aoc/2022.html">Year 2022</a></li>
<li><a href="./aoc/2021.html">Year 2021</a></li>
<li><a href="./aoc/2017.html">Year 2017</a></li>
<li><a href="./aoc/2016.html">Year 2016</a></li>
<li><a href="./aoc/2015.html">Year 2015</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024"><a class="header" href="#advent-of-code---year-2024">Advent of code - Year 2024</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2024">year 2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information"><a class="header" href="#information">Information</a></h3>
<p>In this years advent of code I will try to use <code>go</code> <a href="https://go.dev">programming language</a> to solve all problems. Lets see how far I will get by doing so.</p>
<p>Beside solving each problem I will be focusing on the readability of the code.</p>
<h3 id="days"><a class="header" href="#days">Days</a></h3>
<ul>
<li><a href="aoc/2024-1.html">Day 1</a></li>
<li><a href="aoc/2024-2.html">Day 2</a></li>
<li><a href="aoc/2024-3.html">Day 3</a></li>
<li><a href="aoc/2024-4.html">Day 4</a></li>
<li><a href="aoc/2024-5.html">Day 5</a></li>
<li><a href="aoc/2024-6.html">Day 6</a></li>
<li><a href="aoc/2024-7.html">Day 7</a></li>
<li><a href="aoc/2024-8.html">Day 8</a></li>
<li><a href="aoc/2024-9.html">Day 9</a></li>
<li><a href="aoc/2024-10.html">Day 10</a></li>
<li><a href="aoc/2024-11.html">Day 11</a></li>
<li><a href="aoc/2024-12.html">Day 12</a></li>
<li><a href="aoc/2024-13.html">Day 13</a></li>
<li><a href="aoc/2024-14.html">Day 14</a></li>
<li><a href="aoc/2024-15.html">Day 15</a></li>
<li><a href="aoc/2024-16.html">Day 16</a></li>
<li><a href="aoc/2024-17.html">Day 17</a></li>
<li><a href="aoc/2024-18.html">Day 18</a></li>
<li><a href="aoc/2024-19.html">Day 19</a></li>
<li><a href="aoc/2024-20.html">Day 20</a></li>
<li><a href="aoc/2024-21.html">Day 21</a></li>
<li><a href="aoc/2024-22.html">Day 22</a></li>
<li><a href="aoc/2024-23.html">Day 23</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-1"><a class="header" href="#advent-of-code---year-2024-day-1">Advent of code - Year 2024 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/1">day 1</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-1"><a class="header" href="#information-1">Information</a></h3>
<h4 id="part-1"><a class="header" href="#part-1">Part 1</a></h4>
<p>In the first part we only compute the absolute difference in a sorted lists.</p>
<h4 id="part-2"><a class="header" href="#part-2">Part 2</a></h4>
<p>In the second part we create a map for the second column, where keys are the numers and value is the number of occurances. Then proceed in the first column and compute the value.</p>
<h2 id="maingo"><a class="header" href="#maingo">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "math"
  "os"
  "regexp"
  "sort"
  "strconv"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) ([]int, []int) {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  regex := regexp.MustCompile("([0-9]+)\\s+([0-9]+)")
  found := regex.FindAllStringSubmatch(string(content), -1)
  var first_column []int
  var second_column []int
  for _, f := range found {
    nr1, _ := strconv.Atoi(f[1])
    nr2, _ := strconv.Atoi(f[2])
    first_column = append(first_column, nr1)
    second_column = append(second_column, nr2)
  }
  sort.Ints(first_column)
  sort.Ints(second_column)
  return first_column, second_column
}

func count(list *[]int) map[int]int {
  my_map := make(map[int]int)
  for _, val := range *list {
    if i, ok := my_map[val]; ok {
      my_map[val] = i + 1
    } else {
      my_map[val] = 1
    }
  }
  return my_map
}

func part_one() {
  var result int
  start := time.Now()
  first_column, second_column := read_file("INPUT")
  for i := range first_column {
    difference := math.Abs(float64(first_column[i] - second_column[i]))
    result += int(difference)
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  first_column, second_column := read_file("INPUT")
  second_map := count(&amp;second_column)
  for _, key := range first_column {
    i, ok := second_map[key]
    if ok {
      result = result + key*i
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "1 - Historian Hysteria" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-2"><a class="header" href="#advent-of-code---year-2024-day-2">Advent of code - Year 2024 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/2">day 2</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-2"><a class="header" href="#information-2">Information</a></h3>
<h4 id="part-1-1"><a class="header" href="#part-1-1">Part 1</a></h4>
<p>We will always create an array of arrays. Then we create a closure which will remember the last state. Then we always check whether it is inside bounds for the limit and also if it is increasing or decreasing. For those we wil have two closures. Later on it was rewritten into one closure.</p>
<h4 id="part-2-1"><a class="header" href="#part-2-1">Part 2</a></h4>
<p>For the second part I added toleration. That is we can skip one element <strong>inside</strong> the array. But we have to take care also about the case where <em>the first element</em> can be omitted, therefore I will call two closures. Hence it is not bruteforcing all possible missing indices, but I am considering only two cases.</p>
<h2 id="maingo-1"><a class="header" href="#maingo-1">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "math"
  "os"
  "strconv"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

const LIMIT int = 3

func read_file(file_path string) [][]int {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var res [][]int
  splited := strings.Split(string(content), "\n")
  for i, el := range splited {
    level := strings.Split(el, " ")
    if len(el) == 0 {
      continue
    }
    res = append(res, make([]int, len(level)))
    for j, val := range level {
      res[i][j], _ = strconv.Atoi(val)
    }
  }
  return res
}

func comparing(tolerate bool, start int, compare func(int, int) bool) func(int) bool {
  current := start
  last := true
  tol := tolerate
  return func(x int) bool {
    diff := int(math.Abs(float64(current - x)))
    if tol &amp;&amp; (!compare(x, current) || diff &gt; LIMIT) {
      tol = false
    } else {
      last = compare(x, current) &amp;&amp; last &amp;&amp; diff &lt;= LIMIT
      current = x
    }
    return last
  }
}

func increasing(tolerate bool, start int) func(int) bool {
  greeater_than := func(x, y int) bool {
    return x &gt; y
  }
  return comparing(tolerate, start-1, greeater_than)
}

func decreasing(tolerate bool, start int) func(int) bool {
  less_than := func(x, y int) bool {
    return x &lt; y
  }
  return comparing(tolerate, start+1, less_than)
}

func increasing_or_decreasing(tolerate bool, level *[]int) bool {
  i := increasing(tolerate, (*level)[0])
  d := decreasing(tolerate, (*level)[0])
  incr, decr := true, true
  for _, val := range *level {
    incr = incr &amp;&amp; i(val)
    decr = decr &amp;&amp; d(val)
  }
  return incr || decr
}

func part_one() {
  var result int
  start := time.Now()
  levels := read_file("INPUT")
  for _, level := range levels {
    if increasing_or_decreasing(false, &amp;level) {
      result += 1
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  levels := read_file("INPUT")
  for _, level := range levels {
    level_without_first := level[1:]
    if increasing_or_decreasing(true, &amp;level) || increasing_or_decreasing(false, &amp;level_without_first) {
      result += 1
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "2 - Red-Nosed Reports" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-3"><a class="header" href="#advent-of-code---year-2024-day-3">Advent of code - Year 2024 Day 3</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/3">day 3</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-3"><a class="header" href="#information-3">Information</a></h3>
<h4 id="part-1-2"><a class="header" href="#part-1-2">Part 1</a></h4>
<p>In the first part we only match the regex <code>mul\(([0-9]{1,3}),([0-9]{1,3})\)</code> and compute the result.</p>
<h4 id="part-2-2"><a class="header" href="#part-2-2">Part 2</a></h4>
<p>In the second part we also add <code>do()|don't()</code> and iterate over found values. If we find <code>do()</code> enable computing otherwise for <code>don't()</code> disable it. Then compute the result.</p>
<h2 id="maingo-2"><a class="header" href="#maingo-2">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "strconv"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) string {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  return string(content)
}

func part_one() {
  var result int
  var content = read_file("INPUT")
  start := time.Now()
  regex := regexp.MustCompile("mul\\(([0-9]{1,3}),([0-9]{1,3})\\)")
  found := regex.FindAllStringSubmatch(content, -1)
  for _, f := range found {
    nr1, _ := strconv.Atoi(f[1])
    nr2, _ := strconv.Atoi(f[2])
    result += nr1 * nr2
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  content := read_file("INPUT")
  start := time.Now()
  regex := regexp.MustCompile("do\\(\\)|don't\\(\\)|mul\\(([0-9]{1,3}),([0-9]{1,3})\\)")
  found := regex.FindAllStringSubmatch(content, -1)
  enabled := true
  for _, f := range found {
    switch f[0] {
    case "do()":
      enabled = true
    case "don't()":
      enabled = false
    default:
      if enabled {
        nr1, _ := strconv.Atoi(f[1])
        nr2, _ := strconv.Atoi(f[2])
        result += nr1 * nr2
      }
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "3 - Mull It Over" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-4"><a class="header" href="#advent-of-code---year-2024-day-4">Advent of code - Year 2024 Day 4</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/4">day 4</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-4"><a class="header" href="#information-4">Information</a></h3>
<h4 id="part-1-3"><a class="header" href="#part-1-3">Part 1</a></h4>
<p>In the first part we create way bigger text by adding its transposition (for vertical ones) and also we add the main and second diagonal (by swapping the order of lines and diagonalization). Lastly we replace all <code>S</code> by <code>SS</code> and <code>X</code> by <code>XX</code> for the overlaping cases. Now for this text we run regex <code>XMAS|SAMX</code> and count the occurances.</p>
<h4 id="part-2-3"><a class="header" href="#part-2-3">Part 2</a></h4>
<p>In the second part we used different approach. That is we iterate over the matrix and if we find <code>A</code> in the middle we create diagonal words and check if they are <code>SAM|MAS</code>.</p>
<h2 id="maingo-3"><a class="header" href="#maingo-3">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) string {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  return string(content)
}

// Create a table from the input.
func tabelize(text *string) [][]string {
  lines := strings.Split(*text, "\n")
  var table [][]string
  for _, line := range lines {
    if len(line) &gt; 0 {
      table = append(table, strings.Split(line, ""))
    }
  }
  return table
}

// Transpose the text as a matrix.
func transpose(text *string) string {
  var builder strings.Builder
  table := tabelize(text)
  for i := range table[0] {
    for j := range table {
      builder.WriteString(string(table[j][i]))
    }
    builder.WriteString("\n")
  }
  return builder.String()
}

// Create all diagonals of the text.
func diag(text *string) string {
  var builder strings.Builder
  table := tabelize(text)
  for i := len(table[0]) - 1; i &gt;= 0; i-- {
    for j := 0; j+i &lt; len(table[0]); j++ {
      builder.WriteString(table[j][j+i])
    }
    builder.WriteString("\n")
  }
  for i := len(table) - 1; i &gt; 0; i-- {
    for j := 0; j+i &lt; len(table); j++ {
      builder.WriteString(table[i+j][j])
    }
    builder.WriteString("\n")
  }
  return builder.String()
}

// Swap the order of lines.
func swap(text *string) string {
  var builder strings.Builder
  lines := strings.Split(*text, "\n")
  for i := len(lines) - 1; i &gt;= 0; i-- {
    builder.WriteString(lines[i])
    builder.WriteString("\n")
  }
  return builder.String()
}

// Replace all S by SS and X by XX.
func replace(text *string) string {
  s := regexp.MustCompile("S")
  x := regexp.MustCompile("X")
  return x.ReplaceAllString(s.ReplaceAllString(*text, "SS"), "XX")
}

func count_xmas(text *string) int {
  regex := regexp.MustCompile("XMAS|SAMX")
  found := regex.FindAllString(*text, -1)
  if found == nil {
    return 0
  }
  return len(found)
}

func count_x_mas(table [][]string) int {
  res := 0
  for i := 1; i &lt; len(table)-1; i++ {
    for j := 1; j &lt; len(table[i])-1; j++ {
      if table[i][j] == "A" {
        first_word := table[i-1][j-1] + table[i][j] + table[i+1][j+1]
        second_word := table[i-1][j+1] + table[i][j] + table[i+1][j-1]
        regex := regexp.MustCompile("MAS|SAM")
        if regex.FindAllString(first_word, 1) != nil &amp;&amp; regex.FindAllString(second_word, 1) != nil {
          res += 1
        }
      }
    }
  }
  return res
}

func part_one() {
  var result int
  var content = read_file("INPUT")
  start := time.Now()
  var builder strings.Builder
  swapped := swap(&amp;content)
  builder.WriteString(content)
  builder.WriteString("\n")
  builder.WriteString(transpose(&amp;content))
  builder.WriteString("\n")
  builder.WriteString(diag(&amp;content))
  builder.WriteString("\n")
  builder.WriteString(diag(&amp;swapped))
  text := builder.String()
  text = replace(&amp;text)
  result = count_xmas(&amp;text)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  var content = read_file("INPUT")
  start := time.Now()
  table := tabelize(&amp;content)
  result = count_x_mas(table)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "4 - Ceres Search" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-5"><a class="header" href="#advent-of-code---year-2024-day-5">Advent of code - Year 2024 Day 5</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/5">day 5</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-5"><a class="header" href="#information-5">Information</a></h3>
<h4 id="part-1-4"><a class="header" href="#part-1-4">Part 1</a></h4>
<p>For both cases we read the file via regex and filter out the wrong sequences and good sequences. That is for each page in single order we check previous pages if they violate some rules. Then we just compute the sum of middle pages.</p>
<h4 id="part-2-4"><a class="header" href="#part-2-4">Part 2</a></h4>
<p>For the second part we consider only the incorrect ones. We go by pages and check their violations. If we find some we put the vilated pages behind the current page while removing the violated ones. And proceed by the corrected page onwards, because the pages inserted afterward may be wrong.</p>
<pre><code class="language-txt">-----------
| |X| |O| |
-----------
   ^   ^
   j   k

---------
| | |O| |
---------
   ^ ^
   j k


-----------
| | |O|X| |
-----------
	 ^
	 k
</code></pre>
<h2 id="maingo-4"><a class="header" href="#maingo-4">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "strconv"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) (map[int][]int, [][]int) {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  rules_regex := regexp.MustCompile("([0-9]+)\\|([0-9]+)")
  ordering_regex := regexp.MustCompile("(:?[0-9]+,)+[0-9]+")
  rules := make(map[int][]int)
  found_rules := rules_regex.FindAllStringSubmatch(string(content), -1)
  for _, rule := range found_rules {
    first, _ := strconv.Atoi(rule[1])
    second, _ := strconv.Atoi(rule[2])
    val, ok := rules[first]
    if ok {
      rules[first] = append(val, second)
    } else {
      rules[first] = []int{second}
    }
  }
  var orders [][]int
  found_orders := ordering_regex.FindAllString(string(content), -1)
  for _, order := range found_orders {
    splited := strings.Split(order, ",")
    var order_nr []int
    for _, s := range splited {
      number, _ := strconv.Atoi(s)
      order_nr = append(order_nr, number)
    }
    orders = append(orders, order_nr)
  }
  return rules, orders
}

func filter(rules map[int][]int, orders [][]int) ([][]int, [][]int) {
  var correct [][]int
  var incorrect [][]int
outer:
  for _, order := range orders {
    for i, page := range order {
      rule, ok := rules[page]
      if ok {
        for _, prev := range order[:i] {
          for _, r := range rule {
            if r == prev {
              incorrect = append(incorrect, order)
              continue outer
            }
          }
        }
      }
    }
    correct = append(correct, order)
  }
  return correct, incorrect
}

func fix(rules map[int][]int, order []int) []int {
  for k := 0; k &lt; len(order); k++ {
    var wrong []int
    rule, ok := rules[order[k]]
    if ok {
      for j := 0; j &lt; k; j++ {
        prev := order[j]
        for _, r := range rule {
          if prev == r {
            wrong = append(wrong, prev)
            order = append(order[:j], order[j+1:]...)
            k--
            j--
          }
        }
      }
    }
    if len(wrong) &gt; 0 {
      var fixed []int
      fixed = append(fixed, order[:k+1]...)
      fixed = append(fixed, wrong[:]...)
      fixed = append(fixed, order[k+1:]...)
      order = fixed
    }
  }
  return order
}

func part_one() {
  var result int
  rules, orders := read_file("INPUT")
  start := time.Now()
  correct, _ := filter(rules, orders)
  for _, cor := range correct {
    result += cor[len(cor)/2]
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  rules, orders := read_file("INPUT")
  start := time.Now()
  _, incorrect := filter(rules, orders)
  for _, inc := range incorrect {
    result += fix(rules, inc)[len(inc)/2]
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "5 - Print Queue" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-6"><a class="header" href="#advent-of-code---year-2024-day-6">Advent of code - Year 2024 Day 6</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/6">day 6</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-6"><a class="header" href="#information-6">Information</a></h3>
<h4 id="part-1-5"><a class="header" href="#part-1-5">Part 1</a></h4>
<p>In the first part we only simulate the steps of the guard and mark visited places on the map. Afterward we count the number of such visited places.</p>
<h4 id="part-2-5"><a class="header" href="#part-2-5">Part 2</a></h4>
<p>In the second part we also compute the visited places as in previous step to see candidates for obstacles. Because we may easily see that putting an obstacle outside the path is worthless. Then we put the obstacle into the map and test if we find loop or not. If so count such instance and move on. <em>Note that this is not close to optimal solution, since we are computing the prefix of the path over and over again. It would be good idea to remember previous path to not compute it again.</em> On the other hand given solution terminates with the result after a few seconds (approximately 3s), therefore it is not worth the time to optimize the code. <strong>After using <code>goroutines</code> I got way faster approach which is efficient enough.</strong></p>
<h2 id="maingo-5"><a class="header" href="#maingo-5">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

type Map [][]bool
type Position [2]int

var INVALID_POSITION [2]int = [2]int{-1, -1}

func read_file(file_path string) (Map, Position) {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  lines := strings.Split(string(content), "\n")
  var m (Map)
  var pos Position
  for i, line := range lines {
    if len(line) &lt;= 0 {
      continue
    }
    row := make([]bool, len(line))
    for j, char := range strings.Split(line, "") {
      switch char {
      case ".":
        row[j] = true
      case "#":
        row[j] = false
      case "^":
        pos = [2]int{i, j}
        row[j] = true
      }
    }
    m = append(m, row)
  }
  return m, pos
}

func guard_step(m Map, pos, step, obstacle Position) (Position, Position, bool) {
  new_pos := [2]int{pos[0] + step[0], pos[1] + step[1]}
  inside := new_pos[0] &lt; len(m) &amp;&amp; new_pos[0] &gt;= 0 &amp;&amp; new_pos[1] &lt; len(m[0]) &amp;&amp; new_pos[1] &gt;= 0
  if inside {
    in_map := m[new_pos[0]][new_pos[1]] &amp;&amp; (new_pos[0] != obstacle[0] || new_pos[1] != obstacle[1])
    if in_map {
      return new_pos, step, true
    } else {
      step[0], step[1] = step[1], -step[0]
      return pos, step, true
    }
  } else {
    return new_pos, step, false
  }
}

func found_visited(m Map, pos Position) Map {
  visited := make(Map, len(m))
  for i := range visited {
    visited[i] = make([]bool, len(m[i]))
  }
  visited[pos[0]][pos[1]] = true
  step := [2]int{-1, 0}
  pos, step, ok := guard_step(m, pos, step, INVALID_POSITION)
  for ok {
    visited[pos[0]][pos[1]] = true
    pos, step, ok = guard_step(m, pos, step, INVALID_POSITION)
  }
  return visited
}

func is_loop(m Map, pos, obstacle Position, c chan bool) {
  visited := make(map[[4]int]bool)
  step := [2]int{-1, 0}
  visited[[4]int{pos[0], pos[1], step[0], step[1]}] = true
  pos, step, ok := guard_step(m, pos, step, obstacle)
  hash_ok := false
  for ok &amp;&amp; !hash_ok {
    _, hash_ok = visited[[4]int{pos[0], pos[1], step[0], step[1]}]
    visited[[4]int{pos[0], pos[1], step[0], step[1]}] = true
    pos, step, ok = guard_step(m, pos, step, obstacle)
  }
  c &lt;- hash_ok
}

func part_one() {
  var result int
  start := time.Now()
  m, pos := read_file("INPUT")
  visited := found_visited(m, pos)
  for i := range visited {
    for j := range visited[i] {
      if visited[i][j] {
        result += 1
      }
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  m, pos := read_file("INPUT")
  visited_map := found_visited(m, pos)
  var visited_pos [][2]int
  for i := range visited_map {
    for j := range visited_map[i] {
      if visited_map[i][j] {
        visited_pos = append(visited_pos, [2]int{i, j})
      }
    }
  }
  c := make(chan bool)
  for _, obstacle := range visited_pos {
    go is_loop(m, pos, obstacle, c)
  }
  for i := 0; i &lt; len(visited_pos); i++ {
    if &lt;-c {
      result += 1
    }
  }
  close(c)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "6 - Guard Gallivant" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-7"><a class="header" href="#advent-of-code---year-2024-day-7">Advent of code - Year 2024 Day 7</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/7">day 7</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-7"><a class="header" href="#information-7">Information</a></h3>
<h4 id="part-1-6"><a class="header" href="#part-1-6">Part 1</a></h4>
<p>Generally we proceed by recursion. That is we pass the <code>equation</code>, <code>index</code> and <code>accumulator</code>. Then we continue and both use <code>+</code> and <code>*</code> operations. If we have <code>accumulator &gt; result</code> we cut of the computation.</p>
<h4 id="part-2-6"><a class="header" href="#part-2-6">Part 2</a></h4>
<p>In the second part we only add <code>concat(int, int) int</code> function. Today I also implement it with <code>goroutines</code>.</p>
<h2 id="maingo-6"><a class="header" href="#maingo-6">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strconv"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

type Equation struct {
  result int
  operands []int
}

func read_file(file_path string) []Equation {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  lines := strings.Split(string(content), "\n")
  var equations []Equation
  for _, line := range lines {
    if len(line) == 0 {
      continue
    }
    parts := strings.Split(line, " ")
    result, _ := strconv.Atoi(parts[0][:len(parts[0])-1])
    var numbers []int
    for _, part := range parts[1:] {
      nr, _ := strconv.Atoi(part)
      numbers = append(numbers, nr)
    }
    equations = append(equations, Equation{result, numbers})
  }
  return equations
}

func concat(x, y int) int {
  res, _ := strconv.Atoi(strconv.Itoa(x) + strconv.Itoa(y))
  return res
}

func solve(eq Equation, acc, i int) bool{
  if i &lt; len(eq.operands) &amp;&amp; acc &gt; eq.result {
    return false
  }
  if i == len(eq.operands) {
    return eq.result == acc
  }
  return solve(eq, acc + eq.operands[i], i+1) || solve(eq, acc * eq.operands[i], i+1)
}

func solve_concat(eq Equation, acc, i int) bool {
  if i &lt; len(eq.operands) &amp;&amp; acc &gt; eq.result {
    return false
  }
  if i == len(eq.operands) {
    return eq.result == acc
  }
  return solve_concat(eq, acc + eq.operands[i], i+1) || solve_concat(eq, acc * eq.operands[i], i+1) || solve_concat(eq, concat(acc, eq.operands[i]), i+1)
}

func common_solve(eq Equation, solver func(Equation, int, int) bool, c chan int) {
  if solver(eq, 0, 0) {
    c &lt;- eq.result
  } else {
    c &lt;- 0
  }
}

func part_one() {
  var result int
  start := time.Now()
  equations := read_file("INPUT")
  c := make(chan int)
  for _, eq := range equations {
    go common_solve(eq, solve, c)
  }
  for i := 0; i &lt; len(equations); i++ {
    result += &lt;-c
  }
  close(c)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  equations := read_file("INPUT")
  c := make(chan int)
  for _, eq := range equations {
    go common_solve(eq, solve_concat, c)
  }
  for i := 0; i &lt; len(equations); i++ {
    result += &lt;-c
  }
  close(c)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "7 - Bridge Repair" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-8"><a class="header" href="#advent-of-code---year-2024-day-8">Advent of code - Year 2024 Day 8</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/8">day 8</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-8"><a class="header" href="#information-8">Information</a></h3>
<h4 id="part-1-7"><a class="header" href="#part-1-7">Part 1</a></h4>
<p>For both cases we go through the map and collect the positions of each antenna type. Then in the first part we go through the antennas of the same type and take two of them. Calculating their difference and later on using this difference to either <code>subtrack</code> or <code>add</code> to the position of antenna. Only checking if it is inside a map, if so add it to the list of nodes. Finally return the size of collected nodes.</p>
<h4 id="part-2-7"><a class="header" href="#part-2-7">Part 2</a></h4>
<p>In the second part we use similar approach only that we also add the given antennas to the list of nodes. Then we do not calculate just one antinode, but instead loop until we jump out of the map. With the same difference and operation.</p>
<h2 id="maingo-7"><a class="header" href="#maingo-7">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

type Position [2]int

func read_file(file_path string) (map[string][]Position, int) {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  m := make(map[string][]Position)
  size := 0
  for i, line := range strings.Split(string(content), "\n") {
    if len(line) == 0 {
      continue
    }
    size += 1
    chars := strings.Split(line, "")
    for j, c := range chars {
      if c != "." {
        val, ok := m[c]
        if ok {
          m[c] = append(val, [2]int{i, j})
        } else {
          m[c] = []Position{[2]int{i, j}}
        }
      }
    }
  }
  return m, size
}

func is_in_map(pos Position, size int) bool {
  return pos[0] &gt;= 0 &amp;&amp; pos[1] &gt;= 0 &amp;&amp; pos[0] &lt; size &amp;&amp; pos[1] &lt; size
}

func add_antinodes(nodes *map[[2]int]bool, antenna, diff Position, op func(int, int) int, size int, first_only bool) {
  antinode := [2]int{op(antenna[0], diff[0]), op(antenna[1], diff[1])}
  for is_in_map(antinode, size) {
    (*nodes)[antinode] = true
    if first_only {
      return
    }
    antinode = [2]int{op(antinode[0], diff[0]), op(antinode[1], diff[1])}
  }
}

func add_nodes(nodes *map[[2]int]bool, first_antenna, second_antenna Position, size int, first_only bool) {
  diff := [2]int{first_antenna[0] - second_antenna[0], first_antenna[1] - second_antenna[1]}
  if !first_only {
    (*nodes)[first_antenna] = true
    (*nodes)[second_antenna] = true
  }
  add := func(x int, y int) int { return x + y }
  sub := func(x int, y int) int { return x - y }
  add_antinodes(nodes, first_antenna, diff, add, size, first_only)
  add_antinodes(nodes, second_antenna, diff, sub, size, first_only)
}

func part_one() {
  var result int
  start := time.Now()
  m, size := read_file("INPUT")
  nodes := make(map[[2]int]bool)
  for _, antennas := range m {
    for i := 0; i &lt; len(antennas)-1; i++ {
      for j := i + 1; j &lt; len(antennas); j++ {
        add_nodes(&amp;nodes, antennas[i], antennas[j], size, true)
      }
    }
  }
  result = len(nodes)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  m, size := read_file("INPUT")
  nodes := make(map[[2]int]bool)
  for _, antennas := range m {
    for i := 0; i &lt; len(antennas)-1; i++ {
      for j := i + 1; j &lt; len(antennas); j++ {
        add_nodes(&amp;nodes, antennas[i], antennas[j], size, false)
      }
    }
  }
  result = len(nodes)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "8 - Resonant Collinearity" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-9"><a class="header" href="#advent-of-code---year-2024-day-9">Advent of code - Year 2024 Day 9</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/9">day 9</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-9"><a class="header" href="#information-9">Information</a></h3>
<h4 id="part-1-8"><a class="header" href="#part-1-8">Part 1</a></h4>
<p>Today I used two different approaches for each part. In the first part I recreated the disc and by following two indices (going forward and backward) I swap spaces and files between each other. Lastly I compute the sum.</p>
<h4 id="part-2-8"><a class="header" href="#part-2-8">Part 2</a></h4>
<p>For the second part I created a structure that holds the content of the place, its size and possibly index of a file. Then I also go backwards and forward at the same time and if I find a file I will try to find a big enough space and then put it there. Afterwards I partition the space if there is some left and compact consecutive spaces to just one.</p>
<h2 id="maingo-8"><a class="header" href="#maingo-8">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strconv"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

const (
  SPACE   = 0
  FILE    = 1
  INVALID = -1
)

type Partition struct {
  content int
  size    int
  index   int
}

func read_file(file_path string) []int {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var format []int
  line := strings.Split(string(content), "\n")[0]
  for i := 0; i &lt; len(line); i++ {
    nr, _ := strconv.Atoi(string(line[i]))
    format = append(format, nr)
  }
  return format
}

func init_array(size, val int) []int {
  array := make([]int, size)
  for i := range array {
    array[i] = val
  }
  return array
}

func recreate_disk(format []int) []int {
  var disk []int
  id := 0
  for i := 0; i &lt; len(format); i++ {
    if i%2 == 0 {
      partition := init_array(format[i], id)
      id++
      disk = append(disk, partition[:]...)
    } else {
      partition := init_array(format[i], INVALID)
      disk = append(disk, partition[:]...)
    }
  }
  return disk
}

func create_my_format(format []int) []Partition {
  var prop_format []Partition
  index := 0
  for i := 0; i &lt; len(format); i++ {
    if i%2 == 0 {
      prop_format = append(prop_format, Partition{FILE, format[i], index})
      index++
    } else {
      prop_format = append(prop_format, Partition{SPACE, format[i], INVALID})
    }
  }
  return prop_format
}

func shrink(disk *[]int) {
  a, i := 0, len(*disk)-1
  for a &lt; i {
    if (*disk)[a] == INVALID &amp;&amp; (*disk)[i] != INVALID {
      (*disk)[a] = (*disk)[i]
      (*disk)[i] = INVALID
      a++
      i--
    } else if (*disk)[a] != INVALID {
      a++
    } else if (*disk)[i] == INVALID {
      i--
    }
  }
}

func compact(format *[]Partition) {
  for i := 1; i &lt; len(*format); i++ {
    if (*format)[i-1].content == SPACE &amp;&amp; (*format)[i].content == SPACE {
      (*format)[i-1].size += (*format)[i].size
      *format = append((*format)[:i], (*format)[i+1:]...)
      i--
    }
  }
}

func insert(format *[]Partition, index int, part Partition) {
  new_format := make([]Partition, len(*format)+1)
  for j := 0; j &lt; index+1; j++ {
    new_format[j] = (*format)[j]
  }
  new_format[index+1] = part
  for j := index + 2; j &lt; len(new_format); j++ {
    new_format[j] = (*format)[j-1]
  }
  *format = new_format
}

func reallocate_file(file_index int, format *[]Partition) {
  for a := 0; a &lt; file_index; a++ {
    rest := (*format)[a].size - (*format)[file_index].size
    if (*format)[a].content == SPACE &amp;&amp; rest &gt;= 0 {
      (*format)[a].content = FILE
      (*format)[a].size = (*format)[file_index].size
      (*format)[a].index = (*format)[file_index].index
      (*format)[file_index].content = SPACE
      if rest &gt; 0 {
        insert(format, a, Partition{SPACE, rest, -1})
        compact(format)
      }
      return
    }
  }
}

func reallocate(format *[]Partition) {
  for i := len(*format) - 1; i &gt;= 0; i-- {
    if (*format)[i].content == FILE {
      reallocate_file(i, format)
    }
  }
}

func part_one() {
  var result int
  start := time.Now()
  disk := recreate_disk(read_file("INPUT"))
  shrink(&amp;disk)
  for i, el := range disk {
    if el != INVALID {
      result += i * el
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  format := create_my_format(read_file("INPUT"))
  reallocate(&amp;format)
  position := 0
  for i := 0; i &lt; len(format); i++ {
    for j := 0; j &lt; format[i].size; j++ {
      if format[i].content == FILE {
        result += format[i].index * position
      }
      position++
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "9 - Disk Fragmenter" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-10"><a class="header" href="#advent-of-code---year-2024-day-10">Advent of code - Year 2024 Day 10</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/10">day 10</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-10"><a class="header" href="#information-10">Information</a></h3>
<h4 id="part-1-9"><a class="header" href="#part-1-9">Part 1</a></h4>
<p>In the first part we use recursion on the nighbours. But beforehand we check if the value is <code>9</code>, if so add it to the <code>map</code>. We also check if neighbours are indeed inside of the map and if the value on this place is <code>1</code> higher than the current one.</p>
<h4 id="part-2-9"><a class="header" href="#part-2-9">Part 2</a></h4>
<p>In this case we do not need <code>map</code> and just return on if <code>9</code> was found, and recourse on counting such cases. That is we get to the nine number as many times as there are distinct paths.</p>
<h2 id="maingo-9"><a class="header" href="#maingo-9">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strconv"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) [][]int {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  lines := strings.Split(string(content), "\n")
  var m [][]int
  for _, line := range lines {
    if len(line) == 0 {
      continue
    }
    tiles := strings.Split(line, "")
    row := make([]int, len(tiles))
    for i, tile := range tiles {
      row[i], _ = strconv.Atoi(tile)
    }
    m = append(m, row)
  }
  return m
}

func get_neighbours(x, y int) [4][2]int {
  return [4][2]int{
    {x + 1, y},
    {x - 1, y},
    {x, y + 1},
    {x, y - 1},
  }
}

func in_map(m *[][]int, x, y int) bool {
  return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; len(*m) &amp;&amp; y &lt; len((*m)[0])
}

func find_trails(m *[][]int, x, y int) map[[2]int]bool {
  if (*m)[x][y] == 9 {
    res := make(map[[2]int]bool)
    res[[2]int{x, y}] = true
    return res
  }
  res := make(map[[2]int]bool)
  neighbours := get_neighbours(x, y)
  for _, neigh := range neighbours {
    if in_map(m, neigh[0], neigh[1]) &amp;&amp; (*m)[neigh[0]][neigh[1]] == (*m)[x][y]+1 {
      for key, val := range find_trails(m, neigh[0], neigh[1]) {
        res[key] = val
      }
    }
  }
  return res
}

func find_distinct(m *[][]int, x, y int) int {
  if (*m)[x][y] == 9 {
    return 1
  }
  res := 0
  neighbours := get_neighbours(x, y)
  for _, neigh := range neighbours {
    if in_map(m, neigh[0], neigh[1]) &amp;&amp; (*m)[neigh[0]][neigh[1]] == (*m)[x][y]+1 {
      res += find_distinct(m, neigh[0], neigh[1])
    }
  }
  return res
}

func part_one() {
  var result int
  start := time.Now()
  m := read_file("INPUT")
  for i, row := range m {
    for j := range row {
      if m[i][j] == 0 {
        result += len(find_trails(&amp;m, i, j))
      }
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  m := read_file("INPUT")
  for i, row := range m {
    for j := range row {
      if m[i][j] == 0 {
        result += find_distinct(&amp;m, i, j)
      }
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "10 - Hoof It" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-11"><a class="header" href="#advent-of-code---year-2024-day-11">Advent of code - Year 2024 Day 11</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/11">day 11</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-11"><a class="header" href="#information-11">Information</a></h3>
<h4 id="part-1-10"><a class="header" href="#part-1-10">Part 1</a></h4>
<p>The first part can be done by brute force, that is going in an array and splitting, changing the numbers. Tho this is not a good approach. See part 2 for more info.</p>
<h4 id="part-2-10"><a class="header" href="#part-2-10">Part 2</a></h4>
<p>Generally it is better to hold the number of same stones, since the operation for these stones will be exactly same, so we will instead move all such stones at once. This is under the assumption, that there will be many stones of the same number, because otherwise it will be the same as brute-forcing it. Therefore we create a map for stones as key and we do operation for all keys and add the value to the new number. But it is better to create a new map instead of making it in place.</p>
<h2 id="maingo-10"><a class="header" href="#maingo-10">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "strconv"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) []int {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var stones []int
  regex := regexp.MustCompile("([0-9]+)")
  found := regex.FindAllString(string(content), -1)
  for _, f := range found {
    nr, _ := strconv.Atoi(f)
    stones = append(stones, nr)
  }
  return stones
}

func split_size(stone int) (int, int, bool) {
  str := strconv.Itoa(stone)
  if len(str)%2 == 0 {
    prefix, _ := strconv.Atoi(str[:len(str)/2])
    postfix, _ := strconv.Atoi(str[len(str)/2:])
    return prefix, postfix, true
  }
  return -1, -1, false
}

func add_to_map(stones *map[int]int, key, val int) {
  _, ok := (*stones)[key]
  if ok {
    (*stones)[key] += val
  } else {
    (*stones)[key] = val
  }
}

func blink182(stones map[int]int, iter int) int {
  for i := 0; i &lt; iter; i++ {
    new_stones := make(map[int]int)
    for key, val := range stones {
      if val &gt; 0 {
        prefix, postfix, even := split_size(key)
        if key == 0 {
          add_to_map(&amp;new_stones, 1, val)
        } else if even {
          add_to_map(&amp;new_stones, prefix, val)
          add_to_map(&amp;new_stones, postfix, val)
        } else {
          add_to_map(&amp;new_stones, 2024*key, val)
        }
      }
    }
    stones = new_stones
  }
  sum := 0
  for _, val := range stones {
    sum += val
  }
  return sum
}

func count_all(iter int) int {
  stones := read_file("INPUT")
  m := make(map[int]int)
  for _, stone := range stones {
    add_to_map(&amp;m, stone, 1)
  }
  return blink182(m, iter)
}

func part_one() {
  var result int
  start := time.Now()
  result = count_all(25)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  result = count_all(75)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "11 - Plutonian Pebbles" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-12"><a class="header" href="#advent-of-code---year-2024-day-12">Advent of code - Year 2024 Day 12</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/12">day 12</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-12"><a class="header" href="#information-12">Information</a></h3>
<h4 id="part-1-11"><a class="header" href="#part-1-11">Part 1</a></h4>
<p>We will firstly use bucket fill algorithm to find the inner tiles and also the fences with their positions, orientations and sides. After that in the first part we multiple the number of fences with the number of fences.</p>
<h4 id="part-2-11"><a class="header" href="#part-2-11">Part 2</a></h4>
<p>In the second part we compare the fences between each other if they are in the same side or not. We also abuse the fact, that we set UPPER and LOWER to even numbers and LOWER and RIGHT to odd numbers. Hence the horizontal ones have parity <code>0</code> and vertical <code>1</code>.</p>
<h2 id="maingo-11"><a class="header" href="#maingo-11">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "math"
  "os"
  "sort"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

const (
  UPPER = 0
  LOWER = 2
  LEFT  = 1
  RIGHT = 3
)

type Fence struct {
  position [2]int
  side     int
}

func read_file(file_path string) [][]string {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var m [][]string
  lines := strings.Split(string(content), "\n")
  for _, line := range lines {
    if len(line) == 0 {
      continue
    }
    chars := strings.Split(line, "")
    m = append(m, chars)

  }
  return m
}

func count_sides(fences map[Fence]bool) int {
  considered := make(map[[2]int]bool)
  sum := 0
  for current := range fences {
    i := current.side % 2
    _, used := considered[[2]int{current.position[i], current.side}]
    if used {
      continue
    }
    array := make([]int, 0)
    for fence := range fences {
      if current.side == fence.side &amp;&amp; current.position[i] == fence.position[i] {
        array = append(array, fence.position[(i+1)%2])
      }
    }
    considered[[2]int{current.position[i], current.side}] = true
    sort.Ints(array)
    for j := 1; j &lt; len(array); j++ {
      if int(math.Abs(float64(array[j-1]-array[j]))) &gt; 1 {
        sum += 1
      }
    }
    if len(array) &gt; 0 {
      sum += 1
    }
  }
  return sum
}

func insert_fence(fences *map[Fence]bool, current, neigh [2]int) {
  if neigh[0] == current[0] {
    if neigh[1] &lt; current[1] {
      (*fences)[Fence{position: neigh, side: RIGHT}] = true
    } else {
      (*fences)[Fence{position: neigh, side: LEFT}] = true
    }
  } else {
    if neigh[0] &lt; current[0] {
      (*fences)[Fence{position: neigh, side: UPPER}] = true
    } else {
      (*fences)[Fence{position: neigh, side: LOWER}] = true
    }
  }
}

func flood_fill(garden *[][]string, visited_map *map[[2]int]bool, i, j int) (map[Fence]bool, map[[2]int]bool) {
  queue := append(make([][2]int, 0), [2]int{i, j})
  fences := make(map[Fence]bool)
  inner := make(map[[2]int]bool)

  for len(queue) &gt; 0 {
    current := queue[0]
    inner[current] = true
    queue = queue[1:]
    neighbours := [4][2]int{
      {current[0] - 1, current[1]},
      {current[0] + 1, current[1]},
      {current[0], current[1] + 1},
      {current[0], current[1] - 1},
    }
    for _, neigh := range neighbours {
      _, visited := inner[neigh]
      if visited {
        continue
      }
      if neigh[0] &lt; 0 || neigh[1] &lt; 0 || neigh[0] &gt;= len(*garden) || neigh[1] &gt;= len((*garden)[0]) {
        insert_fence(&amp;fences, current, neigh)
        continue
      }
      if (*garden)[neigh[0]][neigh[1]] != (*garden)[i][j] {
        insert_fence(&amp;fences, current, neigh)
        continue
      }
      queue = append(queue, neigh)
      inner[neigh] = true
      (*visited_map)[neigh] = true
    }
  }
  return fences, inner
}

func count_fences(garden *[][]string, f func(map[Fence]bool) int) int {
  sum := 0
  visited := make(map[[2]int]bool)
  for i, row := range *garden {
    for j := range row {
      _, ok := visited[[2]int{i, j}]
      if ok {
        continue
      }
      fences, inner := flood_fill(garden, &amp;visited, i, j)
      sum += len(inner) * f(fences)
    }
  }
  return sum
}

func part_one() {
  var result int
  start := time.Now()
  garden := read_file("INPUT")
  my_len := func(m map[Fence]bool) int { return len(m) }
  result = count_fences(&amp;garden, my_len)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  garden := read_file("INPUT")
  result = count_fences(&amp;garden, count_sides)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "12 - Garden Groups" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-13"><a class="header" href="#advent-of-code---year-2024-day-13">Advent of code - Year 2024 Day 13</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/13">day 13</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-13"><a class="header" href="#information-13">Information</a></h3>
<h4 id="part-1-12"><a class="header" href="#part-1-12">Part 1</a></h4>
<p>We actually have the following system of equalities.</p>
<p>\[
a_0 x + b_0 y  = p_0
\]</p>
<p>\[
a_1 x + b_1 y = p_1
\]</p>
<p>Which can be simplified to evaluate the following:</p>
<p>\[
y = \frac{p_1 a_0 - a_1 p_0}{b_1 a_0 - a_1 b_0}
\]</p>
<p>\[
x = \frac{p_0 - b_0 y}{a_0}
\]</p>
<p>Lastly we check if it is indeed true. Note that we assume that the vectors are linearly independent.</p>
<h4 id="part-2-12"><a class="header" href="#part-2-12">Part 2</a></h4>
<p>In the second part we use the same fact.</p>
<h2 id="maingo-12"><a class="header" href="#maingo-12">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "strconv"
  "sync"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

type Machine struct {
  a     [2]int
  b     [2]int
  prize [2]int
}

func read_file(file_path string) []Machine {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var machines []Machine
  regex := regexp.MustCompile("Button A: X\\+([0-9]+), Y\\+([0-9]+)\\nButton B: X\\+([0-9]+), Y\\+([0-9]+)\\nPrize: X=([0-9]+), Y=([0-9]+)")
  found := regex.FindAllStringSubmatch(string(content), -1)
  for _, f := range found {
    a_x, _ := strconv.Atoi(f[1])
    a_y, _ := strconv.Atoi(f[2])
    b_x, _ := strconv.Atoi(f[3])
    b_y, _ := strconv.Atoi(f[4])
    prize_x, _ := strconv.Atoi(f[5])
    prize_y, _ := strconv.Atoi(f[6])
    machine := Machine{
      a:     [2]int{a_x, a_y},
      b:     [2]int{b_x, b_y},
      prize: [2]int{prize_x, prize_y},
    }
    machines = append(machines, machine)
  }
  return machines
}

func solve(machine Machine, c chan int) {
  y := (machine.prize[1]*machine.a[0] - machine.a[1]*machine.prize[0]) / (machine.b[1]*machine.a[0] - machine.a[1]*machine.b[0])
  x := (machine.prize[0] - (machine.b[0] * y)) / machine.a[0]
  if x*machine.a[0]+y*machine.b[0] == machine.prize[0] &amp;&amp; x*machine.a[1]+y*machine.b[1] == machine.prize[1] {
    c &lt;- x*3 + y
  }
}

func solve_all(machines []Machine, addition int) int {
  sum := 0
  c := make(chan int, len(machines))
  var wg sync.WaitGroup
  wg.Add(len(machines))
  for _, machine := range machines {
    machine.prize[0] += addition
    machine.prize[1] += addition
    go func(machine Machine) {
      defer wg.Done()
      solve(machine, c)
    }(machine)
  }
  wg.Wait()
  close(c)
  for opt := range c{
    sum += opt
  }
  return sum
}

func part_one() {
  var result int
  start := time.Now()
  result = solve_all(read_file("INPUT"), 0)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  result = solve_all(read_file("INPUT"), 10000000000000)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "13 - Claw Contraption" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-14"><a class="header" href="#advent-of-code---year-2024-day-14">Advent of code - Year 2024 Day 14</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/14">day 14</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-14"><a class="header" href="#information-14">Information</a></h3>
<h4 id="part-1-13"><a class="header" href="#part-1-13">Part 1</a></h4>
<p>Note that we can jump the whole <code>100</code> steps by <code>modulo</code> algebra. And then we split into 4 cases of different quadrants. Then multiply these quadrants.</p>
<h4 id="part-2-13"><a class="header" href="#part-2-13">Part 2</a></h4>
<p>In this part we proceed one step at a time by simply checking if there is a long enough line of robots.</p>
<h2 id="maingo-13"><a class="header" href="#maingo-13">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "strconv"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

const (
  Width  = 101
  Height = 103
)

type Robot struct {
  position [2]int
  velocity [2]int
}

func mod(nr, mod int) int {
  return (nr%mod + mod) % mod
}

func (r *Robot) move(iter int) {
  r.position[0] += r.velocity[0] * iter
  r.position[1] += r.velocity[1] * iter
  r.position[0] = mod(r.position[0], Width)
  r.position[1] = mod(r.position[1], Height)
}

func read_file(file_path string) []Robot {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var robots []Robot
  regex := regexp.MustCompile("p=([\\-0-9]+),([\\-0-9]+) v=([\\-0-9]+),([\\-0-9]+)")
  found := regex.FindAllStringSubmatch(string(content), -1)
  for _, f := range found {
    p_x, _ := strconv.Atoi(f[1])
    p_y, _ := strconv.Atoi(f[2])
    v_x, _ := strconv.Atoi(f[3])
    v_y, _ := strconv.Atoi(f[4])
    robot := Robot{
      position: [2]int{p_x, p_y},
      velocity: [2]int{v_x, v_y},
    }
    robots = append(robots, robot)
  }
  return robots
}

func is_tree(bitmap [Width][Height]bool) bool {
  for i := 0; i &lt; Height; i++ {
    for j := 0; j &lt; Width; j++ {
      k := j
      for ; k &lt; Width &amp;&amp; bitmap[k][i]; k++ {
      }
      if k-j &gt; 30 {
        return true
      }
    }
  }
  return false
}

func part_one() {
  var result int
  start := time.Now()
  robots := read_file("INPUT")
  var quadrants [4]int
  for i := range robots {
    robots[i].move(100)
    if robots[i].position[0] &lt; Width/2 {
      if robots[i].position[1] &lt; Height/2 {
        quadrants[0] += 1
      } else if robots[i].position[1] &gt; Height/2 {
        quadrants[1] += 1
      }
    } else if robots[i].position[0] &gt; Width/2 {
      if robots[i].position[1] &lt; Height/2 {
        quadrants[2] += 1
      } else if robots[i].position[1] &gt; Height/2 {
        quadrants[3] += 1
      }
    }
  }
  result = quadrants[0] * quadrants[1] * quadrants[2] * quadrants[3]
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  robots := read_file("INPUT")
  for t := 1; ; t++ {
    var bitmap [Width][Height]bool
    for i := range robots {
      robots[i].move(1)
      bitmap[robots[i].position[0]][robots[i].position[1]] = true
    }
    if is_tree(bitmap) {
      result = t
      break
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "14 - Restroom Redoubt" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-15"><a class="header" href="#advent-of-code---year-2024-day-15">Advent of code - Year 2024 Day 15</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/15">day 15</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-15"><a class="header" href="#information-15">Information</a></h3>
<h4 id="part-1-14"><a class="header" href="#part-1-14">Part 1</a></h4>
<p>In the first part we simulate the robot step by step. If there is <code>Space</code> move, if there is a <code>Wall</code> stop and if there is a <code>Box</code> then try to move all boxes, which is done by following the line of boxing and potentially placing the first box to the end, hence the same operation as if we moved the whole row of boxes.</p>
<p>After these procedures we compute <code>GPS</code>.</p>
<h4 id="part-2-14"><a class="header" href="#part-2-14">Part 2</a></h4>
<p>For the second part we proceed very similarly. Only change is when dealing with boxes. In a horizontal way we do the same thing, except that we do not put the box to the end, but instead move shift the row of boxes. For the vertical move we will only consider the case that we ran into a left part of the box (otherwise we switch to the left part). Then we check if both parts can be moved or not by recursion. After we check the whole sequence of boxes and get <code>true</code> answer we then may move all boxes proceeding in the same matter.</p>
<h2 id="maingo-14"><a class="header" href="#maingo-14">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strings"
  "time"
)

const (
  Blue   = "[1;34m"
  Yellow = "[1;33m"
  Green  = "[1;32m"
  Reset  = "[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

const (
  Space    = 0
  Wall     = 1
  Box      = 2
  LeftBox  = 3
  RightBox = 4
)

func read_file(file_path string) ([][]int8, [2]int, [][2]int) {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var m [][]int8
  var position [2]int
  var moves [][2]int
  for i, line := range strings.Split(string(content), "\n") {
    if len(line) == 0 {
      continue
    }
    if line[0] == '#' {
      row := make([]int8, len(line))
      for j, char := range strings.Split(line, "") {
        switch char {
        case "#":
          row[j] = Wall
        case "O":
          row[j] = Box
        case "@":
          row[j] = Space
          position = [2]int{i, j}
        case ".":
          row[j] = Space
        }
      }
      m = append(m, row)
    } else {
      for _, char := range strings.Split(line, "") {
        switch char {
        case "&gt;":
          moves = append(moves, [2]int{0, 1})
        case "&lt;":
          moves = append(moves, [2]int{0, -1})
        case "^":
          moves = append(moves, [2]int{-1, 0})
        case "v":
          moves = append(moves, [2]int{1, 0})
        }
      }
    }
  }
  return m, position, moves
}

func wider_map(m [][]int8) [][]int8 {
  wider := make([][]int8, len(m))
  for i, row := range m {
    var new_row []int8
    for j := range row {
      switch row[j] {
      case Space:
        new_row = append(new_row, Space, Space)
      case Wall:
        new_row = append(new_row, Wall, Wall)
      case Box:
        new_row = append(new_row, LeftBox, RightBox)
      }
    }
    wider[i] = new_row
  }
  return wider
}

func up_down_move(m *[][]int8, box [2]int, move [2]int) {
  if (*m)[box[0]][box[1]] == LeftBox {
    if (*m)[box[0]+move[0]][box[1]] == LeftBox || (*m)[box[0]+move[0]][box[1]] == RightBox {
      up_down_move(m, [2]int{box[0] + move[0], box[1]}, move)
    }
    if (*m)[box[0]+move[0]][box[1]+1] == LeftBox {
      up_down_move(m, [2]int{box[0] + move[0], box[1] + 1}, move)
    }
    (*m)[box[0]][box[1]] = Space
    (*m)[box[0]][box[1]+1] = Space
    (*m)[box[0]+move[0]][box[1]] = LeftBox
    (*m)[box[0]+move[0]][box[1]+1] = RightBox
  } else if (*m)[box[0]][box[1]] == RightBox {
    up_down_move(m, [2]int{box[0], box[1] - 1}, move)
  }
}

func up_down_check(m *[][]int8, box [2]int, move [2]int) bool {
  if box[0]+move[0] &lt; 0 || box[0]+move[0] &gt;= len(*m) {
    return false
  }
  plausible := true
  if (*m)[box[0]][box[1]] == LeftBox {
    if (*m)[box[0]+move[0]][box[1]] == LeftBox || (*m)[box[0]+move[0]][box[1]] == RightBox {
      plausible = plausible &amp;&amp; up_down_check(m, [2]int{box[0] + move[0], box[1]}, move)
    }
    if (*m)[box[0]+move[0]][box[1]+1] == LeftBox {
      plausible = plausible &amp;&amp; up_down_check(m, [2]int{box[0] + move[0], box[1] + 1}, move)
    }
    if (*m)[box[0]+move[0]][box[1]] == Space &amp;&amp; (*m)[box[0]+move[0]][box[1]+1] == Space {
      plausible = plausible &amp;&amp; true
    }
    if (*m)[box[0]+move[0]][box[1]] == Wall || (*m)[box[0]+move[0]][box[1]+1] == Wall {
      plausible = false
    }
  } else if (*m)[box[0]][box[1]] == RightBox {
    plausible = plausible &amp;&amp; up_down_check(m, [2]int{box[0], box[1] - 1}, move)
  }
  return plausible
}

func move_larger_box(m *[][]int8, box [2]int, move [2]int) bool {
  if move[0] == 0 {
    i := 0
    for ; box[1]+i*move[1] &lt; len((*m)[box[0]]) &amp;&amp; ((*m)[box[0]][box[1]+i*move[1]] == LeftBox || (*m)[box[0]][box[1]+i*move[1]] == RightBox); i += 1 {
    }
    if box[1]+i*move[1] &lt; len((*m)[box[0]]) &amp;&amp; (*m)[box[0]][box[1]+i*move[1]] == Space {
      (*m)[box[0]][box[1]] = Space
      (*m)[box[0]][box[1]+i*move[1]] = (*m)[box[0]][box[1]+(i-1)*move[1]]
      for j := 1; j &lt; i; j++ {
        if (*m)[box[0]][box[1]+j*move[1]] == RightBox {
          (*m)[box[0]][box[1]+j*move[1]] = LeftBox
        } else {
          (*m)[box[0]][box[1]+j*move[1]] = RightBox
        }
      }
      return true
    }
  } else {
    if up_down_check(m, box, move) {
      up_down_move(m, box, move)
      return true
    }
  }
  return false
}

func move_box(m *[][]int8, box [2]int, move [2]int) bool {
  i := 0
  for ; box[0]+i*move[0] &lt; len(*m) &amp;&amp; box[1]+i*move[1] &lt; len((*m)[box[0]]) &amp;&amp; (*m)[box[0]+i*move[0]][box[1]+i*move[1]] == Box; i++ {
  }
  if box[0]+i*move[0] &lt; len(*m) &amp;&amp; box[1]+i*move[1] &lt; len((*m)[box[0]]) &amp;&amp; (*m)[box[0]+i*move[0]][box[1]+i*move[1]] == Space {
    (*m)[box[0]][box[1]] = Space
    (*m)[box[0]+i*move[0]][box[1]+i*move[1]] = Box
    return true
  }
  return false
}

func single_step(m *[][]int8, position *[2]int, move [2]int) {
  new_position := [2]int{
    (*position)[0] + move[0],
    (*position)[1] + move[1],
  }
  switch (*m)[new_position[0]][new_position[1]] {
  case Space:
    *position = new_position
  case Wall:
    return
  case Box:
    if move_box(m, new_position, move) {
      *position = new_position
    }
  case LeftBox:
    fallthrough
  case RightBox:
    if move_larger_box(m, new_position, move) {
      *position = new_position
    }
  }
}

func simulate(m *[][]int8, position *[2]int, moves [][2]int) int {
  for _, move := range moves {
    single_step(m, position, move)
  }
  sum := 0
  for i, row := range *m {
    for j := range row {
      if row[j] == Box || row[j] == LeftBox {
        sum += i*100 + j
      }
    }
  }
  return sum
}

func part_one() {
  var result int
  start := time.Now()
  m, position, moves := read_file("INPUT")
  result = simulate(&amp;m, &amp;position, moves)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  m, position, moves := read_file("INPUT")
  wider := wider_map(m)
  position[1] *= 2
  result = simulate(&amp;wider, &amp;(position), moves)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "15 - Claw Contraption" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-16"><a class="header" href="#advent-of-code---year-2024-day-16">Advent of code - Year 2024 Day 16</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/16">day 16</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-16"><a class="header" href="#information-16">Information</a></h3>
<h4 id="part-1-15"><a class="header" href="#part-1-15">Part 1</a></h4>
<p>In the first part we do a <code>BFS</code> and mark visited places indexed by place and with value of their length. If we may step on the tile with smaller score do so.</p>
<h4 id="part-2-15"><a class="header" href="#part-2-15">Part 2</a></h4>
<p>In the second part we also return all visited places with the shortest path, but now we recourse on the path which has also the same score. Also if we run out of the budget, which was computed from the previous step we end.</p>
<h2 id="maingo-15"><a class="header" href="#maingo-15">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strings"
  "time"
)

const (
  Blue   = "[1;34m"
  Yellow = "[1;33m"
  Green  = "[1;32m"
  Reset  = "[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

const (
  Wall  = 1
  Space = 0
  Max   = int(^uint(0) &gt;&gt; 1)
)

func read_file(file_path string) ([][]int8, [2]int, [2]int) {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var maze [][]int8
  var end [2]int
  var start [2]int
  for i, line := range strings.Split(string(content), "\n") {
    if len(line) == 0 {
      continue
    }
    row := make([]int8, len(line))
    for j, c := range line {
      switch c {
      case '#':
        row[j] = Wall
      case '.':
        row[j] = Space
      case 'S':
        start = [2]int{i, j}
        row[j] = Space
      case 'E':
        end = [2]int{i, j}
        row[j] = Space
      }
    }
    maze = append(maze, row)
  }
  return maze, start, end
}

func extend_path(maze [][]int8, position, end, orientation [2]int, visited map[[2]int]int, score, res int) int {
  length, ok := visited[[2]int{position[0], position[1]}]
  if (!ok || length &gt; score) &amp;&amp; maze[position[0]][position[1]] == Space {
    new_res := find_path(maze, position, end, orientation, visited, score)
    if res &gt; new_res {
      return new_res
    }
  }
  return res
}

func find_path(maze [][]int8, current, end, orientation [2]int, visited map[[2]int]int, score int) int {
  if current == end {
    return score
  }
  res := Max
  visited[[2]int{current[0], current[1]}] = score

  new_pos := [2]int{current[0] + orientation[0], current[1] + orientation[1]}
  res = extend_path(maze, new_pos, end, orientation, visited, score+1, res)

  new_orientation := [2]int{-orientation[1], orientation[0]}
  new_pos = [2]int{current[0] + new_orientation[0], current[1] + new_orientation[1]}
  res = extend_path(maze, new_pos, end, new_orientation, visited, score+1001, res)

  new_orientation = [2]int{orientation[1], -orientation[0]}
  new_pos = [2]int{current[0] + new_orientation[0], current[1] + new_orientation[1]}
  res = extend_path(maze, new_pos, end, new_orientation, visited, score+1001, res)

  return res
}

func extend_seats(maze [][]int8, position, end, orientation [2]int, visited map[[4]int]int, score, res, budget int, seats [][2]int) (int, [][2]int) {
  length, ok := visited[[4]int{position[0], position[1], orientation[0], orientation[1]}]
  if (!ok || length &gt;= score) &amp;&amp; maze[position[0]][position[1]] == Space {
    new_res, new_seats := find_seats(maze, position, end, orientation, visited, score, budget)
    if res &gt; new_res {
      res = new_res
      seats = new_seats
    } else if res == new_res {
      seats = append(seats, new_seats[:]...)
    }
  }
  return res, seats
}

func find_seats(maze [][]int8, current, end, orientation [2]int, visited map[[4]int]int, score, budget int) (int, [][2]int) {
  if score &gt; budget {
    return Max, [][2]int{}
  }
  if current == end {
    return score, [][2]int{end}
  }
  res := Max
  var seats [][2]int
  visited[[4]int{current[0], current[1], orientation[0], orientation[1]}] = score

  new_pos := [2]int{current[0] + orientation[0], current[1] + orientation[1]}
  res, seats = extend_seats(maze, new_pos, end, orientation, visited, score+1, res, budget, seats)

  new_orientation := [2]int{-orientation[1], orientation[0]}
  new_pos = [2]int{current[0] + new_orientation[0], current[1] + new_orientation[1]}
  res, seats = extend_seats(maze, new_pos, end, new_orientation, visited, score+1001, res, budget, seats)

  new_orientation = [2]int{orientation[1], -orientation[0]}
  new_pos = [2]int{current[0] + new_orientation[0], current[1] + new_orientation[1]}
  res, seats = extend_seats(maze, new_pos, end, new_orientation, visited, score+1001, res, budget, seats)

  return res, append(seats, current)
}

func part_one() {
  var result int
  start := time.Now()
  maze, start_point, end_point := read_file("INPUT")
  result = find_path(maze, start_point, end_point, [2]int{0, 1}, make(map[[2]int]int), 0)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  maze, start_point, end_point := read_file("INPUT")
  length := find_path(maze, start_point, end_point, [2]int{0, 1}, make(map[[2]int]int), 0)
  _, spots := find_seats(maze, start_point, end_point, [2]int{0, 1}, make(map[[4]int]int), 0, length)
  seats := make(map[[2]int]bool)
  for _, s := range spots {
    seats[s] = true
  }
  result = len(seats)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "16 - Claw Contraption" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-17"><a class="header" href="#advent-of-code---year-2024-day-17">Advent of code - Year 2024 Day 17</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/17">day 17</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-17"><a class="header" href="#information-17">Information</a></h3>
<h4 id="part-1-16"><a class="header" href="#part-1-16">Part 1</a></h4>
<p>In the first part we reconstruct the <code>computer</code> and simulate the given program.</p>
<h4 id="part-2-16"><a class="header" href="#part-2-16">Part 2</a></h4>
<p>In the second part we may see that there is only one instruction which changes <code>A</code> that is <code>0 X</code> where <code>X &lt;= 3</code>. So we construct the program from back. In each step we iterate over all numbers between <code>0</code> and <code>2^X</code>. If on the current position we have the same number as in the program itself we recourse on the previous index, also we multiply the current solution by <code>2^X</code> so that the tail stays the same. In other iterations we have some previous solution and add the new number for the current one. We also need to check if we don't have too long array of numbers and properly end.</p>
<h2 id="maingo-16"><a class="header" href="#maingo-16">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "math"
  "os"
  "regexp"
  "strconv"
  "strings"
  "time"
)

const (
  Blue   = "[1;34m"
  Yellow = "[1;33m"
  Green  = "[1;32m"
  Reset  = "[0m"
)

func print_result(dur time.Duration, part int, result string) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + result + Reset)
}

type Computer struct {
  a       int
  b       int
  c       int
  program []int
  output  []int
}

func read_file(file_path string) Computer {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  a_regex := regexp.MustCompile("Register A: ([0-9]+)")
  b_regex := regexp.MustCompile("Register B: ([0-9]+)")
  c_regex := regexp.MustCompile("Register C: ([0-9]+)")
  prg_regex := regexp.MustCompile("Program: ([0-9,]+)")
  a, _ := strconv.Atoi(a_regex.FindStringSubmatch(string(content))[1])
  b, _ := strconv.Atoi(b_regex.FindStringSubmatch(string(content))[1])
  c, _ := strconv.Atoi(c_regex.FindStringSubmatch(string(content))[1])
  var program []int
  for _, chr := range strings.Split(prg_regex.FindStringSubmatch(string(content))[1], ",") {
    nr, _ := strconv.Atoi(chr)
    program = append(program, nr)
  }
  return Computer{a, b, c, program, make([]int, 0)}
}

func combo(computer *Computer, val int) int {
  if val &gt;= 0 &amp;&amp; val &lt;= 3 {
    return val
  }
  if val == 4 {
    return (*computer).a
  }
  if val == 5 {
    return (*computer).b
  }
  if val == 6 {
    return (*computer).c
  }
  panic("no such possible operand")
}

func do_operation(computer *Computer, pointer int) (int, bool) {
  if pointer &gt;= len((*computer).program) {
    return -1, true
  }
  operation := (*computer).program[pointer]
  operand := (*computer).program[pointer+1]
  switch operation {
  case 0:
    (*computer).a = (*computer).a / int(math.Pow(2, float64(combo(computer, operand))))
  case 1:
    (*computer).b = (*computer).b ^ operand
  case 2:
    (*computer).b = combo(computer, operand) % 8
  case 3:
    if (*computer).a != 0 {
      return operand, false
    }
  case 4:
    (*computer).b = (*computer).b ^ (*computer).c
  case 5:
    (*computer).output = append((*computer).output, combo(computer, operand)%8)
  case 6:
    (*computer).b = (*computer).a / int(math.Pow(2, float64(combo(computer, operand))))
  case 7:
    (*computer).c = (*computer).a / int(math.Pow(2, float64(combo(computer, operand))))
  }
  return pointer + 2, false
}

func simulate(computer *Computer) string {
  pointer := 0
  halt := false
  for ; !halt; pointer, halt = do_operation(computer, pointer) {
  }
  str_output := make([]string, len((*computer).output))
  for i, out := range (*computer).output {
    str_output[i] = fmt.Sprint(out)
  }
  return strings.Join(str_output, ",")
}

func find_divisor(computer Computer) int {
  divisor := 1
  for i := 0; i &lt; len(computer.program); i += 2 {
    if computer.program[i] == 0 {
      if computer.program[i+1] &gt; 3 {
        panic("no good solution")
      }
      divisor *= int(math.Pow(2, float64(combo(&amp;computer, computer.program[i+1]))))
    }
  }
  return divisor
}

func solve(computer Computer, prev, index, divisor int) (int, bool) {
  j := index
  for i := 0; i &lt; divisor; i++ {
    computer.a = prev*divisor + i
    computer.output = make([]int, 0)
    simulate(&amp;computer)
    if j &gt;= len(computer.output) {
      continue
    }
    if computer.output[len(computer.output)-j-1] == computer.program[len(computer.program)-j-1] {
      if j == len(computer.program)-1 {
        return prev*divisor + i, true
      }
      sol, ok := solve(computer, prev*divisor+i, index+1, divisor)
      if ok {
        return sol, ok
      }
    }
  }
  return 0, false
}

func part_one() {
  var result string
  start := time.Now()
  computer := read_file("INPUT")
  result = simulate(&amp;computer)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result string
  start := time.Now()
  computer := read_file("INPUT")
  sol, _ := solve(computer, 0, 0, find_divisor(computer))
  result = fmt.Sprint(sol)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "17 - Claw Contraption" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-18"><a class="header" href="#advent-of-code---year-2024-day-18">Advent of code - Year 2024 Day 18</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/18">day 18</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-18"><a class="header" href="#information-18">Information</a></h3>
<h4 id="part-1-17"><a class="header" href="#part-1-17">Part 1</a></h4>
<p>For the first part we may employ any graph search algorithm. In this solution I created simple recursive DFS algorithm. For such we will note the length of shortest path and the predecessor. In this part we do not need predecessors. After that we check what is the length in the end.</p>
<h4 id="part-2-17"><a class="header" href="#part-2-17">Part 2</a></h4>
<p>In the second part we always recreate the path from predecessors and check if the byte will drop onto the path or not. If not we can just put it there and not check the path, if it will drop onto the map we need to recompute the shortest path.</p>
<h2 id="maingo-17"><a class="header" href="#maingo-17">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "strconv"
  "time"
)

const (
  Blue   = "[1;34m"
  Yellow = "[1;33m"
  Green  = "[1;32m"
  Reset  = "[0m"
)

func print_result(dur time.Duration, part int, result string) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

const (
  Size = 71
  Rep  = 1024
)

var Start = [2]int{0, 0}
var End = [2]int{Size - 1, Size - 1}

func read_file(file_path string) [][2]int {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var numbers [][2]int
  regex := regexp.MustCompile("([0-9]+),([0-9]+)")
  for _, f := range regex.FindAllStringSubmatch(string(content), -1) {
    nr1, _ := strconv.Atoi(f[1])
    nr2, _ := strconv.Atoi(f[2])
    numbers = append(numbers, [2]int{nr1, nr2})
  }
  return numbers
}

func find_path(m *[Size][Size]bool, current, previous, end [2]int, visited map[[2]int][3]int, length int) {
  if current[0] &lt; 0 || current[1] &lt; 0 || current[0] &gt;= Size || current[1] &gt;= Size || (*m)[current[0]][current[1]] {
    return
  }
  prev, ok := visited[current]
  l := prev[0]
  if !ok || l &gt; length {
    visited[current] = [3]int{length, previous[0], previous[1]}
    if current[0] == end[0] &amp;&amp; current[1] == end[1] {
      return
    }
    find_path(m, [2]int{current[0] + 1, current[1]}, current, end, visited, length+1)
    find_path(m, [2]int{current[0] - 1, current[1]}, current, end, visited, length+1)
    find_path(m, [2]int{current[0], current[1] + 1}, current, end, visited, length+1)
    find_path(m, [2]int{current[0], current[1] - 1}, current, end, visited, length+1)
  }
}

func recreate_path(visited map[[2]int][3]int) map[[2]int]bool {
  m := make(map[[2]int]bool)
  m[End] = true
  for current := End; current != Start; {
    prev, _ := visited[current]
    current = [2]int{prev[1], prev[2]}
    m[current] = true
  }
  return m
}

func part_one() {
  var result int
  start := time.Now()
  bytes := read_file("INPUT")
  var m [Size][Size]bool
  for i := 0; i &lt; Rep; i++ {
    m[bytes[i][1]][bytes[i][0]] = true
  }
  visited := make(map[[2]int][3]int)
  find_path(&amp;m, Start, Start, End, visited, 0)
  res, _ := visited[End]
  result = res[0]
  end := time.Now()
  print_result(end.Sub(start), 1, fmt.Sprint(result))
}

func part_two() {
  var result [2]int
  start := time.Now()
  bytes := read_file("INPUT")
  var m [Size][Size]bool
  for i := 0; i &lt; Rep; i++ {
    m[bytes[i][1]][bytes[i][0]] = true
  }
  t := Rep - 1
  for {
    visited := make(map[[2]int][3]int)
    find_path(&amp;m, [2]int{0, 0}, [2]int{0, 0}, [2]int{Size - 1, Size - 1}, visited, 0)
    _, ok := visited[[2]int{Size - 1, Size - 1}]
    if !ok {
      result = bytes[t]
      break
    }
    path := recreate_path(visited)
    for {
      t++
      m[bytes[t][1]][bytes[t][0]] = true
      _, on_path := path[[2]int{bytes[t][1], bytes[t][0]}]
      if on_path {
        break
      }
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 2, fmt.Sprintf("%d,%d", result[0], result[1]))
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "18 - Claw Contraption" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-19"><a class="header" href="#advent-of-code---year-2024-day-19">Advent of code - Year 2024 Day 19</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/19">day 19</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-19"><a class="header" href="#information-19">Information</a></h3>
<h4 id="part-1-18"><a class="header" href="#part-1-18">Part 1</a></h4>
<p>For the first part we try a prefix if there is a matching pattern, if so recourse on the suffix. If not return false. If we finally found some, terminate the process.</p>
<h4 id="part-2-18"><a class="header" href="#part-2-18">Part 2</a></h4>
<p>The second part is done pretty much the same way, except for counting the number of plausible. Since it would be slow we create a cache for already computed sequences.</p>
<h2 id="maingo-18"><a class="header" href="#maingo-18">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strings"
  "time"
)

const (
  Blue   = "[1;34m"
  Yellow = "[1;33m"
  Green  = "[1;32m"
  Reset  = "[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) ([]string, []string) {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  lines := strings.Split(string(content), "\n")
  patterns := strings.Split(lines[0], ", ")
  var towels []string
  for _, line := range lines[1:] {
    if len(line) == 0 {
      continue
    }
    towels = append(towels, line)
  }
  return patterns, towels
}

func is_plausible(patterns []string, towel string) bool {
  if len(towel) == 0 {
    return true
  }
  plausible := false
  for _, pattern := range patterns {
    length := len(pattern)
    if len(towel) &lt; length {
      continue
    }
    if towel[:length] == pattern {
      plausible = plausible || is_plausible(patterns, towel[length:])
    }
    if plausible {
      return plausible
    }
  }
  return plausible
}

func nr_of_plausible(patterns []string, towel string, cache *map[string]int) int {
  if len(towel) == 0 {
    return 1
  }
  counter := 0
  for _, pattern := range patterns {
    length := len(pattern)
    if len(towel) &lt; length {
      continue
    }
    if towel[:length] == pattern {
      precomputed, ok := (*cache)[towel[length:]]
      if ok {
        counter += precomputed
      } else {
        computed := nr_of_plausible(patterns, towel[length:], cache)
        (*cache)[towel[length:]] = computed
        counter += computed
      }
    }
  }
  return counter
}

func part_one() {
  var result int
  start := time.Now()
  patterns, rest := read_file("INPUT")
  for _, tow := range rest {
    if is_plausible(patterns, tow) {
      result += 1
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  patterns, towels := read_file("INPUT")
  cache := make(map[string]int)
  for _, towel := range towels {
    result += nr_of_plausible(patterns, towel, &amp;cache)
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "19 - Claw Contraption" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-20"><a class="header" href="#advent-of-code---year-2024-day-20">Advent of code - Year 2024 Day 20</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/20">day 20</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-20"><a class="header" href="#information-20">Information</a></h3>
<h4 id="part-1-19"><a class="header" href="#part-1-19">Part 1</a></h4>
<p>In the first part we will search the graph and find the length of the path. Then we do a flood-fill algorithm on all empty spaces so that we can have 2 picoseconds.</p>
<h4 id="part-2-19"><a class="header" href="#part-2-19">Part 2</a></h4>
<p>In the second part wee only have now 20 picoseconds instead.</p>
<h2 id="maingo-19"><a class="header" href="#maingo-19">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strings"
  "sync"
  "time"
)

const (
  Blue   = "[1;34m"
  Yellow = "[1;33m"
  Green  = "[1;32m"
  Reset  = "[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

const Max int = int(^uint(0) &gt;&gt; 1)

func read_file(file_path string) ([][]bool, [2]int, [2]int) {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var start [2]int
  var end [2]int
  var m [][]bool
  for i, line := range strings.Split(string(content), "\n") {
    if len(line) == 0 {
      continue
    }
    row := make([]bool, len(line))
    for j, c := range line {
      switch c {
        case '#':
          row[j] = false
        case '.':
          row[j] = true
        case 'S':
          row[j] = true
          start = [2]int{i, j}
        case 'E':
          row[j] = true
          end = [2]int{i, j}
      }
    }
    m = append(m, row)
  }
  return m, start, end
}

func get_neighbours(x, y int) [4][2]int {
   return [4][2]int{{x + 1,y}, {x - 1, y}, {x, y + 1},{x, y - 1}}
}

func find_shortest_path(m *[][]bool, position [2]int, length int, visited *[][]int) {
  if position[0] &lt; 0 || position[1] &lt; 0 || position[0] &gt;= len(*m) || position[1] &gt;= len((*m)[position[0]]) {
    return
  }
  if !(*m)[position[0]][position[1]] || (*visited)[position[0]][position[1]] &lt; length {
    return
  }
  (*visited)[position[0]][position[1]] = length
  for _, neigh := range get_neighbours(position[0], position[1]) {
    find_shortest_path(m, neigh, length + 1, visited)
  }
}

func find_shortcuts(m *[][]bool, visited *[][]int, timer, limit, length int, position [2]int, previous map[[2]int]int, ends map[[2]int]bool, cheat bool) {
  if timer &lt;= 0 {
    return
  }
  timer--
  length++
  for _, neigh := range get_neighbours(position[0], position[1]) {
    if neigh[0] &lt; 0 || neigh[1] &lt; 0 || neigh[0] &gt;= len(*m) || neigh[1] &gt;= len((*m)[neigh[0]]) {
      continue
    }
    if (*m)[neigh[0]][neigh[1]] &amp;&amp; (*visited)[neigh[0]][neigh[1]] - limit &gt;= length {
      ends[neigh] = true
    }
    prev, ok := previous[neigh]
    if ok &amp;&amp; prev &lt;= length {
      continue
    }
    previous[neigh] = length
    find_shortcuts(m, visited, timer, limit, length, neigh, previous, ends, cheat &amp;&amp; (*m)[neigh[0]][neigh[1]])
  }
}

func count_shortcuts(picoseconds, limit int) int {
  result := 0
  m, start_pos, end_pos := read_file("INPUT")
  visited := make([][]int, len(m))
  for i, row := range m {
    visited[i] = make([]int, len(m[i]))
    for j := range row {
      visited[i][j] = Max
    }
  }
  find_shortest_path(&amp;m, start_pos, 0, &amp;visited)
  var wg sync.WaitGroup
  c := make(chan int, visited[end_pos[0]][end_pos[1]] + 1)
  wg.Add(visited[end_pos[0]][end_pos[1]] + 1)
  for i, row := range m {
    for j := range row {
      if m[i][j] {
        ends := make(map[[2]int]bool)
        go func(i, j int) {
          defer wg.Done()
          find_shortcuts(&amp;m, &amp;visited, picoseconds, limit, visited[i][j], [2]int{i,j}, make(map[[2]int]int), ends, true)
          c &lt;- len(ends)
        }(i, j)
      }
    }
  }
  wg.Wait()
  close(c)
  for res := range c {
    result += res
  }
  return result
}

func part_one() {
  var result int
  start := time.Now()
  result = count_shortcuts(2, 100)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  result = count_shortcuts(20, 100)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "20 - Claw Contraption" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-21"><a class="header" href="#advent-of-code---year-2024-day-21">Advent of code - Year 2024 Day 21</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/21">day 21</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-21"><a class="header" href="#information-21">Information</a></h3>
<h4 id="part-1-20"><a class="header" href="#part-1-20">Part 1</a></h4>
<p>Generally we will establish ordering of arrow symbols, in this order <code>&lt;</code>, <code>v</code>, <code>^</code>, <code>&gt;</code> and <code>A</code>. Then we will create a mapping from one sequence on a pad to all others following te instructions. These sequences will be sorted in a previously mentioned way. Also we will move all leading <code>&gt;</code> symbols (if there is more than 1 of them). This mapping is from two characters to a sequence of instructions.</p>
<p>Then we will create optimal solution for numerical pad and then we will keep in map number of common sub-strings neighboring with <code>A</code>'s. We will repair such sequence by simulating the movement on the pad. lastly we move all symbols so that the same ones are neighbouring.</p>
<p>This way we proceed for the directional pad and compute it for <code>2</code> repetitions.</p>
<h4 id="part-2-20"><a class="header" href="#part-2-20">Part 2</a></h4>
<p>In the second one we only change <code>2</code> to <code>25</code>.</p>
<h2 id="maingo-20"><a class="header" href="#maingo-20">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "sort"
  "strconv"
  "strings"
  "time"
)

const (
  Blue   = "[1;34m"
  Yellow = "[1;33m"
  Green  = "[1;32m"
  Reset  = "[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

const Invalid rune = '#'

var Numpad [][]rune = [][]rune{
  {'#', '#', '#', '#', '#'},
  {'#', '7', '8', '9', '#'},
  {'#', '4', '5', '6', '#'},
  {'#', '1', '2', '3', '#'},
  {'#', '#', '0', 'A', '#'},
  {'#', '#', '#', '#', '#'},
}

var Numstart [2]int = [2]int{4, 3}

var Dirpad = [][]rune{
  {'#', '#', '#', '#', '#'},
  {'#', '#', '^', 'A', '#'},
  {'#', '&lt;', 'v', '&gt;', '#'},
  {'#', '#', '#', '#', '#'},
}

var Dirstart [2]int = [2]int{1, 3}

var order = map[rune]int{
  '&lt;': 1,
  'v': 2,
  '^': 3,
  '&gt;': 4,
  'A': 5,
}

func order_runes(a, b rune) bool {
  return order[a] &lt; order[b]
}

func read_file(file_path string) []string {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var codes []string
  for _, line := range strings.Split(string(content), "\n") {
    if len(line) == 0 {
      continue
    }
    codes = append(codes, line)
  }
  return codes
}

func add_one_neighbour(start, current [2]int, instr string, table map[[2]rune]string, pad [][]rune, sign rune) {
  if pad[current[0]][current[1]] != Invalid {
    append_neighbours(start, current, instr+string(sign), table, pad)
  }
}

func append_neighbours(start, current [2]int, instr string, table map[[2]rune]string, pad [][]rune) {
  c_start := pad[start[0]][start[1]]
  c_current := pad[current[0]][current[1]]
  prev, ok := table[[2]rune{c_start, c_current}]
  if ok &amp;&amp; len(prev) &lt;= len(instr) {
    return
  }
  table[[2]rune{c_start, c_current}] = instr + "A"
  add_one_neighbour(start, [2]int{current[0] + 1, current[1]}, instr, table, pad, 'v')
  add_one_neighbour(start, [2]int{current[0] - 1, current[1]}, instr, table, pad, '^')
  add_one_neighbour(start, [2]int{current[0], current[1] - 1}, instr, table, pad, '&lt;')
  add_one_neighbour(start, [2]int{current[0], current[1] + 1}, instr, table, pad, '&gt;')
}

func create_mapping(pad [][]rune) map[[2]rune]string {
  table := make(map[[2]rune]string)
  for i, row := range pad {
    for j := range row {
      if pad[i][j] != Invalid {
        append_neighbours([2]int{i, j}, [2]int{i, j}, "", table, pad)
      }
    }
  }
  for key, val := range table {
    runes := []rune(val)
    sort.Slice(runes, func(i, j int) bool {
      return order_runes(runes[i], runes[j])
    })
    table[key] = string(runes)
  }
  return table
}

func find(table map[[2]rune]string, instr string) string {
  instr = "A" + instr
  movement := ""
  for i := 1; i &lt; len(instr); i++ {
    movement += table[[2]rune{rune(instr[i-1]), rune(instr[i])}]
  }
  runes := []rune(movement)
  if runes[0] == '&lt;' &amp;&amp; runes[1] == '&lt;' {
    i := 0
    for ; runes[i] == '&lt;'; i++ {
    }
    j := i + 1
    for ; runes[j] == runes[i]; j++ {
    }
    for k := 0; k &lt; i &amp;&amp; i+k &lt; j; k++ {
      runes[k], runes[j-1-k] = runes[j-k-1], runes[k]
    }
  }
  movement = string(runes)
  return movement
}

func repair(intr string, pad [][]rune, i, j int) string {
  res := []rune(intr)
  for k := 0; k &lt; len(res); k++ {
    chr := res[k]
    switch chr {
    case '&lt;':
      if pad[i][j-1] == Invalid {
        res[k+1], res[k] = res[k], res[k+1]
        k--
      } else {
        j--
      }
    case '&gt;':
      if pad[i][j+1] == Invalid {
        res[k+1], res[k] = res[k], res[k+1]
        k--
      } else {
        j++
      }
    case '^':
      if pad[i-1][j] == Invalid {
        res[k+1], res[k] = res[k], res[k+1]
        k--
      } else {
        i--
      }
    case 'v':
      if pad[i+1][j] == Invalid {
        res[k+1], res[k] = res[k], res[k+1]
        k--
      } else {
        i++
      }
    }
  }
  return string(res)
}

func squish(instr string) string {
  runes := []rune(instr)
  for i := 1; i &lt; len(runes)-1; i++ {
    if runes[i] == 'A' || runes[i-1] == 'A' {
      continue
    }
    if runes[i-1] == runes[i+1] &amp;&amp; runes[i] != runes[i-1] {
      if runes[i-1] == '&gt;' {
        runes[i+1], runes[i] = runes[i], runes[i+1]
      } else {
        runes[i-1], runes[i] = runes[i], runes[i-1]
      }

    }
  }
  return string(runes)
}

func bootstrap(code string, repetitions int, table map[[2]rune]string, table_d map[[2]rune]string) int {
  m := squish(repair(find(table, code), Numpad, Numstart[0], Numstart[1]))
  counters := make(map[string]int)
  splited := strings.Split(m, "A")
  for _, str := range splited[:len(splited)-1] {
    prev, ok := counters["A"+str+"A"]
    if ok {
      counters["A"+str+"A"] = prev + 1
    } else {
      counters["A"+str+"A"] = 1
    }
  }
  for i := 0; i &lt; repetitions; i++ {
    counters = simplified(counters, table_d)
  }
  sum := 0
  for key, val := range counters {
    sum += val * (len(key) - 1)
  }
  return sum
}

func simplified(counters map[string]int, table map[[2]rune]string) map[string]int {
  new_map := make(map[string]int)
  for key, val := range counters {
    m := squish(repair(find(table, key), Dirpad, Dirstart[0], Dirstart[1]))
    splited := strings.Split(m, "A")
    for _, str := range splited[1 : len(splited)-1] {
      prev, ok := new_map["A"+str+"A"]
      if ok {
        new_map["A"+str+"A"] = val + prev
      } else {
        new_map["A"+str+"A"] = val
      }
    }
  }
  return new_map
}

func part_one() {
  var result int
  start := time.Now()
  codes := read_file("INPUT")
  table := create_mapping(Numpad)
  table_d := create_mapping(Dirpad)
  for _, code := range codes {
    nr, _ := strconv.Atoi(code[:len(code)-1])
    sum := bootstrap(code, 2, table, table_d)
    result += nr * sum
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  codes := read_file("INPUT")
  table := create_mapping(Numpad)
  table_d := create_mapping(Dirpad)
  for _, code := range codes {
    nr, _ := strconv.Atoi(code[:len(code)-1])
    sum := bootstrap(code, 25, table, table_d)
    result += nr * sum
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "21 - Claw Contraption" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-22"><a class="header" href="#advent-of-code---year-2024-day-22">Advent of code - Year 2024 Day 22</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/22">day 22</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-22"><a class="header" href="#information-22">Information</a></h3>
<h4 id="part-1-21"><a class="header" href="#part-1-21">Part 1</a></h4>
<p>In the first part we write the instructions as they are given in the description. Then perform <code>2000</code> generations.</p>
<h4 id="part-2-21"><a class="header" href="#part-2-21">Part 2</a></h4>
<p>In the second we go through the generated secrets and mark in table first number for each visited sequence. Then add the values from this table to the global table. After computing all secret sequences find the maximum in the table.</p>
<h2 id="maingo-21"><a class="header" href="#maingo-21">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "strconv"
  "time"
)

const (
  Blue   = "[1;34m"
  Yellow = "[1;33m"
  Green  = "[1;32m"
  Reset  = "[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) []int {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  regex := regexp.MustCompile("([0-9]+)")
  var secrets []int
  for _, find := range regex.FindAllStringSubmatch(string(content), -1) {
    nr, _ := strconv.Atoi(find[1])
    secrets = append(secrets, nr)
  }
  return secrets
}

func mix_and_prune(number, secret int) int {
  return (secret ^ number) % 16777216
}

func mod(number int) int {
  return ((number % 4) + 4 ) % 4
}

func generate(secret int) int {
  secret = mix_and_prune(secret * 64, secret)
  secret = mix_and_prune(secret / 32, secret)
  secret = mix_and_prune(secret * 2048, secret)
  return secret
}

func best_sell(secret int, big_table *map[[4]int]int) {
  table := make(map[[4]int]int)
  changes := [4]int{-10, -10, -10, -10}
  last := 0
  for i := 0; i &lt; 2000; i++ {
    secret = generate(secret)
    changes[i % 4] = (secret % 10) - last
    last = secret % 10
    if changes[3] != -10 {
      key := [4]int{changes[mod(i - 3)], changes[mod(i - 2)], changes[mod(i - 1)], changes[mod(i)]}
      _, ok := table[key]
      if !ok {
        table[key] = secret % 10
      }
    }
  }
  for key, val := range table {
    total, ok := (*big_table)[key]
    if ok {
      (*big_table)[key] = total + val
    } else {
      (*big_table)[key] = val
    }
  }
}

func part_one() {
  var result int
  start := time.Now()
  secrets := read_file("INPUT")
  for _, secret := range secrets {
    for i := 0; i &lt; 2000; i++ {
      secret = generate(secret)
    }
    result += secret
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  secrets := read_file("INPUT")
  table := make(map[[4]int]int)
  for _, secret := range secrets {
    best_sell(secret, &amp;table)
  }
  for _, val := range table {
    if val &gt; result {
      result = val
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "22 - Claw Contraption" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2024-day-23"><a class="header" href="#advent-of-code---year-2024-day-23">Advent of code - Year 2024 Day 23</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2024/day/23">day 23</a>. Go back to year <a href="aoc/2024.html">2024</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-23"><a class="header" href="#information-23">Information</a></h3>
<h4 id="part-1-22"><a class="header" href="#part-1-22">Part 1</a></h4>
<p>In the first part we will go through all nodes and look at their neighbours. For every neighbour we try to add additional neighbour and check if he is adjacent to the original node. This way we add all \(3!\) permutation, so we also divide it by <code>6</code>.</p>
<h4 id="part-2-22"><a class="header" href="#part-2-22">Part 2</a></h4>
<p>For the second part we use pretty much the same approach. We will be keeping the largest clique found so far. Then we look at the neighbours from one node to find a candidate, if the candidate is adjacent to all added nodes so far, then we just add it as well. This way we find the maximal one.</p>
<h2 id="maingo-22"><a class="header" href="#maingo-22">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "sort"
  "strings"
  "time"
)

const (
  Blue   = "[1;34m"
  Yellow = "[1;33m"
  Green  = "[1;32m"
  Reset  = "[0m"
)

func print_result(dur time.Duration, part int, result string) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + result + Reset)
}

func read_file(file_path string) map[string][]string {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  connections := make(map[string][]string)
  regex := regexp.MustCompile("([a-z]+)\\-([a-z]+)")
  for _, found := range regex.FindAllStringSubmatch(string(content), -1) {
    connections[found[1]] = append(connections[found[1]], found[2])
    connections[found[2]] = append(connections[found[2]], found[1])
  }
  return connections
}

func find_triples(connections map[string][]string) int {
  sum := 0
  for key, val := range connections {
    for _, neighbour := range val {
      for _, third := range connections[neighbour] {
        for _, circle := range connections[third] {
          if circle == key &amp;&amp; (third[0] == 't' || key[0] == 't' || neighbour[0] == 't') {
            sum += 1
          }
        }
      }
    }
  }
  return sum / (3 * 2)
}

func find_clique(connections map[string][]string) string {
  max := 0
  max_clique := make(map[string]bool)
  for key, val := range connections {
    for _, neighbour := range val {
      clique := make(map[string]bool, 0)
      clique[key] = true
      clique[neighbour] = true
    outer:
      for _, candidate := range connections[neighbour] {
      inner:
        for inside := range clique {
          for _, s := range connections[candidate] {
            if s == inside {
              continue inner
            }
          }
          continue outer
        }
        clique[candidate] = true
      }
      if max &lt; len(clique) {
        max_clique = clique
        max = len(max_clique)
      }
    }
  }
  var result []string
  for key := range max_clique {
    result = append(result, key)
  }
  sort.Strings(result)
  return strings.Join(result, ",")
}

func part_one() {
  var result int
  start := time.Now()
  connections := read_file("INPUT")
  result = find_triples(connections)
  end := time.Now()
  print_result(end.Sub(start), 1, fmt.Sprint(result))
}

func part_two() {
  var result string
  start := time.Now()
  connections := read_file("INPUT")
  result = find_clique(connections)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2024" + Reset + " day " + Green + "23 - Claw Contraption" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023"><a class="header" href="#advent-of-code---year-2023">Advent of code - Year 2023</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2023">year 2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days-1"><a class="header" href="#days-1">Days</a></h3>
<ul>
<li><a href="aoc/2023-1.html">Day 1</a></li>
<li><a href="aoc/2023-2.html">Day 2</a></li>
<li><a href="aoc/2023-3.html">Day 3</a></li>
<li><a href="aoc/2023-4.html">Day 4</a></li>
<li><a href="aoc/2023-5.html">Day 5</a></li>
<li><a href="aoc/2023-6.html">Day 6</a></li>
<li><a href="aoc/2023-7.html">Day 7</a></li>
<li><a href="aoc/2023-8.html">Day 8</a></li>
<li><a href="aoc/2023-9.html">Day 9</a></li>
<li><a href="aoc/2023-10.html">Day 10</a></li>
<li><a href="aoc/2023-11.html">Day 11</a></li>
<li><a href="aoc/2023-12.html">Day 12</a></li>
<li><a href="aoc/2023-13.html">Day 13</a></li>
<li><a href="aoc/2023-14.html">Day 14</a></li>
<li><a href="aoc/2023-15.html">Day 15</a></li>
<li><a href="aoc/2023-16.html">Day 16</a></li>
<li><a href="aoc/2023-17.html">Day 17</a></li>
<li><a href="aoc/2023-18.html">Day 18</a></li>
<li><a href="aoc/2023-19.html">Day 19</a></li>
<li><a href="aoc/2023-20.html">Day 20</a></li>
<li><a href="aoc/2023-21.html">Day 21</a></li>
<li><a href="aoc/2023-22.html">Day 22</a></li>
<li><a href="aoc/2023-23.html">Day 23</a></li>
<li><a href="aoc/2023-24.html">Day 24</a></li>
<li><a href="aoc/2023-25.html">Day 25</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-1"><a class="header" href="#advent-of-code---year-2023-day-1">Advent of code - Year 2023 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/1">day 1</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-24"><a class="header" href="#information-24">Information</a></h3>
<h4 id="part-1-23"><a class="header" href="#part-1-23">Part 1</a></h4>
<p>In the first part we delete all non-digits characters and found the first and last one.</p>
<h4 id="part-2-23"><a class="header" href="#part-2-23">Part 2</a></h4>
<p>In the second part we also replace written digits as numbers, but keep overlaps. Then again find the first and last digit.</p>
<h2 id="mainrs"><a class="header" href="#mainrs">main.rs</a></h2>
<pre><code class="language-rs">use regex::Regex;
use std::fs;

fn read_file(filepath: &amp;str) -&gt; Vec&lt;String&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let lines: Vec&lt;String&gt; = binding
        .split('\n')
        .filter(|l| l.len() &gt; 0)
        .map(|l| l.to_string())
        .collect();
    lines
}

fn part1() {
    let lines = read_file("INPUT");
    let regex = Regex::new(r"[^1-9]").unwrap();
    let mut total: u32 = 0;
    for line in lines {
        let numbers = regex.replace_all(&amp;line, "");
        total += 10 * numbers.chars().nth(0).unwrap().to_digit(10).unwrap();
        total += numbers
            .chars()
            .nth(numbers.len() - 1)
            .unwrap()
            .to_digit(10)
            .unwrap();
    }
    println!("Part 1: {}", total);
}

fn part2() {
    let lines = read_file("INPUT");
    const LEN: usize = 9;
    let origin: [&amp;str; LEN] = [
        r"one", r"two", r"three", r"four", r"five", r"six", r"seven", r"eight", r"nine",
    ];
    let new: [&amp;str; LEN] = [
        "o1ne", "t2wo", "th3ree", "fo4ur", "fi5ve", "s6ix", "se7ven", "ei8ght", "ni9ne",
    ];
    let regex = Regex::new(r"[^1-9]").unwrap();
    let mut total: u32 = 0;
    for line in lines {
        let mut numbers = line.clone();
        for i in 0..LEN {
            let nr = Regex::new(origin[i]).unwrap();
            numbers = nr.replace_all(&amp;numbers, new[i]).to_string();
        }
        numbers = regex.replace_all(&amp;numbers, "").to_string();
        total += 10 * numbers.chars().nth(0).unwrap().to_digit(10).unwrap();
        total += numbers
            .chars()
            .nth(numbers.len() - 1)
            .unwrap()
            .to_digit(10)
            .unwrap();
    }
    println!("Part 2: {}", total);
}

fn main() {
    println!("Year 2023 day 1 - Trebuchet?!");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-2"><a class="header" href="#advent-of-code---year-2023-day-2">Advent of code - Year 2023 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/2">day 2</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-25"><a class="header" href="#information-25">Information</a></h3>
<h4 id="part-1-24"><a class="header" href="#part-1-24">Part 1</a></h4>
<p>In both parts we use regexes to find red, blue and green numbers. In the first part we compare these values to the limits.</p>
<h4 id="part-2-24"><a class="header" href="#part-2-24">Part 2</a></h4>
<p>In the second part we compute the maximums.</p>
<h2 id="mainrs-1"><a class="header" href="#mainrs-1">main.rs</a></h2>
<pre><code class="language-rs">use regex::Regex;
use std::cmp::max;
use std::fs;

type Colors = (i64, i64, i64);

fn read_file(filepath: &amp;str) -&gt; Vec&lt;String&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let lines: Vec&lt;String&gt; = binding
        .split('\n')
        .filter(|c| c.len() &gt; 0)
        .map(|c| c.to_string())
        .collect();
    lines
}

fn get_colors(line: &amp;str) -&gt; (i64, Vec&lt;Colors&gt;) {
    let re_game = Regex::new(r"Game ([0-9]+)").unwrap();
    let game = re_game.captures(line).unwrap()[1].parse::&lt;i64&gt;().unwrap();
    let mut colors: Vec&lt;Colors&gt; = vec![];
    let re_red = Regex::new(r"([0-9]+) red").unwrap();
    let re_blue = Regex::new(r"([0-9]+) blue").unwrap();
    let re_green = Regex::new(r"([0-9]+) green").unwrap();
    for part in line.split(';') {
        let mut red = 0_i64;
        for (_, [number]) in re_red.captures_iter(part).map(|c| c.extract()) {
            red += number.parse::&lt;i64&gt;().unwrap();
        }
        let mut blue = 0_i64;
        for (_, [number]) in re_blue.captures_iter(part).map(|c| c.extract()) {
            blue += number.parse::&lt;i64&gt;().unwrap();
        }
        let mut green = 0_i64;
        for (_, [number]) in re_green.captures_iter(part).map(|c| c.extract()) {
            green += number.parse::&lt;i64&gt;().unwrap();
        }
        colors.push((red, green, blue));
    }
    (game, colors)
}

fn part1() {
    let lines = read_file("INPUT");
    let limits: [i64; 3] = [12, 13, 14];
    let mut total: i64 = 0;
    for line in lines {
        let (game, colors) = get_colors(&amp;line);
        let feasible: bool = colors
            .into_iter()
            .map(|(r, g, b)| r &lt;= limits[0] &amp;&amp; g &lt;= limits[1] &amp;&amp; b &lt;= limits[2])
            .fold(true, |acc, x| acc &amp;&amp; x);
        if feasible {
            total += game;
        }
    }
    println!("Part 1: {}", total);
}

fn part2() {
    let lines = read_file("INPUT");
    let mut total: i64 = 0;
    for line in lines {
        let (_game, colors) = get_colors(&amp;line);
        let maxes = colors.into_iter().fold((0, 0, 0), |acc, (r, g, b)| {
            (max(acc.0, r), max(acc.1, g), max(acc.2, b))
        });
        total += maxes.0 * maxes.1 * maxes.2;
    }
    println!("Part 2: {}", total);
}

fn main() {
    println!("Year 2023 day 2 - Cube Conundrum");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-3"><a class="header" href="#advent-of-code---year-2023-day-3">Advent of code - Year 2023 Day 3</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/3">day 3</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy"><a class="header" href="#mainpy">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

triplets = [[] for _ in range(3)]
first_sum = 0
second_sum = 0

GEAR = "*"
TAIL = -1

def is_special(char):
  return char != '.' and not char.isdigit()

def transform_row(row):
  """ Get the numbers and put it in the begining position
      and as the tail insert -1. Otherwise 0. """
  number = 0
  index = 0
  new_row = [0 for _ in row]
  for i in range(len(row)):
    if row[i].isdigit():
      if number == 0:
        index = i
      number = number * 10 + int(row[i])
    else:
      new_row[index] = number
      for j in range(index+1, i):
        new_row[j] = TAIL
      index = i
      number = 0
  return new_row

def get_number(row, index, r_index):
  """ Get the number at this index in the row. """
  if index &lt; 0 or index &gt;= len(row):
    return (0, -1)
  i = 0
  while row[index - i] == TAIL:
    i += 1
  return (row[index - i], index - i, r_index)

def scan_gears(t_triplets, triplets):
  """ Scan the gears for the middle triplet. """
  my_sum = 0
  for i in range(len(triplets[1])):
    if triplets[1][i] == GEAR:
      numbers = [get_number(t_triplets[0], i-1, 0),
                 get_number(t_triplets[0], i  , 0),
                 get_number(t_triplets[0], i+1, 0),
                 get_number(t_triplets[1], i-1, 1),
                 get_number(t_triplets[1], i+1, 1),
                 get_number(t_triplets[2], i-1, 2),
                 get_number(t_triplets[2], i  , 2),
                 get_number(t_triplets[2], i+1, 2)]
      numbers = filter(lambda part : part[0] &gt; 0, numbers)
      numbers = list(dict.fromkeys(numbers))
      if len(numbers) == 2:
        my_sum = my_sum + numbers[0][0] * numbers[1][0]
  return my_sum

def sum_middle(row, scan):
  """ Sum those numbers that are scanned.
      At least one scan throughout the number. """
  number = 0
  my_sum = 0
  scanned = False
  for i in range(len(row)):
    if row[i].isdigit():
      number = number * 10 + int(row[i])
      if scan[i]:
        scanned = scan[i]
    else:
      if scanned:
        my_sum = my_sum + number
      number = 0
      scanned = False
  if scanned and number != 0:
    my_sum = my_sum + number
  return my_sum

def scan_middle(triplets):
  """ Scan the middle row if each char has
      special character near him. """
  scanning = [False for _ in triplets[1]]
  for i in range(len(triplets[1])):
    if i &gt; 0 and is_special(triplets[1][i-1]):
      scanning[i] = True
    elif i &lt; len(triplets[1]) - 1 and is_special(triplets[1][i+1]):
      scanning[i] = True
    for j in range(i - 1, i+2):
      for t in [triplets[0], triplets[2]]:
        if j &gt;= 0 and j &lt; len(t) and is_special(t[j]):
          scanning[i] = True
  return sum_middle(triplets[1], scanning)

with open('INPUT') as f:
  for line in f:
    triplets[0], triplets[1] = triplets[1], triplets[2]
    triplets[2] = [c for c in line.strip()]
    first_sum += scan_middle(triplets)
    second_sum += scan_gears([transform_row(triplets[0]), transform_row(triplets[1]), transform_row(triplets[2])], triplets)
  triplets[0], triplets[1], triplets[2] = triplets[1], triplets[2], []
  first_sum += scan_middle(triplets)
  second_sum += scan_gears([transform_row(triplets[0]), transform_row(triplets[1]), transform_row(triplets[2])], triplets)

print(f"First part: {first_sum}")
print(f"Second sum: {second_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-4"><a class="header" href="#advent-of-code---year-2023-day-4">Advent of code - Year 2023 Day 4</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/4">day 4</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-1"><a class="header" href="#mainpy-1">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

# Out of curiosity I got the time my solution.
import time

first_sum = 0
second_sum = 0

tic = time.perf_counter()

with open('INPUT') as f:
  multiples = [1]
  for line in f:
    if len(multiples) == 0:
      multiples.append(1)
    hand = line.strip().split(":")
    types = hand[1].strip().split("|")
    winning = types[0].strip().split(" ")
    winning = filter(lambda nr : len(nr) &gt; 0, winning)
    win_set = set([int(w) for w in winning])
    having = types[1].strip().split(" ")
    having = filter(lambda nr : len(nr) &gt; 0, having)
    hav_set = set([int(h) for h in having])
    res = win_set.intersection(hav_set)
    for i in range(len(res)):
      if i + 1 &gt;= len(multiples):
        multiples.append(1)
      multiples[i+1] += multiples[0]
    second_sum += multiples[0]
    multiples.pop(0)
    points = 0
    if len(res) &gt; 0:
      points = 2 ** (len(res) - 1)
    first_sum += points

toc = time.perf_counter()

print(f"First part: {first_sum}")
print(f"Second part: {second_sum}")
print(f"Time: {((toc - tic) * 1000):3f} ms")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-5"><a class="header" href="#advent-of-code---year-2023-day-5">Advent of code - Year 2023 Day 5</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/5">day 5</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-2"><a class="header" href="#mainpy-2">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

seeds = []
range_seeds = []
"""
[(begining, size, True/False), ...
Each time we split one tuple.
"""

def interval(f, f_beg, t_beg, size):
  if f &gt;= f_beg and f &lt;= f_beg + size:
    return ((f - f_beg) + t_beg, True)
  return (0, False)

def range_interval(f, f_size, f_beg, t_beg, size):
  beg_inside = f &gt;= f_beg and f &lt;= f_beg + size
  end_inside = f + f_size &gt;= f_beg and f + f_size &lt;= f_beg + size
  outside = f &lt; f_beg and f + f_size &gt; f_beg + size

  interval_beg = f
  interval_end = f + f_size
  from_begining = f_beg
  from_end = f_beg + size
  shift = - f_beg + t_beg

  if beg_inside and end_inside:
    return [((f - f_beg) + t_beg, f_size, True)]
  elif beg_inside:
    return [(interval_beg + shift, from_end - interval_beg + 1, True), (from_end + 1, interval_end - from_end - 1, False)]
  elif end_inside:
    return [(from_begining + shift, interval_end - from_begining, True), (interval_beg, from_begining - interval_beg, False)]
  elif outside:
    return [(from_begining + shift, size, True), (interval_beg, from_begining - interval_beg + 1, False), (from_end, interval_end - from_end + 1, False)]
  else:
    return []

def reset(seeds):
  for i in range(len(seeds)):
    seeds[i] = (seeds[i][0], False)

def reset_range(seeds):
  for i in range(len(seeds)):
    seeds[i] = (seeds[i][0], seeds[i][1], False)

with open('INPUT') as f:
  for line in f:
    parts = line.strip().split(" ")
    if parts[0] == "seeds:":
      for i in range(1, len(parts)):
        seeds.append((int(parts[i]), False))
      for i in range(1, len(parts), 2):
        range_seeds.append((int(parts[i]), int(parts[i+1]), False))
    elif len(parts[0]) == 0 or not parts[0][0].isdigit():
      reset(seeds)
      reset_range(range_seeds)
    else:
      t_beg = int(parts[0])
      f_beg = int(parts[1])
      size = int(parts[2])
      for i in range(len(seeds)):
        if not seeds[i][1]:
          ret = interval(seeds[i][0], f_beg, t_beg, size)
          if ret[1]:
            seeds[i] = ret
      for i in range(len(range_seeds)):
        if not range_seeds[i][2]:
          ret = range_interval(range_seeds[i][0], range_seeds[i][1], f_beg, t_beg, size)
          if ret != []:
            range_seeds.pop(i)
          for j in range(len(ret)):
            range_seeds.insert(i, ret[j])

real_seeds = [x[0] for x in seeds]
real_range_seeds = [x[0] for x in range_seeds]
print(f"First part: {min(real_seeds)}")  
print(f"Second part: {min(real_range_seeds)}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-6"><a class="header" href="#advent-of-code---year-2023-day-6">Advent of code - Year 2023 Day 6</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/6">day 6</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-3"><a class="header" href="#mainpy-3">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

times = []
records = []
tot_time = 0
tot_record = 0

first_sum = 1
second_sum = 0

def ignore_space(string):
  num = 0
  for c in string:
    if c.isdigit():
      num = num * 10 + int(c)
  return num

with open('INPUT') as f:
  for line in f:
    parts = list(filter(lambda part : len(part) &gt; 0, line.strip().split(" ")))
    splitted_line = line.strip().split(":")
    if splitted_line[0] == "Time":
      times = [int(x) for x in parts[1:]]
      tot_time = ignore_space(splitted_line[1].strip())
    else:
      records = [int(x) for x in parts[1:]]
      tot_record = ignore_space(splitted_line[1].strip())

for i in range(len(times)):
  counter = 0
  for t in range(times[i]):
    speed = t
    remaining_time = times[i] - t
    travel = speed * remaining_time
    if travel &gt; records[i]:
      counter += 1
  first_sum *= counter


"""
This may not be fast, but it will do.
"""

for t in range(tot_time):
  speed = t
  remaining_time = tot_time - t
  travel = speed * remaining_time
  if travel &gt; tot_record:
    second_sum += 1

print(f"First part: {first_sum}")
print(f"Second sum: {second_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-7"><a class="header" href="#advent-of-code---year-2023-day-7">Advent of code - Year 2023 Day 7</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/7">day 7</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="maincpp"><a class="header" href="#maincpp">main.cpp</a></h2>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;

const char JOKER = 'J';

std::map&lt;char, int&gt; mapping = { {'A', 12},
                              {'K', 11},
                              {'Q', 10},
                              {'J',  9},
                              {'T',  8},
                              {'9',  7},
                              {'8',  6},
                              {'7',  5},
                              {'6',  4},
                              {'5',  3},
                              {'4',  2},
                              {'3',  1},
                              {'2',  0} };

struct Hand{
  std::string hand;
  int bet;
  int rating;
  void compute_rating(){
    std::map&lt;char, int&gt; counters = { {'A', 0}, {'K', 0}, {'Q', 0}, {'J', 0},
                                     {'T', 0}, {'9', 0}, {'8', 0}, {'7', 0},
                                     {'6', 0}, {'5', 0}, {'4', 0}, {'3', 0},
                                     {'2', 0} };
    for(size_t i = 0; i &lt; hand.size(); ++i)
      ++counters[hand[i]];
    size_t fives = 0;
    size_t fours = 0;
    size_t threes = 0;
    size_t twos = 0;
    for(auto&amp;&amp; [key, counter] : counters){
      if(counter == 5) ++fives;
      else if(counter == 4) ++fours;
      else if (counter == 3) ++threes;
      else if (counter == 2) ++twos;
    }
    if(fives == 1) rating = 6;
    else if(fours == 1) rating = 5;
    else if(threes == 1 &amp;&amp; twos == 1) rating = 4;
    else if (threes == 1) rating = 3;
    else if (twos == 2) rating = 2;
    else if (twos == 1) rating = 1;
    else rating = 0;
  }
  void compute_joker_rating(){
    std::map&lt;char, int&gt; counters = { {'A', 0}, {'K', 0}, {'Q', 0}, {'J', 0},
                                     {'T', 0}, {'9', 0}, {'8', 0}, {'7', 0},
                                     {'6', 0}, {'5', 0}, {'4', 0}, {'3', 0},
                                     {'2', 0}, {'J' , 0} };
    for(size_t i = 0; i &lt; hand.size(); ++i)
      ++counters[hand[i]];
    size_t jokers = counters[JOKER];
    char max;
    int m = -1;
    for(auto&amp;&amp; [key, counter] : counters){
      if(key == JOKER) continue;
      else if(m &lt; counter){
        m = counter;
        max = key;
      }
    }
    size_t fives = 0;
    size_t fours = 0;
    size_t threes = 0;
    size_t twos = 0;
    for(auto&amp;&amp; [key, counter] : counters){
      if(key == JOKER) continue;
      if(key == max){
        if(counter + jokers == 5) ++fives;
        else if(counter + jokers == 4) ++fours;
        else if (counter + jokers == 3) ++threes;
        else if (counter + jokers == 2) ++twos;
      }
      else{
        if(counter == 5) ++fives;
        else if(counter == 4) ++fours;
        else if (counter == 3) ++threes;
        else if (counter == 2) ++twos;
      }
    }
    if(fives == 1) rating = 6;
    else if(fours == 1) rating = 5;
    else if(threes == 1 &amp;&amp; twos == 1) rating = 4;
    else if (threes == 1) rating = 3;
    else if (twos == 2) rating = 2;
    else if (twos == 1) rating = 1;
    else rating = 0;
  }
  void read(const std::string&amp; line){
    std::stringstream ss;
    for(size_t i = 0; i &lt; line.size(); ++i){
      if(line[i] == ' '){
        bet = std::stoi(line.substr(i+1));
        break;
      }
      else ss &lt;&lt; line[i];
    }
    hand = ss.str();
  }
};

bool operator&lt;(const Hand&amp; h1, const Hand&amp; h2){
  if(h1.rating &lt; h2.rating)
    return true;
  else if(h2.rating &lt; h1.rating)
    return false;
  else{
    size_t i = 0;
    for(; mapping[h1.hand[i]] == mapping[h2.hand[i]] &amp;&amp; i &lt; h1.hand.size(); ++i){}
    if (mapping[h1.hand[i]] &gt; mapping[h2.hand[i]])
      return false;
    return true;
  }
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Hand&amp; h){
  os &lt;&lt; "Hand: " &lt;&lt; h.hand &lt;&lt; " rating: " &lt;&lt; h.rating &lt;&lt; " bet: " &lt;&lt; h.bet;
  return os;
}

void read_file(const std::string&amp; file, std::vector&lt;Hand&gt;&amp; hands){
  std::ifstream ifs;
  ifs.open(file);
  std::string line;
  while(getline(ifs, line)){
    Hand h;
    h.read(line);
    hands.push_back(h);
  }
}

int sum(const std::vector&lt;Hand&gt;&amp; hands){
  int my_sum = 0;
  for(size_t i = 0; i &lt; hands.size(); ++i){
    my_sum += (i+1) * hands[i].bet;
  }
  return my_sum;
}

int main(int argc, char** argv){
  std::vector&lt;Hand&gt; hands;
  read_file("INPUT", hands);
  for(auto&amp;&amp; h : hands)
    h.compute_rating();
  std::sort(hands.begin(), hands.end());
  std::cout &lt;&lt; "First part: " &lt;&lt; sum(hands) &lt;&lt; std::endl;
  for(auto&amp;&amp; h : hands)
    h.compute_joker_rating();
  mapping[JOKER] = -1;
  std::sort(hands.begin(), hands.end());
  std::cout &lt;&lt; "Second part: " &lt;&lt; sum(hands) &lt;&lt; std::endl;
  
  return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-8"><a class="header" href="#advent-of-code---year-2023-day-8">Advent of code - Year 2023 Day 8</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/8">day 8</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-4"><a class="header" href="#mainpy-4">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

""" Initialization. """
moves = ""
mapping = dict()
move = {'L' : 0, 'R' : 1}
starting_nodes = list()
ending_nodes = list()
start = 'AAA'
end = 'ZZZ'

""" Read input. """
with open('INPUT') as f:
  for line in f:
    if len(line.strip()) != 0:
      if moves == "":
        moves = line.strip()
      else:
        from_to = line.strip().split(" = ")
        mapping[from_to[0]] = from_to[1][1:-1].split(", ")
        if from_to[0][-1] == 'A':
          starting_nodes.append(from_to[0])
        elif from_to[0][-1] == 'Z':
          ending_nodes.append(from_to[0])

def find(moves, mapping, move, point, end):
  """ Find path from point to some point in the end.
      Using moves and given mapping. """
  counter = 0
  while True:
    for c in moves:
      point = mapping[point][move[c]]
      counter += 1
      if point in end:
        return counter

def gcd(a, b):
  """ Greatest common denominator. """
  if a &lt; b:
    a, b = b, a
  while b != 0:
    t = b
    b = a % b
    a = t
  return a

def lcm(a, b):
  """ Least common multiple. """
  return (a * b) / gcd(a, b)

def lcm_list(lengths):
  """ Least common multiple for more numbers. """
  numbers = [j for j in lengths]
  while len(numbers) &gt; 1:
    first, second = numbers[0], numbers[1]
    numbers.pop(0)
    numbers.pop(0)
    numbers.append(lcm(first, second))
  return int(numbers[0])

def find_common(moves, mapping, move, starting_nodes, ending_nodes):
  """ Find common number for multiple paths. """
  lengths = set()
  for point in starting_nodes:
    lengths.add(find(moves, mapping, move, point, ending_nodes))
  return lcm_list(lengths)

print(f"First part: {find(moves, mapping, move, start, [end])}")
print(f"Second part: {find_common(moves, mapping, move, starting_nodes, ending_nodes)}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-9"><a class="header" href="#advent-of-code---year-2023-day-9">Advent of code - Year 2023 Day 9</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/9">day 9</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-5"><a class="header" href="#mainpy-5">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

first_sum = 0
second_sum = 0

def all_zero(array):
  return all([x == 0 for x in array])

def diffs(array):
  new_array = []
  for i in range(len(array) - 1):
    new_array.append(array[i+1] - array[i])
  return new_array

def create_history(array):
  hist = [array]
  while not all_zero(hist[-1]):
    hist.append(diffs(hist[-1]))
  return hist

def propagate(hist):
  hist[-1].append(0)
  for i in range(1, len(hist)):
    size = len(hist) - i - 1
    hist[size].append(hist[size + 1][-1] + hist[size][-1])
  return hist

def propagate_first(hist):
  hist[-1].insert(0, 0)
  for i in range(1, len(hist)):
    size = len(hist) - i - 1
    hist[size].insert(0, hist[size][0] - hist[size + 1][0])

with open('INPUT') as f:
  for line in f:
    hist = create_history([int(x) for x in line.strip().split(" ")])
    propagate(hist)
    propagate_first(hist)
    first_sum += hist[0][-1]
    second_sum += hist[0][0]

print(f"First part: {first_sum}")
print(f"Second part: {second_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-10"><a class="header" href="#advent-of-code---year-2023-day-10">Advent of code - Year 2023 Day 10</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/10">day 10</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-6"><a class="header" href="#mainpy-6">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

from shapely import Polygon

""" ==Constants== """
START = 'S'
EMPTY = '.'
UP_DOWN = '|'
LEFT_RIGHT = '-'
DOWN_RIGHT = 'F'
DOWN_LEFT = '7'
UP_RIGHT = 'L'
UP_LEFT = 'J'
DOWN = 0
UP = 1
LEFT = 2
RIGHT = 3

""" ==Initialization== """
sewers = []
starting_point = (-1,-1)

def step(init_pos, sewers, x, y):
  """ Simulate one step from init_pos at (x,y)
      in the sewers. """
  pipe = sewers[x][y]
  if pipe == UP_RIGHT:
    if init_pos == DOWN:
      return (RIGHT, x, y + 1)
    else:
      return (UP, x - 1, y)
  elif pipe == UP_LEFT:
    if init_pos == DOWN:
      return (LEFT, x, y - 1)
    else:
      return (UP, x - 1, y)
  elif pipe == UP_DOWN:
    if init_pos == UP:
      return (UP, x - 1, y)
    else:
      return (DOWN, x + 1, y)
  elif pipe == LEFT_RIGHT:
    if init_pos == LEFT:
      return (LEFT, x, y - 1)
    else:
      return (RIGHT, x, y + 1)
  elif pipe == DOWN_LEFT:
    if init_pos == UP:
      return (LEFT, x, y - 1)
    else:
      return (DOWN, x + 1, y)
  elif pipe == DOWN_RIGHT:
    if init_pos == UP:
      return (RIGHT, x, y + 1)
    else:
      return (DOWN, x + 1, y)

def find_start_pos(sewers, starting_point):
  """ Find one of the endpoints to the starting point. """
  x = starting_point[0]
  y = starting_point[1]
  if y + 1 &lt; len(sewers[x]) and (sewers[x][y+1] == LEFT_RIGHT or sewers[x][y+1] == UP_LEFT or sewers[x][y+1] == DOWN_LEFT):
    return (RIGHT, x, y + 1)
  elif y - 1 &gt;= 0 and (sewers[x][y-1] == LEFT_RIGHT or sewers[x][y-1] == UP_RIGHT or sewers[x][y+1] == DOWN_RIGHT):
    return (LEFT, x, y - 1)
  elif x + 1 &lt; len(sewers) and (sewers[x+1][y] == UP_DOWN or sewers[x+1][y] == DOWN_RIGHT or sewers[x+1][y] == DOWN_LEFT):
    return (UP, x + 1, y)
  else:
    return (DOWN, x - 1, y)

def outline_and_coords(sewers, starting_point):
  """ Create an outline of the pipeline.
      And also coordinates of the curved boundaries. """
  pipeline = [[False for _ in x] for x in sewers]
  coords = []
  
  pipeline[starting_point[0]][starting_point[1]] = True
  coords.append((starting_point[0],starting_point[1]))
  
  pos = find_start_pos(sewers, starting_point)
  
  pipeline[pos[1]][pos[2]] = True
  if sewers[pos[1]][pos[2]] != UP_DOWN and sewers[pos[1]][pos[2]] != LEFT_RIGHT:
    coords.append((pos[1],pos[2]))
  
  pos = step(pos[0], sewers, pos[1], pos[2])
  while sewers[pos[1]][pos[2]] != START:
    pipeline[pos[1]][pos[2]] = True
    if sewers[pos[1]][pos[2]] != UP_DOWN and sewers[pos[1]][pos[2]] != LEFT_RIGHT:
      coords.append((pos[1],pos[2]))
    pos = step(pos[0], sewers, pos[1], pos[2])
  return pipeline, coords

def distance(outline):
  """ Compute the distance of the pipeline. """
  my_sum = 0
  for x in outline:
    for y in x:
      if y:
        my_sum += 1
  return my_sum

with open('INPUT') as f:
  for line in f:
    sewer_line = [x for x in line.strip()]
    if START in sewer_line:
      starting_point = (len(sewers), sewer_line.index(START))
    sewers.append(sewer_line)

pipeline, coords = outline_and_coords(sewers, starting_point)
dist = distance(pipeline)
# Create a polygon from the coordiantes.
pgon = Polygon(coords)
# Use Pick's Theorem
# https://en.wikipedia.org/wiki/Pick%27s_theorem
interior = int(pgon.area +1 - dist / 2)
print(f"First part: { dist // 2}")
print(f"Second part: {interior}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-11"><a class="header" href="#advent-of-code---year-2023-day-11">Advent of code - Year 2023 Day 11</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/11">day 11</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-7"><a class="header" href="#mainpy-7">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

original_map = []

def find_galaxies(original_map):
  galaxies = []
  for i in range(len(original_map)):
    for j in range(len(original_map[i])):
      if original_map[i][j] == "#":
        galaxies.append((i,j))
  return galaxies

def empty_list(array):
  return all([x == "." for x in array])

def empty(original_map):
  rows = []
  columns = []
  for i in range(len(original_map)):
    if empty_list(original_map[i]):
      columns.append(i)
  for j in range(len(original_map[0])):
    if empty_list([original_map[x][j] for x in range(len(original_map))]):
      rows.append(j)
  return rows, columns

def expand(gal, rows, columns, addition):
  for i in range(len(gal)):
    add = 0
    original = True
    for r in rows:
      if r &lt; gal[i][1]:
        add += addition
      else:
        gal[i] = (gal[i][0], gal[i][1] + add)
        original = False
        break
    if original:
      gal[i] = (gal[i][0], gal[i][1] + add)
    add = 0
    original = True
    for c in columns:
      if c &lt; gal[i][0]:
        add += addition
      else:
        gal[i] = (gal[i][0] + add, gal[i][1])
        original = False
        break
    if original:
      gal[i] = (gal[i][0] + add, gal[i][1])

def length(gal):
  total = 0
  for i in range(len(gal)):
    for j in range(i + 1, len(gal)):
      dist = abs(gal[i][0] - gal[j][0]) + abs(gal[i][1] - gal[j][1])
      total += dist
  return total

with open('INPUT') as f:
  for line in f:
    original_map.append([x for x in line.strip()])

galaxies = find_galaxies(original_map)
rows, columns = empty(original_map)
expand(galaxies, rows, columns, 2 - 1)
print(f"First part: {length(galaxies)}")
galaxies = find_galaxies(original_map)
expand(galaxies, rows, columns, 1_000_000 - 1)
print(f"Second part: {length(galaxies)}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-12"><a class="header" href="#advent-of-code---year-2023-day-12">Advent of code - Year 2023 Day 12</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/12">day 12</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-8"><a class="header" href="#mainpy-8">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def count_placements(groups, clusters, cache = dict()):
  key = "|".join(map(str, groups))
  key += "#" + ":".join(clusters)
  if key in cache:
    return cache[key]

  if not groups:
    for cluster in clusters:
      if '#' in cluster:
        return 0
    return 1
  if not clusters:
    return 0
  ret = 0
  cluster = clusters[0]
  group = groups[0]
  len_cluster = len(cluster)
  if group &gt; len_cluster and '#' in cluster:
    return 0
  for i in range(len_cluster - group + 1):
    left = cluster[:i]
    if '#' in left:
      continue
    right = cluster[i + group:]
    if right.startswith('#'):
      continue
    new_clusters = clusters[1:]
    if len(right) &gt; 1:
      new_clusters.insert(0, right[1:])
    ret += count_placements(groups[1:], new_clusters, cache)

  if '#' not in cluster:
    ret += count_placements(groups, clusters[1:], cache)

  cache[key] = ret

  return ret


def compute(expand):
  total = 0
  with open('INPUT', 'r') as file:
    for line in file:
      springs, groups_str = line.strip().split()
      groups = [int(x) for x in groups_str.split(",")]
      if expand:
        springs = "?".join(5 * [springs])
        groups = 5 * groups
      clusters = [s for s in springs.split('.') if s]
      delta = count_placements(groups, clusters)
      total += delta
  return total

def part1():
  return compute(False)

def part2():
  return compute(True)

print(f"First part: {part1()}")
print(f"Second part: {part2()}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-13"><a class="header" href="#advent-of-code---year-2023-day-13">Advent of code - Year 2023 Day 13</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/13">day 13</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-9"><a class="header" href="#mainpy-9">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def differences(array1, array2):
  return sum([array1[i] != array2[i] for i in range(len(array1))])

def column_symmetry(matrix, smudges):
  for i in range(1, len(matrix[0])):
    shift = 0
    total = 0
    while i - shift - 1 &gt;= 0 and i + shift &lt;= len(matrix[0]) - 1 and total &lt;= smudges:
      first_column = [matrix[j][i + shift] for j in range(len(matrix))]
      second_column = [matrix[j][i - shift - 1] for j in range(len(matrix))]
      total += differences(first_column, second_column)
      shift += 1
    if total == smudges:
      return i
  return 0

def row_symmetry(matrix, smudges):
  for i in range(1, len(matrix)):
    shift = 0
    total = 0
    while i - shift - 1 &gt;= 0 and i + shift &lt;= len(matrix) - 1 and total &lt;= smudges:
      first_row = matrix[i + shift]
      second_row = matrix[i - shift - 1]
      total += differences(first_row, second_row)
      shift += 1
    if total == smudges:
      return i
  return 0

def compute(matrix, smudges):
  ret = 0
  if smudges:
    ret = column_symmetry(matrix, 1)
    ret += row_symmetry(matrix, 1) * 100
  else:
    ret = column_symmetry(matrix, 0)
    ret += row_symmetry(matrix, 0) * 100
  return ret

def find_mirror(smudges):
  with open('INPUT') as f:
    total = 0
    matrix = []
    for line in f:
      if line.strip() == "":
        total += compute(matrix, smudges)
        matrix = []
      else:
        matrix.append([x for x in line.strip()])
    total += compute(matrix, smudges)
    return total

if __name__ == "__main__":
  print(f"First part: {find_mirror(False)}")
  print(f"Second part: {find_mirror(True)}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-14"><a class="header" href="#advent-of-code---year-2023-day-14">Advent of code - Year 2023 Day 14</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/14">day 14</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-26"><a class="header" href="#information-26">Information</a></h3>
<h4 id="part-1-25"><a class="header" href="#part-1-25">Part 1</a></h4>
<p>In the first part we create a grid of all stones and shift it to one north side and then compute it.</p>
<h4 id="part-2-25"><a class="header" href="#part-2-25">Part 2</a></h4>
<p>In the second part we cycle the shifts counterclockwis and always remember current number of cycle and how the map looked. If we encounter the same situation we take a shortcut by skipping all repeating cycles and only finish the last ones.</p>
<h2 id="mainrs-2"><a class="header" href="#mainrs-2">main.rs</a></h2>
<pre><code class="language-rs">use std::collections::HashMap;
use std::fs;

const NOT_FREE: usize = usize::MAX;

#[derive(PartialEq)]
enum Side {
    North,
    South,
    West,
    East,
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Vec&lt;char&gt;&gt; {
    let contents = fs::read_to_string(filepath);
    let mut matrix: Vec&lt;Vec&lt;char&gt;&gt; = vec![];
    let mut line: Vec&lt;char&gt; = vec![];
    for c in contents.expect("REASON").chars() {
        if c != '\n' {
            line.push(c);
        } else {
            matrix.push(line.clone());
            line.clear();
        }
    }
    return matrix;
}

fn compute_position(
    row: usize,
    column: usize,
    by_row: bool,
    reverse: bool,
    shift: usize,
) -&gt; (usize, usize, bool) {
    if by_row {
        if !reverse {
            return (row + shift, column, false);
        } else {
            return (row - shift, column, row - shift == 0);
        }
    }
    if !reverse {
        return (row, column + shift, false);
    } else {
        return (row, column - shift, column - shift == 0);
    }
}

fn shift_array(
    matrix: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;,
    row_start: usize,
    column_start: usize,
    by_row: bool,
    reverse: bool,
) {
    let mut shift: usize = 0;
    let mut free: usize = NOT_FREE;
    let (mut row, mut column, mut last) =
        compute_position(row_start, column_start, by_row, reverse, shift);
    while row &lt; matrix.len() &amp;&amp; column &lt; matrix[row].len() {
        if matrix[row][column] == '.' &amp;&amp; free == NOT_FREE {
            if by_row {
                free = row;
            } else {
                free = column;
            }
        } else if matrix[row][column] == '#' {
            free = NOT_FREE;
        } else if matrix[row][column] == 'O' &amp;&amp; free != NOT_FREE {
            if by_row {
                matrix[free][column] = 'O';
                matrix[row][column] = '.';
            } else {
                matrix[row][free] = 'O';
                matrix[row][column] = '.';
            }
            if reverse {
                free = free - 1;
            } else {
                free = free + 1;
            }
        }
        shift += 1;
        if last {
            return;
        }
        (row, column, last) = compute_position(row_start, column_start, by_row, reverse, shift);
    }
}

fn shift_side(matrix: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;, side: Side) {
    match side {
        Side::North =&gt; {
            for i in 0..matrix[0].len() {
                shift_array(matrix, 0, i, true, false);
            }
        }
        Side::South =&gt; {
            for i in 0..matrix[0].len() {
                shift_array(matrix, matrix.len() - 1, i, true, true);
            }
        }
        Side::East =&gt; {
            for i in 0..matrix[0].len() {
                shift_array(matrix, i, matrix[i].len() - 1, false, true);
            }
        }
        Side::West =&gt; {
            for i in 0..matrix[0].len() {
                shift_array(matrix, i, 0, false, false);
            }
        }
    }
}

fn cycle(matrix: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;) {
    shift_side(matrix, Side::North);
    shift_side(matrix, Side::West);
    shift_side(matrix, Side::South);
    shift_side(matrix, Side::East);
}

fn compute(matrix: &amp;Vec&lt;Vec&lt;char&gt;&gt;) -&gt; usize {
    let size: usize = matrix.len();
    let mut ret: usize = 0;
    for i in 0..size {
        for j in 0..matrix[i].len() {
            if matrix[i][j] == 'O' {
                ret += size;
                ret -= i
            }
        }
    }
    return ret;
}

fn insert_to_history(
    matrix: &amp;Vec&lt;Vec&lt;char&gt;&gt;,
    history: &amp;mut HashMap&lt;String, i64&gt;,
    cycle: i64,
) -&gt; i64 {
    let mut key: String = String::from("");
    for i in 0..matrix.len() {
        for j in 0..matrix[i].len() {
            key.push(matrix[i][j]);
        }
    }
    if history.contains_key(&amp;key) {
        return history[&amp;key];
    }
    history.insert(key, cycle);
    return -1;
}

fn part1() {
    let mut matrix = read_file("INPUT");
    shift_side(&amp;mut matrix, Side::North);
    println!("Part 1: {}", compute(&amp;matrix));
}

fn part2() {
    let mut matrix = read_file("INPUT");
    let mut history: HashMap&lt;String, i64&gt; = HashMap::new();
    let cycles: i64 = 1_000_000_000;
    for i in 0..cycles {
        cycle(&amp;mut matrix);
        let rep: i64 = insert_to_history(&amp;matrix, &amp;mut history, i);
        if rep != -1 {
            let m: i64 = (1_000_000_000 - rep) % (i - rep) - 1;
            for _ in 0..m {
                cycle(&amp;mut matrix);
            }
            println!("Part 2: {}", compute(&amp;matrix));
            return;
        }
    }
    println!("Part 2: {}", compute(&amp;matrix));
}

fn main() {
    println!("Year 2023 day 14 - Parabolic Reflector Dish");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-15"><a class="header" href="#advent-of-code---year-2023-day-15">Advent of code - Year 2023 Day 15</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/15">day 15</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-27"><a class="header" href="#information-27">Information</a></h3>
<h4 id="part-1-26"><a class="header" href="#part-1-26">Part 1</a></h4>
<p>In the first part we just straightforwardly compute the given acii hash.</p>
<h4 id="part-2-26"><a class="header" href="#part-2-26">Part 2</a></h4>
<p>In the second part we create  <code>hash_map</code> from vector and linked list. Then proceed the given instructions wit hthe ascii hash.</p>
<h2 id="mainrs-3"><a class="header" href="#mainrs-3">main.rs</a></h2>
<pre><code class="language-rs">use std::collections::LinkedList;
use std::fs;

fn read_file(filepath: &amp;str) -&gt; Vec&lt;String&gt; {
    let contents = fs::read_to_string(filepath);
    let mut strings: Vec&lt;String&gt; = vec![];
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    for line in lines {
        let inputs = line.split(',');
        for input in inputs {
            if input != "" {
                strings.push(input.to_string());
            }
        }
    }
    return strings;
}

fn ascii_hash(string: &amp;str) -&gt; i32 {
    let mut hash: i32 = 0;
    for c in string.chars() {
        let ascii = c as i32;
        hash = ((hash + ascii) * 17) % 256;
    }
    return hash;
}

fn insert_to_map(hash_map: &amp;mut Vec&lt;LinkedList&lt;(String, i32)&gt;&gt;, lens: i32, key: &amp;str) {
    let hash = ascii_hash(key) as usize;
    for element in &amp;mut hash_map[hash] {
        if element.0 == key {
            element.1 = lens;
            return;
        }
    }
    hash_map[hash].push_back((key.to_string(), lens));
}

fn remove_from_map(hash_map: &amp;mut Vec&lt;LinkedList&lt;(String, i32)&gt;&gt;, key: &amp;str) {
    let hash = ascii_hash(key) as usize;
    let mut j: usize = 0;
    for element in &amp;mut hash_map[hash] {
        if element.0 == key {
            let mut last = hash_map[hash].split_off(j);
            last.pop_front();
            hash_map[hash].append(&amp;mut last);
            return;
        }
        j += 1;
    }
}

fn init_hash_map(size: i32) -&gt; Vec&lt;LinkedList&lt;(String, i32)&gt;&gt; {
    let mut hash_map: Vec&lt;LinkedList&lt;(String, i32)&gt;&gt; = vec![];
    for _ in 0..size {
        hash_map.push(LinkedList::new());
    }
    return hash_map;
}

fn part1() {
    let strings = read_file("INPUT");
    let mut total = 0;
    for string in strings {
        total += ascii_hash(&amp;string);
    }
    println!("Part 1: {}", total);
}

fn part2() {
    let mut hash_map = init_hash_map(256);
    let strings = read_file("INPUT");
    let mut total = 0;
    for string in strings {
        if string.chars().nth(string.len() - 1) == Some('-') {
            let key = &amp;string[0..string.len() - 1];
            remove_from_map(&amp;mut hash_map, key);
        } else if string.chars().nth(string.len() - 2) == Some('=') {
            let lens = string.chars().nth(string.len() - 1).unwrap() as i32 - '0' as i32;
            let key = &amp;string[0..string.len() - 2];
            insert_to_map(&amp;mut hash_map, lens, key);
        }
    }
    for i in 0..hash_map.len() {
        let mut j = 0;
        for element in &amp;hash_map[i] {
            total += (i + 1) * (j + 1) * (element.1 as usize);
            j += 1;
        }
    }
    println!("Part 2: {}", total);
}

fn main() {
    println!("Year 2023 day 15 - Lens Library");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-16"><a class="header" href="#advent-of-code---year-2023-day-16">Advent of code - Year 2023 Day 16</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/16">day 16</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-28"><a class="header" href="#information-28">Information</a></h3>
<h4 id="part-1-27"><a class="header" href="#part-1-27">Part 1</a></h4>
<p>We simply recursively simulate beam step-by-step. We use hashmap to memorize already visited places in grid with the same directions.</p>
<h4 id="part-2-27"><a class="header" href="#part-2-27">Part 2</a></h4>
<p>We reuse the codebase and run he simulation from every possible place and find the maximum.</p>
<h2 id="mainrs-4"><a class="header" href="#mainrs-4">main.rs</a></h2>
<pre><code class="language-rs">use std::collections::HashMap;
use std::fs;

type Grid&lt;T&gt; = Vec&lt;Vec&lt;T&gt;&gt;;

/** Read the input file and return the matrix and empty visited map. */
fn read_file(filepath: &amp;str) -&gt; (Grid&lt;char&gt;, Grid&lt;bool&gt;) {
    let contents = fs::read_to_string(filepath);
    let mut matrix: Grid&lt;char&gt; = vec![];
    let mut visited: Grid&lt;bool&gt; = vec![];
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    for line in lines {
        let mut matrix_line: Vec&lt;char&gt; = vec![];
        let mut visited_line: Vec&lt;bool&gt; = vec![];
        for c in line.chars() {
            matrix_line.push(c);
            visited_line.push(false);
        }
        matrix.push(matrix_line);
        visited.push(visited_line);
    }
    return (matrix, visited);
}

/** Get the key to the hash function. */
fn get_key(position: (usize, usize), movement: (i32, i32)) -&gt; String {
    let mut key = String::from("");
    key += &amp;position.0.to_string();
    key.push(':');
    key += &amp;position.1.to_string();
    key.push('|');
    key += &amp;movement.0.to_string();
    key.push(':');
    key += &amp;movement.1.to_string();
    return key;
}

/** Move one tile in a matrix. Also check and if it was used do not go there again. */
fn step(
    matrix: &amp;Vec&lt;Vec&lt;char&gt;&gt;,
    visited: &amp;mut Vec&lt;Vec&lt;bool&gt;&gt;,
    position: (usize, usize),
    movement: (i32, i32),
    history: &amp;mut HashMap&lt;String, bool&gt;,
) {
    if position.0 &gt;= matrix.len() || position.1 &gt;= matrix[position.0].len() {
        return;
    }
    let key = get_key(position, movement);
    if history.contains_key(&amp;key) {
        return;
    }
    history.insert(key, true);
    visited[position.0][position.1] = true;
    match matrix[position.0][position.1] {
        '/' =&gt; {
            let new_movement = (-movement.1, -movement.0);
            let new_position = (
                (position.0 as i32 + new_movement.0) as usize,
                (position.1 as i32 + new_movement.1) as usize,
            );
            step(matrix, visited, new_position, new_movement, history);
        }
        '\\' =&gt; {
            let new_movement = (movement.1, movement.0);
            let new_position = (
                (position.0 as i32 + new_movement.0) as usize,
                (position.1 as i32 + new_movement.1) as usize,
            );
            step(matrix, visited, new_position, new_movement, history);
        }
        '|' =&gt; {
            if movement.0 == -1 || movement.0 == 1 {
                let new_position = (
                    (position.0 as i32 + movement.0) as usize,
                    (position.1 as i32 + movement.1) as usize,
                );
                step(matrix, visited, new_position, movement, history);
            } else {
                let mut new_position = ((position.0 as i32 + 1) as usize, position.1);
                step(matrix, visited, new_position, (1, 0), history);
                new_position = ((position.0 as i32 - 1) as usize, position.1);
                step(matrix, visited, new_position, (-1, 0), history);
            }
        }
        '-' =&gt; {
            if movement.1 == -1 || movement.1 == 1 {
                let new_position = (
                    (position.0 as i32 + movement.0) as usize,
                    (position.1 as i32 + movement.1) as usize,
                );
                step(matrix, visited, new_position, movement, history);
            } else {
                let mut new_position = (position.0, (position.1 as i32 + 1) as usize);
                step(matrix, visited, new_position, (0, 1), history);
                new_position = (position.0, (position.1 as i32 - 1) as usize);
                step(matrix, visited, new_position, (0, -1), history);
            }
        }
        '.' =&gt; {
            let new_position = (
                (position.0 as i32 + movement.0) as usize,
                (position.1 as i32 + movement.1) as usize,
            );
            step(matrix, visited, new_position, movement, history);
        }
        _ =&gt; {}
    }
}

/** Count the visited places. */
fn count_visited(visited: &amp;Vec&lt;Vec&lt;bool&gt;&gt;) -&gt; i64 {
    let mut total: i64 = 0;
    for line in visited {
        for c in line {
            if *c {
                total += 1;
            }
        }
    }
    return total;
}

/** Try one possibility. */
fn try_one(
    matrix: &amp;Vec&lt;Vec&lt;char&gt;&gt;,
    visited: &amp;Vec&lt;Vec&lt;bool&gt;&gt;,
    position: (usize, usize),
    movement: (i32, i32),
) -&gt; i64 {
    let mut v = visited.clone();
    let mut h: HashMap&lt;String, bool&gt; = HashMap::new();
    step(&amp;matrix, &amp;mut v, position, movement, &amp;mut h);
    return count_visited(&amp;v);
}

/** Move in the matrix. */
fn part1() {
    let (matrix, mut visited) = read_file("INPUT");
    let mut history: HashMap&lt;String, bool&gt; = HashMap::new();
    step(&amp;matrix, &amp;mut visited, (0, 0), (0, 1), &amp;mut history);
    println!("Part 1: {}", count_visited(&amp;visited));
}

/** Try all posibilitie. */
fn part2() {
    let (matrix, visited) = read_file("INPUT");
    let mut max: i64 = 0;
    for i in 1..matrix.len() - 1 {
        let c = try_one(&amp;matrix, &amp;visited, (i, 0), (0, 1));
        if c &gt; max {
            max = c;
        }
        let c = try_one(&amp;matrix, &amp;visited, (matrix.len() - 1 - i, 0), (0, -1));
        if c &gt; max {
            max = c;
        }
    }
    for i in 1..matrix[0].len() - 1 {
        let c = try_one(&amp;matrix, &amp;visited, (0, i), (1, 0));
        if c &gt; max {
            max = c;
        }
        let c = try_one(&amp;matrix, &amp;visited, (0, matrix.len() - 1 - i), (-1, 0));
        if c &gt; max {
            max = c;
        }
    }
    let c = try_one(&amp;matrix, &amp;visited, (0, 0), (1, 0));
    if c &gt; max {
        max = c;
    }
    let c = try_one(&amp;matrix, &amp;visited, (0, 0), (0, 1));
    if c &gt; max {
        max = c;
    }
    let c = try_one(&amp;matrix, &amp;visited, (matrix.len(), matrix[0].len()), (-1, 0));
    if c &gt; max {
        max = c;
    }
    let c = try_one(&amp;matrix, &amp;visited, (matrix.len(), matrix[0].len()), (0, -1));
    if c &gt; max {
        max = c;
    }
    println!("Part 2: {}", max);
}

fn main() {
    println!("Year 2023 day 16 - The Floor Will Be Lava");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-17"><a class="header" href="#advent-of-code---year-2023-day-17">Advent of code - Year 2023 Day 17</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/17">day 17</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-29"><a class="header" href="#information-29">Information</a></h3>
<h4 id="part-1-28"><a class="header" href="#part-1-28">Part 1</a></h4>
<p>We record every single step by its position, direction, all other possibilities. Then we use heap for the shortest paths and hashmap to record alreeady visited nodes.</p>
<h4 id="part-2-28"><a class="header" href="#part-2-28">Part 2</a></h4>
<p>We also introduce a minimal number of nodes in one direction, then we rewrite the code so it can work for both parts.</p>
<h2 id="mainrs-5"><a class="header" href="#mainrs-5">main.rs</a></h2>
<pre><code class="language-rs">use std::cmp::Reverse;
use std::collections::{BinaryHeap, HashMap};
use std::fs;

type Grid&lt;T&gt; = Vec&lt;Vec&lt;T&gt;&gt;;
type Position = (usize, usize);

fn read_file(filepath: &amp;str) -&gt; Grid&lt;usize&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    let mut grid: Grid&lt;usize&gt; = vec![];
    for line in lines {
        let mut grid_line: Vec&lt;usize&gt; = vec![];
        for c in line.chars() {
            grid_line.push(c.to_digit(10).unwrap() as usize);
        }
        if grid_line.len() &gt; 0 {
            grid.push(grid_line);
        }
    }
    return grid;
}

#[derive(Clone, Copy, Eq, Hash, PartialEq, Ord, PartialOrd)]
enum Direction {
    Up,
    Down,
    Right,
    Left,
}

#[derive(Clone, Copy, Eq, Hash, PartialEq, Ord, PartialOrd)]
struct State {
    position: Position,
    remaining_up: usize,
    remaining_right: usize,
    remaining_down: usize,
    remaining_left: usize,
    direction: Direction,
    moves_in_current_direction: usize,
}

fn get_neighbouring_states(state: State, map: &amp;Grid&lt;usize&gt;, min: usize, max: usize) -&gt; Vec&lt;State&gt; {
    let mut neighbours: Vec&lt;State&gt; = vec![];

    if state.moves_in_current_direction &lt; min {
        match state.direction {
            Direction::Up =&gt; {
                if state.position.0 &gt;= 1 {
                    neighbours.push(State {
                        position: (state.position.0 - 1, state.position.1),
                        remaining_up: state.remaining_up - 1,
                        remaining_right: max,
                        remaining_down: max,
                        remaining_left: max,
                        direction: Direction::Up,
                        moves_in_current_direction: state.moves_in_current_direction + 1,
                    });
                }
                return neighbours;
            }
            Direction::Right =&gt; {
                if state.position.1 &lt; map[0].len() - 1 {
                    neighbours.push(State {
                        position: (state.position.0, state.position.1 + 1),
                        remaining_up: max,
                        remaining_right: state.remaining_right - 1,
                        remaining_down: max,
                        remaining_left: max,
                        direction: Direction::Right,
                        moves_in_current_direction: state.moves_in_current_direction + 1,
                    });
                }
                return neighbours;
            }
            Direction::Down =&gt; {
                if state.position.0 &lt; map.len() - 1 {
                    neighbours.push(State {
                        position: (state.position.0 + 1, state.position.1),
                        remaining_up: max,
                        remaining_right: max,
                        remaining_down: state.remaining_down - 1,
                        remaining_left: max,
                        direction: Direction::Down,
                        moves_in_current_direction: state.moves_in_current_direction + 1,
                    });
                }
                return neighbours;
            }
            Direction::Left =&gt; {
                if state.position.1 &gt;= 1 {
                    neighbours.push(State {
                        position: (state.position.0, state.position.1 - 1),
                        remaining_up: max,
                        remaining_right: max,
                        remaining_down: max,
                        remaining_left: state.remaining_left - 1,
                        direction: Direction::Left,
                        moves_in_current_direction: state.moves_in_current_direction + 1,
                    });
                }
                return neighbours;
            }
        }
    }

    if state.remaining_up &gt;= 1 &amp;&amp; state.position.0 &gt;= 1 &amp;&amp; state.direction != Direction::Down {
        neighbours.push(State {
            position: (state.position.0 - 1, state.position.1),
            remaining_up: state.remaining_up - 1,
            remaining_right: max,
            remaining_down: max,
            remaining_left: max,
            direction: Direction::Up,
            moves_in_current_direction: if state.direction == Direction::Up {
                state.moves_in_current_direction + 1
            } else {
                1
            },
        });
    }

    if state.remaining_right &gt;= 1
        &amp;&amp; state.position.1 &lt; map[0].len() - 1
        &amp;&amp; state.direction != Direction::Left
    {
        neighbours.push(State {
            position: (state.position.0, state.position.1 + 1),
            remaining_up: max,
            remaining_right: state.remaining_right - 1,
            remaining_down: max,
            remaining_left: max,
            direction: Direction::Right,
            moves_in_current_direction: if state.direction == Direction::Right {
                state.moves_in_current_direction + 1
            } else {
                1
            },
        });
    }

    if state.remaining_down &gt;= 1
        &amp;&amp; state.position.0 &lt; map.len() - 1
        &amp;&amp; state.direction != Direction::Up
    {
        neighbours.push(State {
            position: (state.position.0 + 1, state.position.1),
            remaining_up: max,
            remaining_right: max,
            remaining_down: state.remaining_down - 1,
            remaining_left: max,
            direction: Direction::Down,
            moves_in_current_direction: if state.direction == Direction::Down {
                state.moves_in_current_direction + 1
            } else {
                1
            },
        });
    }

    if state.remaining_left &gt;= 1 &amp;&amp; state.position.1 &gt;= 1 &amp;&amp; state.direction != Direction::Right {
        neighbours.push(State {
            position: (state.position.0, state.position.1 - 1),
            remaining_up: max,
            remaining_right: max,
            remaining_down: max,
            remaining_left: state.remaining_left - 1,
            direction: Direction::Left,
            moves_in_current_direction: if state.direction == Direction::Left {
                state.moves_in_current_direction + 1
            } else {
                1
            },
        });
    }

    neighbours
}

fn get_cost(
    map: &amp;Grid&lt;usize&gt;,
    source: Position,
    destination: Position,
    min: usize,
    max: usize,
) -&gt; usize {
    let mut costs: HashMap&lt;State, usize&gt; = HashMap::new();
    let mut heap: BinaryHeap&lt;Reverse&lt;(usize, State)&gt;&gt; = BinaryHeap::new();

    let start_state_right = State {
        position: source,
        remaining_up: max,
        remaining_right: max,
        remaining_down: max,
        remaining_left: max,
        direction: Direction::Right,
        moves_in_current_direction: 0,
    };
    let start_state_down = State {
        position: source,
        remaining_up: max,
        remaining_right: max,
        remaining_down: max,
        remaining_left: max,
        direction: Direction::Down,
        moves_in_current_direction: 0,
    };

    costs.insert(start_state_right, 0);
    costs.insert(start_state_down, 0);
    heap.push(Reverse((0, start_state_right)));
    heap.push(Reverse((0, start_state_down)));

    while let Some(Reverse((curr_cost, curr_state))) = heap.pop() {
        if curr_state.position == destination &amp;&amp; curr_state.moves_in_current_direction &gt;= min {
            return curr_cost;
        }

        if curr_cost &gt; *costs.get(&amp;curr_state).unwrap_or(&amp;usize::MAX) {
            continue;
        }

        let neighbours = get_neighbouring_states(curr_state, map, min, max);

        for neighbour in neighbours {
            let next_pos = neighbour.position;
            let next_cost = curr_cost + map[next_pos.0][next_pos.1];
            if next_cost &lt; *costs.get(&amp;neighbour).unwrap_or(&amp;usize::MAX) {
                heap.push(Reverse((next_cost, neighbour)));
                costs.insert(neighbour, next_cost);
            }
        }
    }
    usize::MAX
}

fn part1() {
    let grid = read_file("INPUT");
    println!(
        "Part 1: {}",
        get_cost(&amp;grid, (0, 0), (grid.len() - 1, grid.len() - 1), 0, 3)
    );
}

fn part2() {
    let grid = read_file("INPUT");
    println!(
        "Part 2: {}",
        get_cost(&amp;grid, (0, 0), (grid.len() - 1, grid.len() - 1), 4, 10)
    );
}

fn main() {
    println!("Year 2023 day 17 - Clumsy Crucible");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-18"><a class="header" href="#advent-of-code---year-2023-day-18">Advent of code - Year 2023 Day 18</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/18">day 18</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-30"><a class="header" href="#information-30">Information</a></h3>
<h4 id="part-1-29"><a class="header" href="#part-1-29">Part 1</a></h4>
<p>We can simply calculate the whole grid. Then create the outline and after that recursively fill in the polygon from a starting node. This solution is actually in here anymore.</p>
<h4 id="part-2-29"><a class="header" href="#part-2-29">Part 2</a></h4>
<p>Again we use <a href="https://en.wikipedia.org/wiki/Pick%27s_theorem">Pick's Theorem</a>. And <a href="https://docs.rs/geo/latest/geo/">geo</a> library to create a polygon from the instruction set and compute the area using the library. Then we procede with the use of the theoem.</p>
<h2 id="mainrs-6"><a class="header" href="#mainrs-6">main.rs</a></h2>
<pre><code class="language-rs">use geo::{coord, Area, Coord, LineString, Polygon};
use std::fs;

type Point&lt;T&gt; = (T, T);
type Instruction = (char, i32);

fn read_file(filepath: &amp;str) -&gt; (Vec&lt;Instruction&gt;, Vec&lt;String&gt;) {
    let mut instructions: Vec&lt;Instruction&gt; = vec![];
    let mut strings: Vec&lt;String&gt; = vec![];
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    for line in lines {
        if line != "" {
            let mut parts = line.split(' ');
            let instruction = (
                parts.next().unwrap().chars().nth(0).unwrap(),
                parts.next().unwrap().parse::&lt;i32&gt;().unwrap(),
            );
            instructions.push(instruction);
            strings.push(parts.next().unwrap().to_string());
        }
    }
    return (instructions, strings);
}

fn step(instruction: &amp;Instruction, point: &amp;Point&lt;i32&gt;) -&gt; Point&lt;i32&gt; {
    match instruction.0 {
        '0' | 'R' =&gt; (point.0, point.1 + instruction.1),
        '1' | 'D' =&gt; (point.0 + instruction.1, point.1),
        '2' | 'L' =&gt; (point.0, point.1 - instruction.1),
        '3' | 'U' =&gt; (point.0 - instruction.1, point.1),
        _ =&gt; (point.0, point.1),
    }
}

fn calculate_area(points: &amp;Vec&lt;Point&lt;i32&gt;&gt;) -&gt; f64 {
    let mut coordinates: Vec&lt;Coord&gt; = vec![];
    for point in points {
        coordinates.push(coord! {x: point.0 as f64, y: point.1 as f64 });
    }
    let line_string = LineString::new(coordinates);
    let polygon = Polygon::new(line_string, Vec::new());
    polygon.unsigned_area()
}

fn compute_from_instructions(instructions: &amp;Vec&lt;Instruction&gt;) -&gt; i64 {
    let mut points: Vec&lt;Point&lt;i32&gt;&gt; = vec![];
    let mut point: Point&lt;i32&gt; = (0, 0);
    let mut b: i64 = 0;
    for instruction in instructions {
        points.push(point);
        point = step(instruction, &amp;mut point);
        b += instruction.1 as i64;
    }
    let area = calculate_area(&amp;points) as i64;
    2 + b + (area - b / 2 - 1)
}

fn parse_string(string: &amp;str) -&gt; Instruction {
    let len: usize = string.len() - 2;
    let hex_string = &amp;string[2..len];
    let num = i32::from_str_radix(&amp;hex_string, 16).unwrap();
    (string.chars().nth(len).unwrap(), num)
}

fn part1() {
    let (instructions, _) = read_file("INPUT");
    println!("Part 1: {}", compute_from_instructions(&amp;instructions));
}

fn part2() {
    let (_, strings) = read_file("INPUT");
    let instructions: Vec&lt;Instruction&gt; = strings
        .into_iter()
        .map(|string| parse_string(&amp;string))
        .collect();
    println!("Part 2: {}", compute_from_instructions(&amp;instructions));
}

fn main() {
    println!("Year 2023 day 18 - Lavaduct Lagoon");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-19"><a class="header" href="#advent-of-code---year-2023-day-19">Advent of code - Year 2023 Day 19</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/19">day 19</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-31"><a class="header" href="#information-31">Information</a></h3>
<p>The main key was to parse properly the given input. That is why the code today is pretty long.</p>
<h4 id="part-1-30"><a class="header" href="#part-1-30">Part 1</a></h4>
<p>After that we just use hash table to memorize given states. Than we process each request from left to right until it is satisfied.</p>
<h4 id="part-2-30"><a class="header" href="#part-2-30">Part 2</a></h4>
<p>In the second part we had to use the same aproach only to compute the intervals not just single numbers. But it is very similiar, since we just split parts on each comparison and recursively called to the next step.</p>
<h2 id="mainrs-7"><a class="header" href="#mainrs-7">main.rs</a></h2>
<pre><code class="language-rs">use std::cmp::{max, min};
use std::collections::HashMap;
use std::fs;

const X: usize = 0;
const M: usize = 1;
const A: usize = 2;
const S: usize = 3;
const INV: usize = 5;

type Part = [i64; 4];

type BoundPart = [(i64, i64); 4];

enum Compare {
    LessThan,
    MoreThan,
    True,
}

struct Rule {
    considering: usize,
    compare: Compare,
    number: i64,
    next_state: String,
    accepting: bool,
    rejecting: bool,
}

type State = Vec&lt;Rule&gt;;

fn get_considering(c: char) -&gt; usize {
    match c {
        'x' =&gt; return X,
        'm' =&gt; return M,
        'a' =&gt; return A,
        's' =&gt; return S,
        _ =&gt; return INV,
    }
}

fn parse_rule(line: &amp;str) -&gt; Rule {
    let splitted = line.split(':');
    let parts: Vec&lt;&amp;str&gt; = splitted.collect();
    if parts.len() == 1 as usize {
        let new_state = parts[0];
        if new_state == "A" {
            return Rule {
                considering: INV,
                compare: Compare::True,
                number: 0,
                next_state: "".to_string(),
                accepting: true,
                rejecting: false,
            };
        } else if new_state == "R" {
            return Rule {
                considering: INV,
                compare: Compare::True,
                number: 0,
                next_state: "".to_string(),
                accepting: false,
                rejecting: true,
            };
        } else {
            return Rule {
                considering: INV,
                compare: Compare::True,
                number: 0,
                next_state: new_state.to_string(),
                accepting: false,
                rejecting: false,
            };
        }
    }
    let binding = parts[0].to_string();
    let considering = get_considering(binding.chars().nth(0).unwrap());
    let compare: Compare;
    match binding.chars().nth(1).unwrap() {
        '&lt;' =&gt; compare = Compare::LessThan,
        '&gt;' =&gt; compare = Compare::MoreThan,
        _ =&gt; compare = Compare::True,
    }
    let number = i64::from_str_radix(&amp;binding[2..], 10).unwrap();
    let new_state = parts[1].to_string();
    if new_state == "A" {
        return Rule {
            considering: considering,
            compare: compare,
            number: number,
            next_state: "".to_string(),
            accepting: true,
            rejecting: false,
        };
    } else if new_state == "R" {
        return Rule {
            considering: considering,
            compare: compare,
            number: number,
            next_state: "".to_string(),
            accepting: false,
            rejecting: true,
        };
    } else {
        return Rule {
            considering: considering,
            compare: compare,
            number: number,
            next_state: new_state,
            accepting: false,
            rejecting: false,
        };
    }
}

fn parse_state(line: &amp;str) -&gt; (String, State) {
    let mut parts = line.split('{');
    let string = parts.next().unwrap().to_string();
    let mut rules: Vec&lt;Rule&gt; = vec![];
    let binding = parts.next().unwrap().to_string();
    let rule = &amp;binding[0..binding.len() - 1];
    for r in rule.split(',') {
        rules.push(parse_rule(r));
    }
    (string, rules)
}

fn parse_part(line: &amp;str) -&gt; Part {
    let interior = &amp;line[1..line.len() - 1];
    let values: Vec&lt;&amp;str&gt; = interior.split(',').collect();
    let mut part: Part = [0; 4];
    for val in values {
        match val.chars().nth(0).unwrap() {
            'x' =&gt; part[X] = i64::from_str_radix(&amp;val[2..], 10).unwrap(),
            'm' =&gt; part[M] = i64::from_str_radix(&amp;val[2..], 10).unwrap(),
            'a' =&gt; part[A] = i64::from_str_radix(&amp;val[2..], 10).unwrap(),
            's' =&gt; part[S] = i64::from_str_radix(&amp;val[2..], 10).unwrap(),
            _ =&gt; todo!(),
        }
    }
    part
}

fn read_file(filepath: &amp;str) -&gt; (HashMap&lt;String, State&gt;, Vec&lt;Part&gt;) {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    let mut parts: Vec&lt;Part&gt; = vec![];
    let mut hash_map: HashMap&lt;String, State&gt; = HashMap::new();
    let mut first_part: bool = true;
    for line in lines {
        if line == "" {
            first_part = false;
        } else if first_part {
            let (string, state) = parse_state(&amp;line);
            hash_map.insert(string, state);
        } else {
            parts.push(parse_part(line));
        }
    }
    (hash_map, parts)
}

fn process_part(hash_map: &amp;HashMap&lt;String, State&gt;, part: Part) -&gt; i64 {
    let mut string = "in";
    let ret: i64 = part[X] + part[M] + part[A] + part[S];
    loop {
        let state = &amp;hash_map[string];
        for rule in state {
            match rule.compare {
                Compare::LessThan =&gt; {
                    if part[rule.considering] &lt; rule.number {
                        if rule.accepting {
                            return ret;
                        } else if rule.rejecting {
                            return 0;
                        }
                        string = &amp;rule.next_state;
                        break;
                    }
                }
                Compare::MoreThan =&gt; {
                    if part[rule.considering] &gt; rule.number {
                        if rule.accepting {
                            return ret;
                        } else if rule.rejecting {
                            return 0;
                        }
                        string = &amp;rule.next_state;
                        break;
                    }
                }
                Compare::True =&gt; {
                    if rule.accepting {
                        return ret;
                    } else if rule.rejecting {
                        return 0;
                    }
                    string = &amp;rule.next_state;
                    break;
                }
            }
        }
    }
}

fn check_bound(bound: (i64, i64)) -&gt; bool {
    bound.1 &gt; bound.0
}

fn count_possibilites(bounds: &amp;BoundPart) -&gt; i64 {
    let res = (bounds[X].1 - bounds[X].0)
        * (bounds[M].1 - bounds[M].0)
        * (bounds[A].1 - bounds[A].0)
        * (bounds[S].1 - bounds[S].0);
    res
}

fn process_bounds(hash_map: &amp;HashMap&lt;String, State&gt;, bounds: &amp;mut BoundPart, string: &amp;str) -&gt; i64 {
    let mut total: i64 = 0;
    let state = &amp;hash_map[string];
    for rule in state {
        match rule.compare {
            Compare::LessThan =&gt; {
                let part1 = (bounds[rule.considering].0, rule.number);
                let mut new_bounds = [bounds[X], bounds[M], bounds[A], bounds[S]];
                bounds[rule.considering] = (
                    max(rule.number, bounds[rule.considering].0),
                    bounds[rule.considering].1,
                );
                new_bounds[rule.considering] = part1;
                if check_bound(part1) {
                    if rule.accepting {
                        total += count_possibilites(&amp;new_bounds);
                    } else if rule.rejecting {
                        total += 0;
                    } else {
                        total += process_bounds(hash_map, &amp;mut new_bounds, &amp;rule.next_state);
                    }
                }
            }
            Compare::MoreThan =&gt; {
                let part1 = (rule.number + 1, bounds[rule.considering].1);
                let mut new_bounds = [bounds[X], bounds[M], bounds[A], bounds[S]];
                bounds[rule.considering] = (
                    bounds[rule.considering].0,
                    min(rule.number + 1, bounds[rule.considering].1),
                );
                new_bounds[rule.considering] = part1;
                if check_bound(part1) {
                    if rule.accepting {
                        total += count_possibilites(&amp;new_bounds);
                    } else if rule.rejecting {
                        total += 0;
                    } else {
                        total += process_bounds(hash_map, &amp;mut new_bounds, &amp;rule.next_state);
                    }
                }
            }
            Compare::True =&gt; {
                let mut new_bounds = [bounds[X], bounds[M], bounds[A], bounds[S]];
                if rule.accepting {
                    total += count_possibilites(&amp;bounds);
                } else if rule.rejecting {
                    total += 0;
                } else {
                    total += process_bounds(hash_map, &amp;mut new_bounds, &amp;rule.next_state);
                }
            }
        }
    }
    total
}

fn part1() {
    let (hash_map, parts) = read_file("INPUT");
    let results: Vec&lt;i64&gt; = parts
        .into_iter()
        .map(|p| process_part(&amp;hash_map, p))
        .collect();
    println!("Part 1: {}", results.iter().sum::&lt;i64&gt;());
}

fn part2() {
    let (hash_map, _) = read_file("INPUT");
    let mut part: BoundPart = [(1, 4001); 4];
    println!("Part 2: {}", process_bounds(&amp;hash_map, &amp;mut part, "in"));
}

fn main() {
    println!("Year 2023 day 19 - Aplenty");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-20"><a class="header" href="#advent-of-code---year-2023-day-20">Advent of code - Year 2023 Day 20</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/20">day 20</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-32"><a class="header" href="#information-32">Information</a></h3>
<h4 id="part-1-31"><a class="header" href="#part-1-31">Part 1</a></h4>
<p>In the first part you run the bfs to firstly find predecessors. Then you have the whole graph represented. After you run once again bfs with some different cases for the logic to work.</p>
<h4 id="part-2-31"><a class="header" href="#part-2-31">Part 2</a></h4>
<p>The second part is easier to solve by hand. You may create a <code>graph.dot</code> in <a href="https://graphviz.org/doc/info/lang.html">graphviz dot language</a> and then by running <code>dot -Kdot -Tsvg graph.dot -o graph.svg</code> create a picture of the graph. There are 4 modules that behave like a binary counters. For each you represent it by a binary number; 1 if the edge goes to the conjection and 0 otherwise. After you represent it you use LCM for them and that is the answer.</p>
<h2 id="mainrs-8"><a class="header" href="#mainrs-8">main.rs</a></h2>
<pre><code class="language-rs">use std::collections::{HashMap, HashSet, VecDeque};
use std::fs;
use std::io::Write;

const BROADCASTER: &amp;str = "broadcaster";
const RX: &amp;str = "rx";

#[derive(Debug, Eq, PartialEq, Clone)]
enum NodeType {
    FlipFlop,
    Conjuction,
    Broadcast,
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum Pulse {
    Low,
    High,
}

#[derive(Debug, Clone)]
struct Node {
    name: String,
    node_type: NodeType,
    on: bool,
    next_nodes: Vec&lt;String&gt;,
    predecessors: HashMap&lt;String, Pulse&gt;,
}

fn parse_node(line: &amp;str) -&gt; Node {
    let parts: Vec&lt;&amp;str&gt; = line.split(" -&gt; ").collect();
    let node_type: NodeType;
    match parts[0].chars().nth(0).unwrap() {
        '%' =&gt; node_type = NodeType::FlipFlop,
        '&amp;' =&gt; node_type = NodeType::Conjuction,
        _ =&gt; node_type = NodeType::Broadcast,
    }
    let name: String;
    if node_type != NodeType::Broadcast {
        name = parts[0][1..].to_string();
    } else {
        name = parts[0].to_string();
    }
    let next_nodes: Vec&lt;String&gt; = parts[1].split(", ").map(|n| n.to_string()).collect();
    Node {
        name: name,
        node_type: node_type,
        on: false,
        next_nodes: next_nodes,
        predecessors: HashMap::new(),
    }
}

fn read_file(filepath: &amp;str) -&gt; HashMap&lt;String, Node&gt; {
    let mut hash_map: HashMap&lt;String, Node&gt; = HashMap::new();
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    for line in lines {
        if line != "" {
            let node = parse_node(line);
            let name = &amp;node.name;
            hash_map.insert(name.to_string(), node);
        }
    }
    hash_map.insert(
        RX.to_string(),
        Node {
            name: RX.to_string(),
            node_type: NodeType::Broadcast,
            on: false,
            next_nodes: vec![],
            predecessors: HashMap::new(),
        },
    );
    return hash_map;
}

fn find_predecessors(hash_map: &amp;mut HashMap&lt;String, Node&gt;) {
    let mut name = BROADCASTER.to_string();
    let mut set: HashSet&lt;String&gt; = HashSet::new();
    let mut queue: VecDeque&lt;String&gt; = VecDeque::new();
    queue.push_back(name.clone());
    while !queue.is_empty() {
        name = queue.pop_front().unwrap().to_string();
        if set.contains(&amp;name) {
            continue;
        }
        set.insert(name.clone());
        let next_nodes = &amp;hash_map[&amp;name].next_nodes.clone();
        for n in next_nodes {
            if let Some(new_node) = hash_map.get_mut(n) {
                new_node.predecessors.insert(name.clone(), Pulse::Low);
                queue.push_back(n.clone());
            }
        }
    }
}

fn create_graphviz(hash_map: &amp;HashMap&lt;String, Node&gt;, filepath: &amp;str) {
    let file = fs::File::create(filepath);
    match writeln!(file.as_ref().expect("REASON"), "{}", "digraph AOC {") {
        Ok(()) =&gt; {}
        Err(..) =&gt; return,
    }
    for n in hash_map {
        let mut color: &amp;str;
        match n.1.node_type {
            NodeType::Broadcast =&gt; color = "red",
            NodeType::Conjuction =&gt; color = "blue",
            NodeType::FlipFlop =&gt; color = "green",
        }
        if n.1.name == RX {
            color = "orange";
        }
        match writeln!(
            file.as_ref().expect("REASON"),
            "{}",
            format!("  {} [color={}]", n.1.name, color)
        ) {
            Ok(()) =&gt; {}
            Err(..) =&gt; return,
        }
    }
    let mut name = BROADCASTER.to_string();
    let mut set: HashSet&lt;String&gt; = HashSet::new();
    let mut queue: VecDeque&lt;String&gt; = VecDeque::new();
    queue.push_back(name.clone());
    while !queue.is_empty() {
        name = queue.pop_front().unwrap().to_string();
        if set.contains(&amp;name) {
            continue;
        }
        set.insert(name.clone());
        let next_nodes = &amp;hash_map[&amp;name].next_nodes.clone();
        for n in next_nodes {
            match writeln!(
                file.as_ref().expect("REASON"),
                "{}",
                format!("  {} -&gt; {};", name, n)
            ) {
                Ok(()) =&gt; {}
                Err(..) =&gt; return,
            }
            queue.push_back(n.clone());
        }
    }
    match writeln!(file.as_ref().expect("REASON"), "{}", "}") {
        Ok(()) =&gt; {}
        Err(..) =&gt; return,
    }
}

fn all_highs(hash_map: &amp;HashMap&lt;String, Pulse&gt;) -&gt; bool {
    hash_map
        .into_iter()
        .map(|x| x.1 == &amp;Pulse::High)
        .fold(true, |acc, x| acc &amp;&amp; x)
}

fn bfs(hash_map: &amp;mut HashMap&lt;String, Node&gt;) -&gt; (i64, i64) {
    let mut lows: i64 = 1;
    let mut highs: i64 = 0;
    let mut name = BROADCASTER.to_string();
    let mut pulse: Pulse = Pulse::Low;
    let mut queue: VecDeque&lt;(String, Pulse)&gt; = VecDeque::new();
    queue.push_back((name.clone(), pulse));
    while !queue.is_empty() {
        (name, pulse) = queue.pop_front().unwrap();
        let next_nodes = &amp;hash_map[&amp;name].next_nodes.clone();
        match &amp;hash_map[&amp;name].node_type {
            NodeType::FlipFlop =&gt; {
                if pulse == Pulse::Low {
                    hash_map.get_mut(&amp;name).unwrap().on = !&amp;hash_map[&amp;name].on;
                    if hash_map[&amp;name].on {
                        pulse = Pulse::High;
                    } else {
                        pulse = Pulse::Low;
                    }
                } else {
                    continue;
                }
            }
            NodeType::Conjuction =&gt; {
                if all_highs(&amp;hash_map[&amp;name].predecessors) {
                    pulse = Pulse::Low;
                } else {
                    pulse = Pulse::High;
                }
            }
            NodeType::Broadcast =&gt; pulse = pulse,
        }
        if pulse == Pulse::High {
            highs += next_nodes.len() as i64;
        } else {
            lows += next_nodes.len() as i64;
        }
        for n in next_nodes {
            if let Some(new_node) = hash_map.get_mut(n) {
                new_node.predecessors.insert(name.clone(), pulse.clone());
                queue.push_back((n.clone(), pulse.clone()));
            }
        }
    }
    (lows, highs)
}

fn gcd(mut a: u64, mut b: u64) -&gt; u64 {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a
}

fn lcm(a: u64, b: u64) -&gt; u64 {
    (a * b) / gcd(a, b)
}

fn lcm_vec(vec: &amp;Vec&lt;u64&gt;) -&gt; u64 {
    vec.into_iter().fold(1, |acc, x| lcm(*x, acc))
}

fn part1() {
    let mut hash_map = read_file("INPUT");
    find_predecessors(&amp;mut hash_map);
    let mut total_lows: i64 = 0;
    let mut total_highs: i64 = 0;
    for _ in 0..1000 {
        let (low, high) = bfs(&amp;mut hash_map);
        total_lows += low;
        total_highs += high;
    }
    println!("Part 1: {}", total_lows * total_highs);
}

fn part2() {
    let hash_map = read_file("INPUT");
    create_graphviz(&amp;hash_map, "graph.dot");
    // This is actually only my result.
    let vec: Vec&lt;u64&gt; = [
        0b111111010011,
        0b111100000111,
        0b111100100101,
        0b111011010101,
    ]
    .to_vec();
    println!("This is just my solution, yours can be found by looking at the graph in graph.dot.");
    println!("Try running: dot -Kdot -Tsvg graph.dot -o graph.svg to see the graph.");
    println!("Simply create binary numbers for each module; 1 if it goes in and 0 otherwise.");
    println!("Part 2: {}", lcm_vec(&amp;vec));
}

fn main() {
    println!("Year 2023 day 20 - Pulse Propagation");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-21"><a class="header" href="#advent-of-code---year-2023-day-21">Advent of code - Year 2023 Day 21</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/21">day 21</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-33"><a class="header" href="#information-33">Information</a></h3>
<h4 id="part-1-32"><a class="header" href="#part-1-32">Part 1</a></h4>
<p>For the first part we have more options.</p>
<ol>
<li>Completely brute force it. It is just <code>64</code> steps. <strong>:D</strong></li>
<li>Remember two sets: Odd visited and even visited. Then see the number of even visited with the limit <code>64</code>.</li>
<li>Use <code>bfs</code> algorithm to compute distances to every place. Then just filter out these that were visited in an even steep and is under the limit of <code>64</code>.</li>
</ol>
<h4 id="part-2-32"><a class="header" href="#part-2-32">Part 2</a></h4>
<p>The second part uses the implemented <code>bfs</code>. We are not able to compute it for all <code>26501365</code> steps. But there is some quite nice math behind the input. Firstly it is a square and there is a straight line from the middle to each side. Every neighbouring blocks switch <strong>even</strong>/<strong>odd</strong> parity. And lastly we campute the corners.</p>
<p>This is just simplified steps of the computation. I actually didn't come up with that on my own, but one can see it make sense due to the nice input. By which we can have some assumptions.</p>
<h2 id="mainrs-9"><a class="header" href="#mainrs-9">main.rs</a></h2>
<pre><code class="language-rs">use std::collections::{HashSet, VecDeque};
use std::fs;

type Grid&lt;T&gt; = Vec&lt;Vec&lt;T&gt;&gt;;
type Position = (usize, usize);

const ROCK: i64 = -3;
const EMPTY: i64 = -1;

fn read_file(filepath: &amp;str) -&gt; (Grid&lt;bool&gt;, Position) {
    let contents = fs::read_to_string(filepath);
    let mut garden: Grid&lt;bool&gt; = vec![];
    let mut start: Position = (0, 0);
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    let mut i: usize = 0;
    for line in lines {
        let mut garden_line: Vec&lt;bool&gt; = vec![];
        let mut j: usize = 0;
        for c in line.chars() {
            garden_line.push(c != '#');
            if c == 'S' {
                start = (i, j);
            }
            j += 1;
        }
        if garden_line.len() &gt; 0 {
            garden.push(garden_line);
        }
        i += 1;
    }
    (garden, start)
}

fn add(a: usize, b: i8) -&gt; usize {
    (a as i64 + b as i64) as usize
}

fn bfs(garden: &amp;Grid&lt;bool&gt;, position: Position) -&gt; Grid&lt;i64&gt; {
    let mut distances: Grid&lt;i64&gt; = vec![];
    for g in garden {
        distances.push(vec![EMPTY; g.len()])
    }

    let mut visited: HashSet&lt;Position&gt; = HashSet::new();
    visited.insert(position);
    let neighbors: [(i8, i8); 4] = [(1, 0), (-1, 0), (0, 1), (0, -1)];
    let mut queue: VecDeque&lt;(Position, i64)&gt; = VecDeque::new();
    queue.push_back((position, 0));

    while !queue.is_empty() {
        let (pos, counter) = queue.pop_front().unwrap();
        if !garden[pos.0][pos.1] {
            distances[pos.0][pos.1] = ROCK;
            continue;
        } else {
            distances[pos.0][pos.1] = counter;
        }
        for n in neighbors {
            let new_pos = (add(pos.0, n.0), add(pos.1, n.1));
            if new_pos.0 &gt;= garden.len() || new_pos.1 &gt;= garden[new_pos.0].len() {
                continue;
            }
            if !visited.contains(&amp;new_pos) {
                queue.push_back((new_pos, counter + 1));
                visited.insert(new_pos);
            }
        }
    }
    distances
}

fn part1() {
    let (garden, start) = read_file("INPUT");
    let dist = bfs(&amp;garden, start);
    let limit: i64 = 64;
    let total = dist
        .into_iter()
        .map(|vec| {
            vec.into_iter()
                .filter(|x| x % 2 == 0 &amp;&amp; x != &amp;ROCK &amp;&amp; x &lt;= &amp;limit)
                .count()
        })
        .fold(0, |acc, sum| acc + sum);
    println!("Part 1: {}", total);
}

fn part2() {
    let (garden, start) = read_file("INPUT");
    let dist = bfs(&amp;garden, start);
    let magical_const: usize = 26501365;
    let n: usize = magical_const / garden.len();
    let limit: i64 = magical_const as i64 % garden.len() as i64;
    let full_even = dist
        .clone()
        .into_iter()
        .map(|vec| vec.into_iter().filter(|x| x % 2 == 0 &amp;&amp; x != &amp;ROCK).count())
        .fold(0, |acc, sum| acc + sum);
    let full_odd = dist
        .clone()
        .into_iter()
        .map(|vec| vec.into_iter().filter(|x| x % 2 == 1 &amp;&amp; x != &amp;ROCK).count())
        .fold(0, |acc, sum| acc + sum);
    let corner_odd = dist
        .clone()
        .into_iter()
        .map(|vec| {
            vec.into_iter()
                .filter(|x| x % 2 == 1 &amp;&amp; x != &amp;ROCK &amp;&amp; x &gt; &amp;limit)
                .count()
        })
        .fold(0, |acc, sum| acc + sum);
    let corner_even = dist
        .clone()
        .into_iter()
        .map(|vec| {
            vec.into_iter()
                .filter(|x| x % 2 == 0 &amp;&amp; x != &amp;ROCK &amp;&amp; x &gt; &amp;limit)
                .count()
        })
        .fold(0, |acc, sum| acc + sum);

    let total =
        (n + 1) * (n + 1) * full_odd + n * n * full_even - (n + 1) * corner_odd + n * corner_even;
    println!("Part 2: {}", total);
}

fn main() {
    println!("Year 2023 day 21 - Step Counter");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-22"><a class="header" href="#advent-of-code---year-2023-day-22">Advent of code - Year 2023 Day 22</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/22">day 22</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-34"><a class="header" href="#information-34">Information</a></h3>
<h4 id="part-1-33"><a class="header" href="#part-1-33">Part 1</a></h4>
<p>In the first part we parse the input than sort the bricks by their <code>z</code> value. After that we simply squish the bricks together (or <code>compress</code> them) so they won't  levitate anymore. After that we compute how they are dependent on each other, or in other words how they <strong>support</strong> each other. Lastly we compute these that follows the rules and left out the others.</p>
<h4 id="part-2-33"><a class="header" href="#part-2-33">Part 2</a></h4>
<p>We use the already written code to construct such bricks. After that we look on every brick and remove it. Then see if any bricks that were supported by this will fall (so the <strong>interection</strong> with the <code>supported_by</code> contains all of them. Then we follow on these bricks until they stay in place.</p>
<h2 id="mainrs-10"><a class="header" href="#mainrs-10">main.rs</a></h2>
<pre><code class="language-rs">use std::collections::{HashMap, HashSet, VecDeque};
use std::fs;

struct Brick {
    x: (i64, i64),
    y: (i64, i64),
    z: (i64, i64),
    supports: HashSet&lt;usize&gt;,
    supported_by: HashSet&lt;usize&gt;,
}

fn parse_numbers(line: &amp;str) -&gt; (i64, i64, i64) {
    let parts: Vec&lt;&amp;str&gt; = line.split(',').into_iter().collect();
    (
        i64::from_str_radix(&amp;parts[0], 10).unwrap(),
        i64::from_str_radix(&amp;parts[1], 10).unwrap(),
        i64::from_str_radix(&amp;parts[2], 10).unwrap(),
    )
}

fn parse_brick(line: &amp;str) -&gt; Brick {
    let parts: Vec&lt;&amp;str&gt; = line.split('~').into_iter().collect();
    let (x1, y1, z1) = parse_numbers(parts[0]);
    let (x2, y2, z2) = parse_numbers(parts[1]);
    Brick {
        x: (x1, x2),
        y: (y1, y2),
        z: (z1, z2),
        supported_by: HashSet::new(),
        supports: HashSet::new(),
    }
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Brick&gt; {
    let contents = fs::read_to_string(filepath);
    let mut bricks: Vec&lt;Brick&gt; = vec![];
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    for line in lines {
        if line != "" {
            bricks.push(parse_brick(line));
        }
    }
    bricks
}

fn overlap(b1: &amp;Brick, b2: &amp;Brick) -&gt; bool {
    b1.x.0 &lt;= b2.x.1 &amp;&amp; b1.x.1 &gt;= b2.x.0 &amp;&amp; b1.y.0 &lt;= b2.y.1 &amp;&amp; b1.y.1 &gt;= b2.y.0
}

fn compress_bricks(bricks: &amp;mut Vec&lt;Brick&gt;) {
    for i in 0..bricks.len() {
        let mut max: i64 = 0;
        for j in 0..i {
            if bricks[j].z.1 &gt; max &amp;&amp; overlap(&amp;bricks[i], &amp;bricks[j]) {
                max = bricks[j].z.1;
            }
        }
        max += 1;
        bricks[i].z.1 = bricks[i].z.1 - bricks[i].z.0 + max;
        bricks[i].z.0 = max;
    }
}

fn create_supports(bricks: &amp;mut Vec&lt;Brick&gt;) {
    for i in 0..bricks.len() {
        for j in 0..bricks.len() {
            if bricks[j].z.1 == bricks[i].z.0 - 1 &amp;&amp; overlap(&amp;bricks[i], &amp;bricks[j]) {
                bricks[i].supported_by.insert(j);
            }
            if bricks[i].z.1 + 1 == bricks[j].z.0 &amp;&amp; overlap(&amp;bricks[i], &amp;bricks[j]) {
                bricks[i].supports.insert(j);
            }
        }
    }
}

fn count_overlaps(bricks: &amp;mut Vec&lt;Brick&gt;) -&gt; usize {
    let mut hash_map: HashMap&lt;usize, bool&gt; = HashMap::new();
    for i in 0..bricks.len() {
        if bricks[i].supported_by.len() &gt; 1 {
            for s in &amp;bricks[i].supported_by {
                if !hash_map.contains_key(s) {
                    hash_map.insert(*s, true);
                }
            }
        } else {
            for s in &amp;bricks[i].supported_by {
                hash_map.insert(*s, false);
            }
        }
        if bricks[i].supports.len() == 0 {
            if !hash_map.contains_key(&amp;i) {
                hash_map.insert(i, true);
            }
        }
    }
    hash_map.into_iter().filter(|a| a.1).count()
}

fn count_disintegration(bricks: &amp;Vec&lt;Brick&gt;) -&gt; usize {
    let mut total: usize = 0;
    for i in 0..bricks.len() {
        let mut set: HashSet&lt;usize&gt; = HashSet::new();
        let mut queue: VecDeque&lt;usize&gt; = VecDeque::new();
        set.insert(i);
        queue.push_back(i);
        while !queue.is_empty() {
            let brick = queue.pop_front().unwrap();
            for b in &amp;bricks[brick].supports {
                if set.intersection(&amp;bricks[*b].supported_by).count()
                    == bricks[*b].supported_by.len()
                {
                    if !set.contains(b) {
                        queue.push_back(*b);
                        set.insert(*b);
                    }
                }
            }
        }
        total += set.len() - 1;
    }
    total
}

fn part1() {
    let mut bricks = read_file("INPUT");
    bricks.sort_by(|a, b| a.z.cmp(&amp;b.z));
    compress_bricks(&amp;mut bricks);
    create_supports(&amp;mut bricks);
    println!("Part 1: {}", count_overlaps(&amp;mut bricks));
}

fn part2() {
    let mut bricks = read_file("INPUT");
    bricks.sort_by(|a, b| a.z.cmp(&amp;b.z));
    compress_bricks(&amp;mut bricks);
    create_supports(&amp;mut bricks);
    println!("Part 2: {}", count_disintegration(&amp;bricks));
}

fn main() {
    println!("Year 2023 day 22 - Sand Slabs");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-23"><a class="header" href="#advent-of-code---year-2023-day-23">Advent of code - Year 2023 Day 23</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/23">day 23</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-35"><a class="header" href="#information-35">Information</a></h3>
<h4 id="part-1-34"><a class="header" href="#part-1-34">Part 1</a></h4>
<p>First part is pretty simple and fast. We just recursively go through the map and follow the slopes. We are trying every possibility and then find the maximum.</p>
<h4 id="part-2-34"><a class="header" href="#part-2-34">Part 2</a></h4>
<p>For the second part they are at least two approaches.</p>
<ol>
<li>Use the same code just ignore the slopes and try every possibilty. As one may see this is not quite the best way to do it. But as it turns out you will wait way less than an hour, so it si doable.</li>
<li>The second more complex way is to actually compress each path and create a simplified graph. Then again try every possibility. it will still take probably some time, but there is less vertices and edges to consider.</li>
</ol>
<p>In my code I just used the brute force, because after a lunch the result was already processed.</p>
<h2 id="mainrs-11"><a class="header" href="#mainrs-11">main.rs</a></h2>
<pre><code class="language-rs">use std::collections::HashSet;
use std::fs;

const EMPTY: char = '.';
const NON_EMPTY: char = '#';

type Grid&lt;T&gt; = Vec&lt;Vec&lt;T&gt;&gt;;
type Position = (usize, usize);

fn read_file(filepath: &amp;str) -&gt; Grid&lt;char&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    let mut map: Grid&lt;char&gt; = vec![];
    for line in lines {
        let map_line: Vec&lt;char&gt; = line.chars().collect();
        if map_line.len() &gt; 0 {
            map.push(map_line);
        }
    }
    map
}

fn find_start_end(map: &amp;Grid&lt;char&gt;) -&gt; (Position, Position) {
    let mut start: Position = (0, 0);
    let mut end: Position = (0, 0);
    for i in 0..map[0].len() {
        if map[0][i] == EMPTY {
            start = (0, i);
            break;
        }
    }
    for i in 0..map[map.len() - 1].len() {
        if map[map.len() - 1][i] == EMPTY {
            end = (map.len() - 1, i);
            break;
        }
    }
    (start, end)
}

fn add(a: Position, b: (i8, i8)) -&gt; Position {
    (
        (a.0 as i64 + b.0 as i64) as usize,
        (a.1 as i64 + b.1 as i64) as usize,
    )
}

fn step(map: &amp;Grid&lt;char&gt;, position: Position, ignore_slopes: bool) -&gt; Vec&lt;Position&gt; {
    let mut positions: Vec&lt;Position&gt; = vec![];
    const LEN: usize = 4;
    let neighbors: [(i8, i8); LEN] = [(0, -1), (0, 1), (1, 0), (-1, 0)];
    let slopes: [char; LEN] = ['&lt;', '&gt;', 'v', '^'];
    for i in 0..LEN {
        let pos: Position = add(position, neighbors[i]);
        if pos.0 &lt; map.len() &amp;&amp; pos.1 &lt; map[pos.0].len() {
            if ignore_slopes &amp;&amp; map[pos.0][pos.1] != NON_EMPTY {
                positions.push(pos);
            } else if !ignore_slopes
                &amp;&amp; (map[pos.0][pos.1] == EMPTY || map[pos.0][pos.1] == slopes[i])
            {
                positions.push(pos);
            }
        }
    }
    positions
}

fn longest_path(
    map: &amp;Grid&lt;char&gt;,
    visited: &amp;mut HashSet&lt;Position&gt;,
    pos: Position,
    max: &amp;mut u64,
    len: u64,
    end: &amp;Position,
    ignore_slopes: bool,
) {
    if pos == *end {
        if *max &lt; len {
            *max = len;
        }
        return;
    }
    let neighbors = step(map, pos, ignore_slopes);
    for n in neighbors {
        if !visited.contains(&amp;n) {
            visited.insert(n);
            longest_path(map, visited, n, max, len + 1, end, ignore_slopes);
            visited.remove(&amp;n);
        }
    }
}

fn part1() {
    let map = read_file("INPUT");
    let (start, end) = find_start_end(&amp;map);
    let mut set: HashSet&lt;Position&gt; = HashSet::new();
    let mut max: u64 = 0;
    longest_path(&amp;map, &amp;mut set, start, &amp;mut max, 0, &amp;end, false);
    println!("Part 1: {}", max);
}

fn part2() {
    let map = read_file("INPUT");
    let (start, end) = find_start_end(&amp;map);
    let mut set: HashSet&lt;Position&gt; = HashSet::new();
    let mut max: u64 = 0;
    longest_path(&amp;map, &amp;mut set, start, &amp;mut max, 0, &amp;end, true);
    println!("Part 2: {}", max);
}

fn main() {
    println!("Year 2023 day 23 - A Long Walk");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-24"><a class="header" href="#advent-of-code---year-2023-day-24">Advent of code - Year 2023 Day 24</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/24">day 24</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-36"><a class="header" href="#information-36">Information</a></h3>
<h4 id="part-1-35"><a class="header" href="#part-1-35">Part 1</a></h4>
<p>First part was somewhat easy since we only take a look at two dimensional matrix and finc the solution if there is any. After that check the bounds and return right answer.</p>
<h4 id="part-2-35"><a class="header" href="#part-2-35">Part 2</a></h4>
<p>In the second part we used <a href="https://docs.rs/z3/latest/z3/">z3</a> proving system to set the variables and solve the problem.</p>
<h2 id="mainrs-12"><a class="header" href="#mainrs-12">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use z3::ast::{Ast, Int};
use z3::{Config, Context, Solver};

struct HailStone {
    x: i64,
    y: i64,
    z: i64,
    xv: i64,
    yv: i64,
    zv: i64,
}

fn parse_hail_stone(line: &amp;str) -&gt; HailStone {
    let pos_vel: Vec&lt;&amp;str&gt; = line.split(" @ ").collect();
    let pos: Vec&lt;i64&gt; = pos_vel[0]
        .split(", ")
        .map(|x| i64::from_str_radix(x, 10).unwrap())
        .collect();
    let vel: Vec&lt;i64&gt; = pos_vel[1]
        .split(", ")
        .map(|x| i64::from_str_radix(x, 10).unwrap())
        .collect();
    HailStone {
        x: pos[0],
        y: pos[1],
        z: pos[2],
        xv: vel[0],
        yv: vel[1],
        zv: vel[2],
    }
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;HailStone&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    let mut hail_stones: Vec&lt;HailStone&gt; = vec![];
    for line in lines {
        if line != "" {
            hail_stones.push(parse_hail_stone(line));
        }
    }
    hail_stones
}

fn colission(hs1: &amp;HailStone, hs2: &amp;HailStone, limits: (i64, i64)) -&gt; bool {
    let det = (-hs1.xv) * hs2.yv - hs2.xv * (-hs1.yv);
    if det == 0 {
        return false;
    } else {
        let time1 = ((hs1.x - hs2.x) * hs2.yv - (hs1.y - hs2.y) * hs2.xv) / det;
        let time2 = ((-hs1.xv) * (hs1.y - hs2.y) - (-hs1.yv) * (hs1.x - hs2.x)) / det;
        let point = (hs1.x + hs1.xv * time1, hs1.y + hs1.yv * time1);
        return point.0 &gt;= limits.0
            &amp;&amp; point.0 &lt;= limits.1
            &amp;&amp; point.1 &gt;= limits.0
            &amp;&amp; point.1 &lt;= limits.1
            &amp;&amp; time1 &gt;= 0
            &amp;&amp; time2 &gt;= 0;
    }
}

fn number_of_collisions(hail_stones: &amp;Vec&lt;HailStone&gt;, limits: (i64, i64)) -&gt; u64 {
    let mut total: u64 = 0;
    for i in 0..hail_stones.len() {
        for j in i + 1..hail_stones.len() {
            if colission(&amp;hail_stones[i], &amp;hail_stones[j], limits) {
                total += 1;
            }
        }
    }
    total
}

fn perfect_shot(hailstones: &amp;Vec&lt;HailStone&gt;) -&gt; i64 {
    let cfg = Config::new();
    let ctx = Context::new(&amp;cfg);
    let solver = Solver::new(&amp;ctx);
    let px = Int::new_const(&amp;ctx, "px");
    let py = Int::new_const(&amp;ctx, "py");
    let pz = Int::new_const(&amp;ctx, "pz");
    let vx = Int::new_const(&amp;ctx, "vx");
    let vy = Int::new_const(&amp;ctx, "vy");
    let vz = Int::new_const(&amp;ctx, "vz");
    for hailstone in hailstones {
        let pxn = Int::from_i64(&amp;ctx, hailstone.x);
        let pyn = Int::from_i64(&amp;ctx, hailstone.y);
        let pzn = Int::from_i64(&amp;ctx, hailstone.z);
        let vxn = Int::from_i64(&amp;ctx, hailstone.xv);
        let vyn = Int::from_i64(&amp;ctx, hailstone.yv);
        let vzn = Int::from_i64(&amp;ctx, hailstone.zv);
        let tn = Int::fresh_const(&amp;ctx, "t");
        solver.assert(&amp;(&amp;pxn + &amp;vxn * &amp;tn)._eq(&amp;(&amp;px + &amp;vx * &amp;tn)));
        solver.assert(&amp;(&amp;pyn + &amp;vyn * &amp;tn)._eq(&amp;(&amp;py + &amp;vy * &amp;tn)));
        solver.assert(&amp;(&amp;pzn + &amp;vzn * &amp;tn)._eq(&amp;(&amp;pz + &amp;vz * &amp;tn)));
    }
    solver.check();
    let model = solver.get_model().unwrap();
    let x = model.get_const_interp(&amp;px).unwrap().as_i64().unwrap();
    let y = model.get_const_interp(&amp;py).unwrap().as_i64().unwrap();
    let z = model.get_const_interp(&amp;pz).unwrap().as_i64().unwrap();
    x + y + z
}

fn part1() {
    let hail_stones = read_file("INPUT");
    println!(
        "Part 1: {}",
        number_of_collisions(&amp;hail_stones, (200_000_000_000_000, 400_000_000_000_000))
    );
}

fn part2() {
    let hail_stones = read_file("INPUT");
    println!("Part 2: {}", perfect_shot(&amp;hail_stones));
}

fn main() {
    println!("Year 2023 day 24 - Never Tell Me The Odds");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-25"><a class="header" href="#advent-of-code---year-2023-day-25">Advent of code - Year 2023 Day 25</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/25">day 25</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-37"><a class="header" href="#information-37">Information</a></h3>
<h4 id="part-1-36"><a class="header" href="#part-1-36">Part 1</a></h4>
<p>The first part is done by <a href="https://graphviz.org/doc/info/lang.html">graphviz dot language</a>. So the code creates a file <code>graph.dot</code> than you run <code>dot -Kneato -Tsvg graph.dot -o graph.svg</code>. You find the three pairs forming the min cut and manually insert it into the code. Then you ran the code again.</p>
<p>The alternate algorithm is to use <a href="https://en.wikipedia.org/wiki/Karger%27s_algorithm">Karger-Steins</a> approximation algorithm. This I didn't make.</p>
<h4 id="part-2-36"><a class="header" href="#part-2-36">Part 2</a></h4>
<p><strong>PUSH THE RED BUTTON.</strong></p>
<h2 id="mainrs-13"><a class="header" href="#mainrs-13">main.rs</a></h2>
<pre><code class="language-rs">use std::collections::{HashSet, VecDeque};
use std::fs;
use std::io::Write;

struct Wire {
    start: String,
    ends: Vec&lt;String&gt;,
}

fn parse_wire(line: &amp;str) -&gt; Wire {
    let from_to: Vec&lt;&amp;str&gt; = line.split(": ").collect();
    let mut wire = Wire {
        start: from_to[0].to_string(),
        ends: vec![],
    };
    let parts: Vec&lt;&amp;str&gt; = from_to[1].split(' ').collect();
    for p in parts {
        wire.ends.push(p.to_string());
    }
    wire
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Wire&gt; {
    let contents = fs::read_to_string(filepath);
    let mut wires: Vec&lt;Wire&gt; = vec![];
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    for line in lines {
        if line != "" {
            wires.push(parse_wire(line));
        }
    }
    wires
}

fn create_graphviz(filepath: &amp;str, wires: &amp;Vec&lt;Wire&gt;) {
    let file = fs::File::create(filepath);
    match writeln!(file.as_ref().expect("REASON"), "{}", "graph AOC25 {") {
        Ok(()) =&gt; {}
        Err(..) =&gt; return,
    }
    for wire in wires {
        for end in &amp;wire.ends {
            match writeln!(
                file.as_ref().expect("REASON"),
                "{}",
                format!("  {} -- {};", wire.start, end)
            ) {
                Ok(()) =&gt; {}
                Err(..) =&gt; return,
            }
        }
    }
    match writeln!(file.as_ref().expect("REASON"), "{}", "}") {
        Ok(()) =&gt; {}
        Err(..) =&gt; return,
    }
}

fn is_forb(w1: &amp;str, w2: &amp;str, forb: &amp;[(&amp;str, &amp;str); 3]) -&gt; bool {
    for f in forb {
        if (f.0 == w1 &amp;&amp; f.1 == w2) || (f.1 == w1 &amp;&amp; f.0 == w2) {
            return true;
        }
    }
    false
}

fn partitions(wires: &amp;Vec&lt;Wire&gt;, forb: &amp;[(&amp;str, &amp;str); 3]) -&gt; u64 {
    let mut found: HashSet&lt;String&gt; = HashSet::new();
    let mut queue: VecDeque&lt;String&gt; = VecDeque::new();
    found.insert(wires[0].start.clone());
    queue.push_back(wires[0].start.clone());
    while !queue.is_empty() {
        let wire = queue.pop_front().unwrap();
        for w in wires {
            if wire == w.start {
                for e in &amp;w.ends {
                    if !is_forb(&amp;wire, &amp;e.clone(), forb) &amp;&amp; !found.contains(&amp;e.clone()) {
                        found.insert(e.clone());
                        queue.push_back(e.clone());
                    }
                }
            } else if w.ends.clone().into_iter().filter(|e| &amp;wire == e).count() &gt; 0 {
                for e in &amp;w.ends {
                    if &amp;wire == e
                        &amp;&amp; !is_forb(&amp;w.start, &amp;e.clone(), forb)
                        &amp;&amp; !found.contains(&amp;w.start)
                    {
                        found.insert(w.start.clone());
                        queue.push_back(w.start.clone());
                    }
                }
            }
        }
    }
    let mut all: HashSet&lt;String&gt; = HashSet::new();
    for w in wires {
        all.insert(w.start.clone());
        for e in &amp;w.ends {
            all.insert(e.clone());
        }
    }
    (found.len() * (all.len() - found.len())) as u64
}

fn part1() {
    let wires = read_file("INPUT");
    create_graphviz("graph.dot", &amp;wires);
    // This is only my solution. Run `dot -Kneato -Tsvg graph.dot -o graph.svg` to create your graph.
    let forb: [(&amp;str, &amp;str); 3] = [("dlv", "tqh"), ("ngp", "bmd"), ("tqr", "grd")];
    println!("Run `dot -Kneato -Tsvg graph.dot -o graph.svg` to see three edges.");
    println!("Part 1: {}", partitions(&amp;wires, &amp;forb));
}

fn part2() {
    println!("Part 2: {}", "PUSH THE RED BUTTON.");
}

fn main() {
    println!("Year 2023 day 25 - Snowverload");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022"><a class="header" href="#advent-of-code---year-2022">Advent of code - Year 2022</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2022">year 2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days-2"><a class="header" href="#days-2">Days</a></h3>
<ul>
<li><a href="aoc/2022-1.html">Day 1</a></li>
<li><a href="aoc/2022-2.html">Day 2</a></li>
<li><a href="aoc/2022-3.html">Day 3</a></li>
<li><a href="aoc/2022-4.html">Day 4</a></li>
<li><a href="aoc/2022-5.html">Day 5</a></li>
<li><a href="aoc/2022-6.html">Day 6</a></li>
<li><a href="aoc/2022-7.html">Day 7</a></li>
<li><a href="aoc/2022-8.html">Day 8</a></li>
<li><a href="aoc/2022-9.html">Day 9</a></li>
<li><a href="aoc/2022-10.html">Day 10</a></li>
<li><a href="aoc/2022-11.html">Day 11</a></li>
<li><a href="aoc/2022-12.html">Day 12</a></li>
<li><a href="aoc/2022-13.html">Day 13</a></li>
<li><a href="aoc/2022-14.html">Day 14</a></li>
<li><a href="aoc/2022-15.html">Day 15</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-1"><a class="header" href="#advent-of-code---year-2022-day-1">Advent of code - Year 2022 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/1">day 1</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-10"><a class="header" href="#mainpy-10">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

calories_max = 0
calories_sec_max = 0
calories_third_max = 0

with open('INPUT') as f:
  buffer = 0
  for line in f:
    if line == "\n":
      if buffer &gt; calories_max:
        calories_third_max = calories_sec_max
        calories_sec_max = calories_max
        calories_max = buffer
      elif buffer &gt; calories_sec_max:
        calories_third_max = calories_sec_max
        sec_max = buffer
      elif buffer &gt; calories_third_max:
        calories_third_max = buffer
      buffer = 0      
    else:
      buffer += int(line)

print(f"První: {calories_max}")
print(f"Druhý: {calories_max + sec_max + third_max}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-2"><a class="header" href="#advent-of-code---year-2022-day-2">Advent of code - Year 2022 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/2">day 2</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-11"><a class="header" href="#mainpy-11">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

WIN = 6
TIE = 3

win_sum = 0
opt_sum = 0
MODULO = 4
same = ord("X") - ord("A")

def addType(prio, pl, mod):
  tmp = (prio + 1 + pl)
  if tmp &gt;= mod:
    return tmp - mod + 1
  return tmp

with open("INPUT") as f:
  for line in f:
    fir = line[0]
    sec = line[2]
    if ord(sec) - ord(fir) == same:
      win_sum += TIE
    elif (fir == "A" and sec == "Y") or (fir == "B" and sec == "Z") or (fir == "C" and sec == "X"):
      win_sum += WIN
    win_sum += addType(ord(sec) - ord("X"), 0, MODULO)
    if sec == "Z":
      opt_sum += WIN
      opt_sum += addType(ord(fir) - ord("A"), 1, MODULO)
    elif sec == "Y":
      opt_sum += TIE
      opt_sum += addType(ord(fir) - ord("A"), 0, MODULO)
    else:
      opt_sum += addType(ord(fir) - ord("A"), 2, MODULO)
      
print(f"První: {win_sum}")
print(f"Druhý: {opt_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-3"><a class="header" href="#advent-of-code---year-2022-day-3">Advent of code - Year 2022 Day 3</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/3">day 3</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-12"><a class="header" href="#mainpy-12">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

length = ord('z') - ord('a')

def index(char):
  if ord(char) &gt; ord('Z'):
    return ord(char) - ord('a')
  else:
    return ord(char) - ord('A') + length + 1

total_sum = 0
type_sum = 0

with open("INPUT") as f:
  current = 0
  types = [True for _ in range(2*length + 2)]
  for line in f:
    if len(line) &gt; 0:
      first_half = [0 for _ in range(2*length + 2)]
      second_half = [0 for _ in range(2*length + 2)]
      current_types = [False for _ in range(2*length + 2)]
      mid = (len(line) - 1)//2
      one = line[:mid]
      two = line[mid:]
      for i in range(mid):
        first_half[index(one[i])] += 1
        second_half[index(two[i])] += 1
        current_types[index(one[i])] = True
        current_types[index(two[i])] = True
      for j in range(2*length + 2):
        total_sum += min(min(first_half[j], second_half[j]),1) * (j+1)
        types[j] = types[j] and current_types[j]
      current += 1
      if current == 3:
        current = 0;
        for j in range(2*length + 2):
          if types[j]:
            type_sum += j+1
            break
        types = [True for _ in range(2*length + 2)]
            
      
print(f"Prvni: {total_sum}")
print(f"Druha: {type_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-4"><a class="header" href="#advent-of-code---year-2022-day-4">Advent of code - Year 2022 Day 4</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/4">day 4</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-13"><a class="header" href="#mainpy-13">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

total_sum = 0
overlap_sum = 0

with open("INPUT") as f:
  for line in f:
    if line != '\n':
      comp = line.split(",")
      first = comp[0].split("-")
      second = comp[1].split("-")
      diff1 = int(first[0]) - int(second[0])
      diff2 = int(first[1]) - int(second[1])
      overlap1 = int(first[1]) - int(second[0])
      overlap2 = int(first[0]) - int(second[1])
      if (diff1 &lt;= 0 and diff2 &gt;= 0) or (diff1 &gt;= 0 and diff2 &lt;= 0):
        total_sum += 1
      if (overlap1 == 0 or overlap2 == 0) or (overlap1 &gt; 0 and overlap2 &lt; 0) or (overlap1 &lt; 0 and overlap2 &gt; 0):
        overlap_sum += 1

print(f"Prvni: {total_sum}")
print(f"Druhy: {overlap_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-5"><a class="header" href="#advent-of-code---year-2022-day-5">Advent of code - Year 2022 Day 5</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/5">day 5</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-14"><a class="header" href="#mainpy-14">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def frearrange(stack, count, fstack, tostack):
  for _ in range(count):
    if (stack[fstack] != []):
      stack[tostack].append(stack[fstack][-1])
      stack[fstack] = stack[fstack][:-1]

def srearrange(stack, count, fstack, tostack):
  realCount = min(count, len(stack[fstack]))
  tmp = stack[fstack][-realCount:]
  stack[fstack] = stack[fstack][:-realCount]
  for i in range(len(tmp)):
    stack[tostack].append(tmp[i])

def compute(rearrange, text):
  stack = [[] for _ in range(9)]
  with open("INPUT") as f:
    for line in f:
      if line != '\n':
        if line[0] != 'm' and line[1] != '1':
          for i in range(len(stack)):
            if(line[(4*i)+1]) != ' ':
              stack[i].append(line[(4*i)+1])
        elif line[1] == '1':
          for i in range(len(stack)):
            stack[i] = stack[i][::-1]
        elif line[0] == 'm':
          comp = line.split(' ')
          count = int(comp[1])
          fstack = int(comp[3]) - 1
          tostack = int(comp[5]) - 1
          rearrange(stack, count, fstack, tostack)
  print(text, end = "")
  for i in range(len(stack)):
    if stack[i] != []:
      print(stack[i][-1], end = "")
  print()

compute(frearrange, "Prvni: ")
compute(srearrange, "Druhy: ")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-6"><a class="header" href="#advent-of-code---year-2022-day-6">Advent of code - Year 2022 Day 6</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/6">day 6</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-15"><a class="header" href="#mainpy-15">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def check(array):
  sarray = sorted(array)
  for i in range(len(array) - 1):
    if sarray[i] == sarray[i+1] or sarray[i] == -1:
      return False
  return True

with open("INPUT") as f:
  for line in f:
    four = [-1 for _ in range(4)]
    message = [-1 for _ in range(14)]
    current = 0
    current_msg = 0
    first = False
    for i,char in enumerate(line):
      four[current] = ord(char)
      message[current_msg] = ord(char)
      current = (current + 1) % 4
      current_msg = (current_msg + 1) % 14
      if check(four) and not first:
        print(f"První: {i+1}")
        first = True
      if check(message):
        print(f"Druhá: {i+1}")
        break
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-7"><a class="header" href="#advent-of-code---year-2022-day-7">Advent of code - Year 2022 Day 7</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/7">day 7</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-16"><a class="header" href="#mainpy-16">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

class directory:
  def __init__(self, name, parent = ""):
    self.name = name
    self.parent = parent
    self.subdirs = []
    self.files = []
    self.tot_sum = 0
  def sum_all(self):
    for f in self.files:
      self.tot_sum += f
    for d in self.subdirs:
      self.tot_sum += d.sum_all()
    return self.tot_sum
  def add_all(self):
    tmp = 0
    if self.tot_sum &lt;= 100000:
      tmp += self.tot_sum
    for d in self.subdirs:
      tmp += d.add_all()
    return tmp
  def return_min(self, size):
    if self.tot_sum &gt; size:
      tmp = self.tot_sum
    else:  
      tmp = 70000000
    for d in self.subdirs:
      tmp = min(tmp, d.return_min(size))
    return tmp
  def same_name(self, name):
    return name == self.name
  def add_subdir(self, n, c):
    self.subdirs.append(directory(n, c))
  def cd(self, name):
    if name == '..\n':
      return self.parent
    for d in self.subdirs:
      if d.same_name(name):
        return d

root = directory('/')

with open("INPUT") as f:
  current = root
  for line in f:
    if line != '\n':
      if line[0] == '$':
        if line[2] == 'c':
          tmp = line.split(' ')
          if tmp[2] == '/\n':
            current = root
          else:
            current = current.cd(tmp[2])
      elif line[0] == 'd':
        current.add_subdir((line.split(' '))[1], current)
      else:
        number = int((line.split(' '))[0])
        current.files.append(number)

space = 70000000 - root.sum_all() 
needed = 30000000 - space
print(f"Prvni {root.add_all()}")
print(f"Druhy {root.return_min(needed)}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-8"><a class="header" href="#advent-of-code---year-2022-day-8">Advent of code - Year 2022 Day 8</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/8">day 8</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-17"><a class="header" href="#mainpy-17">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def read():
  forest = []
  with open("INPUT") as f:
    for line in f:
      tmp = line[:-1]
      forest.append([int(c) for c in tmp])
  return forest

def compute_visible(forest, visible, consti, constj, multi, multj, swap):
  for i in range(len(forest)):
    minimum = -1
    for j in range(len(forest[i])):
      if swap:
        i,j = j,i
      #print(f"Hledáme: {consti + multi*i} a {constj + multj*j}")
      if forest[consti + multi*i][constj + multj*j] &gt; minimum:
        minimum = forest[consti + multi*i][constj + multj*j]
        visible[consti + multi*i][constj + multj*j] = True
      if swap:
        i,j = j,i
  return visible

def total_sum(visible):
  tot_sum = 0
  for line in visible:
    for cell in line:
      if cell:
        tot_sum += 1
  print(f"Prvni: {tot_sum}")

def first_part(forest):
  visible = [[False for _ in range(len(a))] for a in forest]
  visible = compute_visible(forest, visible, 0, 0, 1, 1, False)
  visible = compute_visible(forest, visible, 0, len(forest)-1, 1, -1, False)
  visible = compute_visible(forest, visible, 0, 0, 1, 1, True)
  visible = compute_visible(forest, visible, len(forest)-1, 0, -1,  1, True)
  total_sum(visible)

def around(i, j, length, multi, multj):
  current_view = 0
  for l in range(length):
    if forest[i+multi*(l+1)][j+multj*(l+1)] &lt; forest[i][j]:
      current_view += 1
    else:
      current_view += 1
      break
  return current_view

def second_part(forest):
  max_score = 0
  for i in range(len(forest)):
    for j in range(len(forest[i])):
      score = 1
      score *= around(i,j, j, 0, -1)
      score *= around(i,j, len(forest[i]) - j - 1, 0, 1)
      score *= around(i,j, i, -1, 0)
      score *= around(i,j, len(forest) - i - 1, 1, 0)
      if score &gt; max_score:
        max_score = score
  print(f"Druhy: {max_score}")

forest = read()
first_part(forest)
second_part(forest)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-9"><a class="header" href="#advent-of-code---year-2022-day-9">Advent of code - Year 2022 Day 9</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/9">day 9</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-18"><a class="header" href="#mainpy-18">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

class rope:
  def __init__(self, count):
    self.head = (0,0)
    self.nodes = [(0,0) for _ in range(count)]
    self.tail = (0,0)
    self.visited = {self.tail}
  def one_close(self, fir, sec, thi, fou, eq):
    if eq*(fir - sec) &gt; eq**2:
      if thi == fou:
        second = thi
      elif thi &gt; fou:
        second = thi - 1
      else:
        second = thi + 1
      first = fir - eq
      return first, second, True
    return fir, sec, False
  def is_close(self, node1, node2):
    first, second, found = self.one_close(node1[0], node2[0], node1[1], node2[1], 1)
    if found:
      return (first,second)
    first, second, found = self.one_close(node1[0], node2[0], node1[1], node2[1], -1)
    if found:
      return (first,second)
    second, first, found = self.one_close(node1[1], node2[1], node1[0], node2[0], 1)
    if found:
      return (first,second)
    second, first, found = self.one_close(node1[1], node2[1], node1[0], node2[0], -1)
    if found:
      return (first,second)
    return (node1[0], node1[1])
  def move(self, move, length):
    for _ in range(int(length)):
      if move == 'R':
        self.head = (self.head[0], self.head[1]-1)
      elif move == 'L':
        self.head = (self.head[0], self.head[1]+1)
      elif move == 'D':
        self.head = (self.head[0]-1, self.head[1])
      elif move == 'U':
        self.head = (self.head[0]+1, self.head[1])
      self.nodes_moves()
  def nodes_moves(self):
    tmp = self.head
    for i in range(len(self.nodes)):
      self.nodes[i] = self.is_close(self.nodes[i], tmp)
      tmp = self.nodes[i]
    self.tail = self.is_close(self.tail, tmp)
    self.visited.add(self.tail)
  def get_visited(self):
    return len(self.visited)

with open("INPUT") as f:
  my_rope = rope(0)
  sec_part = rope(8)
  for line in f:
    if line != '\n':
      tmp = line.split(' ')
      my_rope.move(tmp[0],tmp[1])
      sec_part.move(tmp[0],tmp[1])
  print(f"Prvni: {my_rope.get_visited()}")
  print(f"Druhy: {sec_part.get_visited()}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-10"><a class="header" href="#advent-of-code---year-2022-day-10">Advent of code - Year 2022 Day 10</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/10">day 10</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-19"><a class="header" href="#mainpy-19">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

round_count = 0
X = 1
total_sum = 0
CHECKING = [20,60,100,140,180,220]
drawing = [[False for _ in range(40)] for _ in range(7)]
sprite = [-1,0,1]

def step(rc, drw, spr, x, ts):
  mod = rc % 40
  div = rc // 40
  rc += 1
  drw[div][mod] = (mod in spr)
  if rc in CHECKING:
    ts += (rc * x)
  return rc, drw, spr, x, ts

with open("INPUT") as f:
  for line in f:
    if line == '\n':
      continue
    if line == 'noop\n':
      round_count, drawing, sprite, X, total_sum = step(round_count, drawing, sprite, X, total_sum)
    else:
      parts = line.split(" ")
      round_count, drawing, sprite, X, total_sum = step(round_count, drawing, sprite, X, total_sum)
      round_count, drawing, sprite, X, total_sum = step(round_count, drawing, sprite, X, total_sum)
      X += int(parts[1])
      sprite = [X-1, X, X+1]
      
print(f"Prvni: {total_sum}")
print(f"Druhy: [RZHFGJCB]")
for i in range(len(drawing)):
  for j in range(len(drawing[i])):
    if drawing[i][j]:
      print('#', end = "")
    else:
      print('.', end = "")
  print()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-11"><a class="header" href="#advent-of-code---year-2022-day-11">Advent of code - Year 2022 Day 11</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/11">day 11</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-20"><a class="header" href="#mainpy-20">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

import operator

class Monkey:
  def __init__(self, items, operation, test, trmon, flsmon, nr):
    self.items = items
    self.operation = operation
    self.test = test
    self.counter = 0
    self.falsemonkey = flsmon
    self.truemonkey = trmon
    if nr == 'old':
      self.nr = 'old'
    else:
      self.nr = int(nr)
  def bind(self, true, false):
    self.true = true
    self.false = false
  def set_mod(self,mod):
    self.mod = mod
  def single_oper(self, item, div, mod):
    if self.nr == 'old':
      titem = self.operation(item,item)
    else:
      titem = self.operation(item, self.nr)
    if div:
      titem = titem // 3
    else:
      titem = titem % mod
    if titem % self.test == 0:
      self.true.add(titem)
    else:
      self.false.add(titem)
  def operate(self, mod, div):
    self.counter += len(self.items)
    for item in self.items:
      self.single_oper(item, div, mod)
    self.items = []
  def add(self, item):
    self.items.append(item)
  def print(self):
    print(self.items)


def read():
  monkeys = []
  with open("INPUT") as f:
    tmplist = []
    tmpoper = operator.mul;
    tmptest = 1
    truemonkey = 0
    falsemonkey = 0
    tmnr = 0
    tmmod = 1
    for line in f:
      parts = line.split(' ')
      if len(parts) &lt; 2:
        monkeys.append(Monkey(tmplist, tmpoper, tmptest, truemonkey, falsemonkey, tmnr))
        tmplist = []
      elif parts[0] == 'Monkey':
        continue
      elif parts[3] == 'items:':
        for nr in parts[4:]:
          tmplist.append(int(nr[:-1]))
      elif parts[3] == 'new':
        if parts[6] == '+':
          tmpoper = operator.add;
        else:
          tmpoper = operator.mul;
        tmnr = parts[7][:-1]
      elif parts[3] == 'divisible':
        tmptest = int(parts[5])
        tmmod *= int(parts[5])
      elif parts[5] == 'true:':
        truemonkey = int(parts[9])
      elif parts[5] == 'false:':
        falsemonkey = int(parts[9])
  for monkey in monkeys:
    monkey.bind(monkeys[monkey.truemonkey], monkeys[monkey.falsemonkey])
  return monkeys, tmmod

def common(div, count):
  monkeys, mod = read()
  for i in range(count):
    for monkey in monkeys:
      monkey.operate(mod, div)
  max1 = 0
  max2 = 0
  for monkey in monkeys:
    if max1 &lt; monkey.counter:
      max2 = max1
      max1 = monkey.counter
    elif max2 &lt; monkey.counter:
      max2 = monkey.counter
  return max1*max2

def first_part():
  print(f"Prvni: {common(True, 20)}")
  
def second_part():
  print(f"Druhy: {common(False, 10000)}")

first_part()
second_part()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-12"><a class="header" href="#advent-of-code---year-2022-day-12">Advent of code - Year 2022 Day 12</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/12">day 12</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="maincpp-1"><a class="header" href="#maincpp-1">main.cpp</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;climits&gt;
#include &lt;queue&gt;

int start[] = {0,0};
int end[] = {0,0};
std::vector&lt;int&gt; sPoints;

std::vector&lt;std::vector&lt;int&gt;&gt; read(){
  std::ifstream input = std::ifstream();
  input.open("INPUT");
  std::string line;
  std::vector&lt;std::vector&lt;int&gt;&gt; heights;
  int x = 0;
  while(getline(input, line)){
    heights.push_back(std::vector&lt;int&gt;());
    for(size_t i = 0; i &lt; line.length(); ++i){
      char c = line[i];
      if(c == 'S'){
        start[0] = x;
        start[1] = i;
        heights[x].push_back(0);
      }
      else if(c == 'E'){
        end[0] = x;
        end[1] = i;
        heights[x].push_back(int('z') - int('a'));
      }
      else if(c != '\n'){
        heights[x].push_back(int(c) - int('a'));
      }
      if (c == 'a'){
        int y = i;
        sPoints.push_back(x);
        sPoints.push_back(y);
      }
    }
    ++x;
  }
  return heights;
}

void onePath(std::queue&lt;int&gt;&amp; q, int x, int y, const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; h, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; v, int p0, int p1, int step){
  bool in_matrix = (p1 + x &gt;= 0) &amp;&amp; (p1 + y &gt;= 0) &amp;&amp; (p0 + x &lt; h.size()) &amp;&amp; (p1 + y &lt; h[0].size());
  if(!in_matrix){
    return;
  }
  bool possible =  h[p0 + x][p1 + y] &lt;= h[p0][p1] + 1;
  if(!possible){
    return;
  }
  bool worth = v[p0 + x][p1 + y] &gt; step + 1;
  if(!worth){
    return;
  }
  v[p0 + x][p1 + y] = step + 1;
  if (end[0] == p0 + x &amp;&amp; end[1] == p1 + y){
    return;
  }
  q.push(p0+x);
  q.push(p1+y);
  q.push(++step);
}

int findPath(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; h, int s0, int s1){
  std::queue&lt;int&gt; q;
  std::vector&lt;std::vector&lt;int&gt;&gt; visited;
  for(size_t i = 0; i &lt; h.size(); ++i){
    visited.push_back(std::vector&lt;int&gt;());
    for(size_t j = 0; j &lt; h[i].size(); ++j){
      visited[i].push_back(INT_MAX);
    }
  }
  visited[s0][s1] = 0;
  q.push(s0);
  q.push(s1);
  q.push(0);
  int neigh[][2] = { {-1, 0}, {1, 0}, {0, 1}, {0,-1} };
  while(!q.empty()){
    int p0 = q.front();
    q.pop();
    int p1 = q.front();
    q.pop();
    int step = q.front();
    q.pop();
    for(auto &amp;&amp; n : neigh){
      onePath(q, n[0], n[1], h, visited, p0, p1, step);
    }
  }
  return visited[end[0]][end[1]];
}

int main(int argc, char * * argv){
  std::vector&lt;std::vector&lt;int&gt;&gt; h = read();
  int min = findPath(h, start[0], start[1]);
  std::cout &lt;&lt; "Prvni: " &lt;&lt; min &lt;&lt; std::endl;
  std::cout &lt;&lt; "Druhy: ";
  for(size_t i = 0; i &lt; sPoints.size(); i += 2){
    int tmp = findPath(h, sPoints[i], sPoints[i+1]);
    if(tmp &lt; min){
      min = tmp;
    }
  }
  std::cout &lt;&lt; min &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-13"><a class="header" href="#advent-of-code---year-2022-day-13">Advent of code - Year 2022 Day 13</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/13">day 13</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-21"><a class="header" href="#mainpy-21">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3
from functools import cmp_to_key

def read(string):
  inp = []
  number = 0
  was_number = False
  i = 0
  while i &lt; len(string):
    c = string[i]
    if c == '[':
      np, index = read(string[i+1:])
      was_number = False
      inp.append(np)
      i += index + 1
    elif c == ']':
      if was_number:
        inp.append(number)
      return inp, i
    elif c == ',':
      if was_number:
        inp.append(number)
      number = 0
      was_number = False
    else:
      was_number = True
      number *= 10
      number += int(c)
    i += 1
  return np

def compare(x,y):
  if type(x) != type(y):
    return compare([x],y) if type(x) is int else compare(x,[y])
  else:
    if type(x) is int:
      if x != y:
        return -1 if x &gt; y else 1
      return 0
    else:
      for i in range(min(len(x), len(y))):
        if (res := compare(x[i], y[i])) != 0:
          return res
      if len(x) != len(y):
        return -1 if len(x) &gt; len(y) else 1
      return 0

list_all = [[[2]],[[6]]]
m = 1

with open("INPUT") as f:
  left = []
  right = []
  index = 0
  iSum = 0
  for line in f:
    if line == '\n':
      index += 1
      tmp = compare(left,right)
      if tmp != -1:
        iSum += index
    else:
      left = right
      right = read(line[:-1])
      list_all.append(right)
  print(f"Prvni {iSum}")
  s = sorted(list_all, key=cmp_to_key(lambda x, y : -compare(x,y)))
  for i in range(len(s)):
    if s[i] == [[2]]:
      m *= (i+1)
    if s[i] == [[6]]:
      m *= (i+1)
      print(f"Druhy: {m}")
      break
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-14"><a class="header" href="#advent-of-code---year-2022-day-14">Advent of code - Year 2022 Day 14</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/14">day 14</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-22"><a class="header" href="#mainpy-22">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def read(s):
  tmp = s.split(' -&gt; ')
  ret = []
  for t in tmp:
    nr = t.split(',')
    ret.append((int(nr[0]), int(nr[1])))
  return ret

d = set()

def addd(r, lo):
  index = 0
  while index+1 &lt; len(r):
    f = r[index]
    s = r[index+1]
    index += 1
    for i in range(min(f[0], s[0]), max(f[0],s[0])+1):
      for j in range(min(f[1], s[1]), max(f[1],s[1])+1):
        d.add((i,j))
        if j &gt; lo:
          lo = j
  return lo

def sand(lo):
  s = (500, 0)
  while s[1] &lt;= lo:
    if (s[0], s[1]+1) in d:
      if (s[0]-1, s[1] + 1) in d:
        if (s[0] + 1, s[1] + 1) in d:
          d.add(s)
          return 1
        s = (s[0] + 1, s[1] + 1)
        continue
      s = (s[0] - 1, s[1] + 1)
      continue
    s = (s[0], s[1] + 1)
  return 0

def sand2(lo):
  s = (500, 0)
  if s in d:
    return 0
  floor = lo + 2
  while s[1] &lt; floor:
    if (s[0], s[1]+1) in d or s[1]+1 == floor:
      if (s[0]-1, s[1] + 1) in d or s[1] +1  == floor:
        if (s[0] + 1, s[1] + 1) in d or s[1] +1 == floor:
          d.add(s)
          return 1
        s = (s[0] + 1, s[1] + 1)
        continue
      s = (s[0] - 1, s[1] + 1)
      continue
    s = (s[0], s[1] + 1)
  return 0

with open("INPUT") as f:
  lo = 0
  summ = 0
  for line in f:
    r = read(line[:-1])
    lo = addd(r, lo)
  while (sand(lo) == 1):
    summ += 1
  print(f"Prvni: {summ}")
  while sand2(lo) == 1:
    summ += 1
  print(f"Druhy: {summ}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-15"><a class="header" href="#advent-of-code---year-2022-day-15">Advent of code - Year 2022 Day 15</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/15">day 15</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-23"><a class="header" href="#mainpy-23">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

# Solution is relatively slow

class Sensor:
  def __init__(self, x, y, bx, by):
    self.x = x
    self.y = y
    self.bx = bx
    self.by = by
  def map(self, m, minx, maxx, addd, index):
    for i in range(len(m)):
      if abs(self.y - (index)) + abs(self.x - (i + minx)) &lt;= self.length():
        m[i] = True
  def map2(self, i, j):
    if abs(self.x - i) + abs(self.y - j) &lt;= self.length():
      return False, self.length() - abs(self.x - i) - abs(self.y - j)
    return True, 0
  def length(self):
    return abs(self.x-self.bx) + abs(self.y - self.by)

sensors = []
se = set()
be = set()

def read():
  with open("INPUT") as f:
    minx = 9000000
    maxx = -9000000
    for line in f:
      t = line.split(' ')
      s = Sensor(int(t[2][2:-1]), int(t[3][2:-1]), int(t[8][2:-1]), int(t[9][2:-1]))
      sensors.append(s)
      minx = min(s.x, s.bx, minx)
      maxx = max(s.x, s.bx, maxx)
      se.add((s.x,s.y))
      be.add((s.bx, s.by))
    return minx, maxx

def compute(index, minx, maxx):
  addd = max([s.length() for s in sensors])
  minx -= addd
  maxx += addd
  m = [ False for _ in range(minx, maxx+1)]
  for s in sensors:
    s.map(m, minx, maxx, addd, index)
  summ = 0
  for i, c in enumerate(m):
    if(i + minx, index) in be or (i+minx, index) in se:
      continue
    if c:
      summ += 1
  print(f"Prvni: {summ}")

def compute2(fr, to):
  mset = set()
  for i in range(to - fr + 1):
    j = 0
    while j &lt; (to - fr):
      found = True
      for s in sensors:
        f, shift = s.map2(i,j)
        found = found and f
        if not found:
          j += shift
          break
      j += 1
      if found:
        j -= 1
        print(f"Druhy: {i*4000000 + j}")
        return

minx, maxx = read()
compute(2000000, minx, maxx)
compute2(0, 4000000)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021"><a class="header" href="#advent-of-code---year-2021">Advent of code - Year 2021</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2021">year 2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days-3"><a class="header" href="#days-3">Days</a></h3>
<ul>
<li><a href="aoc/2021-1.html">Day 1</a></li>
<li><a href="aoc/2021-2.html">Day 2</a></li>
<li><a href="aoc/2021-3.html">Day 3</a></li>
<li><a href="aoc/2021-4.html">Day 4</a></li>
<li><a href="aoc/2021-5.html">Day 5</a></li>
<li><a href="aoc/2021-6.html">Day 6</a></li>
<li><a href="aoc/2021-7.html">Day 7</a></li>
<li><a href="aoc/2021-8.html">Day 8</a></li>
<li><a href="aoc/2021-10.html">Day 10</a></li>
<li><a href="aoc/2021-11.html">Day 11</a></li>
<li><a href="aoc/2021-14.html">Day 14</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-1"><a class="header" href="#advent-of-code---year-2021-day-1">Advent of code - Year 2021 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/1">day 1</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-38"><a class="header" href="#information-38">Information</a></h3>
<h4 id="part-1-37"><a class="header" href="#part-1-37">Part 1</a></h4>
<p>Generally we create a window of <code>n</code> elements and set their size. We proceed from <code>n</code>-th element and check if the sum of the new window is greater or not and update the sum and window. For part one the window has size <code>1</code>.</p>
<h4 id="part-2-37"><a class="header" href="#part-2-37">Part 2</a></h4>
<p>For the second part we set <code>n</code> to <code>3</code>.</p>
<h2 id="maingo-23"><a class="header" href="#maingo-23">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "strconv"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) []int {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  regex := regexp.MustCompile("([0-9]+)")
  found := regex.FindAllStringSubmatch(string(content), -1)
  array := make([]int, len(found))
  for i, f := range found {
    array[i], _ = strconv.Atoi(f[1])
  }
  return array
}

func slide(start []int) func(int) bool {
  window := start
  sum := 0
  for _, ele := range window {
    sum += ele
  }
  return func(ele int) bool {
    new_sum := sum - window[0] + ele
    window = append(window[1:], ele)
    res := new_sum &gt; sum
    sum = new_sum
    return res
  }
}

func part_one() {
  var result int
  start := time.Now()
  array := read_file("INPUT")
  s := slide(array[:1])
  for i := 1; i &lt; len(array); i++ {
    if s(array[i]) {
      result += 1
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  array := read_file("INPUT")
  s := slide(array[:3])
  for i := 3; i &lt; len(array); i++ {
    if s(array[i]) {
      result += 1
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2021" + Reset + " day " + Green + "1 - Sonar Sweep" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-2"><a class="header" href="#advent-of-code---year-2021-day-2">Advent of code - Year 2021 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/2">day 2</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-39"><a class="header" href="#information-39">Information</a></h3>
<h4 id="part-1-38"><a class="header" href="#part-1-38">Part 1</a></h4>
<p>In the first part we simply calculate the depth and forward position. The parsing is done via <code>regex</code>.</p>
<h4 id="part-2-38"><a class="header" href="#part-2-38">Part 2</a></h4>
<p>For the second part we use the provided calculation using aim.</p>
<h2 id="maingo-24"><a class="header" href="#maingo-24">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "strconv"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

type Instruction struct {
  instruction string
  value       int
}

func read_file(file_path string) []Instruction {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  regex := regexp.MustCompile("(forward|up|down) ([0-9])")
  found := regex.FindAllStringSubmatch(string(content), -1)
  instructions := make([]Instruction, len(found))
  for i, f := range found {
    nr, _ := strconv.Atoi(f[2])
    instructions[i] = Instruction{f[1], nr}
  }
  return instructions
}

func compute(instructions []Instruction) int {
  depth, forward := 0, 0
  for _, instruction := range instructions {
    switch instruction.instruction {
    case "up":
      depth -= instruction.value
    case "down":
      depth += instruction.value
    case "forward":
      forward += instruction.value
    }
  }
  return depth * forward
}

func compute_aim(instructions []Instruction) int {
  depth, forward, aim := 0, 0, 0
  for _, instruction := range instructions {
    switch instruction.instruction {
    case "up":
      aim -= instruction.value
    case "down":
      aim += instruction.value
    case "forward":
      forward += instruction.value
      depth += aim * instruction.value
    }
  }
  return depth * forward
}

func part_one() {
  var result int
  start := time.Now()
  instructions := read_file("INPUT")
  result = compute(instructions)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  instructions := read_file("INPUT")
  result = compute_aim(instructions)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2021" + Reset + " day " + Green + "2 - Dive!" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-3"><a class="header" href="#advent-of-code---year-2021-day-3">Advent of code - Year 2021 Day 3</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/3">day 3</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-40"><a class="header" href="#information-40">Information</a></h3>
<h4 id="part-1-39"><a class="header" href="#part-1-39">Part 1</a></h4>
<p>In the first part we compute gamma and epsilon by computing number of ones. This determines the most significant bit among all lines. Then we compute the number from such binary representation.</p>
<h4 id="part-2-39"><a class="header" href="#part-2-39">Part 2</a></h4>
<p>In the second part we also compute the most significant bit and filter lines. Then get the number from binary representation and multiply both cases.</p>
<h2 id="maingo-25"><a class="header" href="#maingo-25">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strconv"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) []string {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  lines := strings.Split(string(content), "\n")
  for i, line := range lines {
    if len(line) == 0 {
      lines = append(lines[:i], lines[i+1:]...)
    }
  }
  return lines
}

func number_of_ones(lines []string, index int) int {
  number_of_ones := 0
  for _, line := range lines {
    if line[index] == '0' {
      number_of_ones -= 1
    } else {
      number_of_ones += 1
    }
  }
  return number_of_ones
}

func significants(lines []string) int {
  gamma, epsilon := 0, 0
  acc := 1
  for j := len(lines[0]) - 1; j &gt;= 0; j-- {
    if number_of_ones(lines, j) &gt; 0 {
      gamma += acc
    } else {
      epsilon += acc
    }
    acc *= 2
  }
  return gamma * epsilon
}

func filter(lines []string, rule func(int, byte) bool) int {
  for i := 0; i &lt; len(lines[0]); i++ {
    number_of_ones := number_of_ones(lines, i)
    for j := 0; j &lt; len(lines); j++ {
      if rule(number_of_ones, lines[j][i]) {
        lines = append(lines[:j], lines[j+1:]...)
        j--
      }
    }
    if len(lines) == 1 {
      nr, _ := strconv.ParseInt(lines[0], 2, 64)
      return int(nr)
    }
  }
  return 0
}

func oxygen(lines []string) int {
  rule := func(number_of_ones int, bit byte) bool {
    return (number_of_ones &gt;= 0 &amp;&amp; bit == '0') || (number_of_ones &lt; 0 &amp;&amp; bit == '1')
  }
  return filter(lines, rule)
}

func co2(lines []string) int {
  rule := func(number_of_ones int, bit byte) bool {
    return (number_of_ones &lt; 0 &amp;&amp; bit == '0') || (number_of_ones &gt;= 0 &amp;&amp; bit == '1')
  }
  return filter(lines, rule)
}

func part_one() {
  var result int
  start := time.Now()
  lines := read_file("INPUT")
  result = significants(lines)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  result = oxygen(read_file("INPUT")) * co2(read_file("INPUT"))
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2021" + Reset + " day " + Green + "3 - Binary Diagnostic" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-4"><a class="header" href="#advent-of-code---year-2021-day-4">Advent of code - Year 2021 Day 4</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/4">day 4</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-41"><a class="header" href="#information-41">Information</a></h3>
<h4 id="part-1-40"><a class="header" href="#part-1-40">Part 1</a></h4>
<p>In the first part we iterate over the numbers and fill in the bingo cards and check if it is winning, if so compute the value and multiply it by the drawn number.</p>
<h4 id="part-2-40"><a class="header" href="#part-2-40">Part 2</a></h4>
<p>In the second part use the same procedure, only cycle through the winning boards, since multiple boards can win in with the same number.</p>
<h2 id="maingo-26"><a class="header" href="#maingo-26">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strconv"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

type Box struct {
  value int
  mark  bool
}

type Bingo [5][5]Box

func empty_bingo() Bingo {
  var bingo Bingo
  return bingo
}

func read_file(file_path string) ([]int, []Bingo) {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  counter := 0
  var numbers []int
  var bingos []Bingo
  for _, line := range strings.Split(string(content), "\n") {
    if len(line) == 0 {
      continue
    }
    space_splited := strings.Split(line, " ")
    comma_splited := strings.Split(line, ",")
    if len(comma_splited) &gt; 1 {
      for _, nbr_string := range comma_splited {
        nr, _ := strconv.Atoi(nbr_string)
        numbers = append(numbers, nr)
      }
    } else {
      if counter%5 == 0 {
        bingos = append(bingos, empty_bingo())
      }
      j := 0
      for i := 0; i &lt; len(space_splited); i++ {
        if len(space_splited[i]) == 0 {
          continue
        }
        nr, _ := strconv.Atoi(space_splited[i])
        bingos[counter/5][counter%5][j] = Box{nr, false}
        j++
      }
      counter++
    }
  }
  return numbers, bingos
}

func is_winning(bingo Bingo) bool {
  for i, row := range bingo {
    is_row_winning := true
    is_column_winning := true
    for j, ele := range row {
      is_row_winning = is_row_winning &amp;&amp; ele.mark
      is_column_winning = is_column_winning &amp;&amp; bingo[j][i].mark
    }
    if is_row_winning || is_column_winning {
      return true
    }
  }
  return false
}

func value_of_bingo(bingo Bingo) int {
  result := 0
  for _, row := range bingo {
    for _, ele := range row {
      if !ele.mark {
        result += ele.value
      }
    }
  }
  return result
}

func draw_number(bingos []Bingo, number int) (int, int, bool) {
  for k, bingo := range bingos {
    for i, row := range bingo {
      for j, ele := range row {
        if number == ele.value {
          bingos[k][i][j].mark = true
        }
      }
    }
    if is_winning(bingos[k]) {
      return number * value_of_bingo(bingos[k]), k, true
    }
  }
  return 0, -1, false
}

func part_one() {
  var result int
  start := time.Now()
  numbers, bingos := read_file("INPUT")
  for _, number := range numbers {
    val, _, win := draw_number(bingos, number)
    if win {
      result = val
      break
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  numbers, bingos := read_file("INPUT")
  for _, number := range numbers {
    val, index, win := draw_number(bingos, number)
    for win {
      bingos = append(bingos[:index], bingos[index+1:]...)
      result = val
      val, index, win = draw_number(bingos, number)
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2021" + Reset + " day " + Green + "4 - Giant Squid" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-5"><a class="header" href="#advent-of-code---year-2021-day-5">Advent of code - Year 2021 Day 5</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/5">day 5</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-42"><a class="header" href="#information-42">Information</a></h3>
<h4 id="part-1-41"><a class="header" href="#part-1-41">Part 1</a></h4>
<p>In the first part we check if at least one coordinate is equal. If so add all midpoints by computing the difference.</p>
<h4 id="part-2-41"><a class="header" href="#part-2-41">Part 2</a></h4>
<p>In the second part we use pretty much the same approach only this time we will consider also diagonal cases. Which are found by having the same absolute values of difference.</p>
<h2 id="maingo-27"><a class="header" href="#maingo-27">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "math"
  "os"
  "regexp"
  "strconv"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

type Line struct {
  start [2]int
  end   [2]int
}

func read_file(file_path string) []Line {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  regex := regexp.MustCompile("([0-9]+),([0-9]+) -&gt; ([0-9]+),([0-9]+)")
  found := regex.FindAllStringSubmatch(string(content), -1)
  var lines []Line
  for _, f := range found {
    start_x, _ := strconv.Atoi(f[1])
    start_y, _ := strconv.Atoi(f[2])
    end_x, _ := strconv.Atoi(f[3])
    end_y, _ := strconv.Atoi(f[4])
    lines = append(lines, Line{[2]int{start_x, start_y}, [2]int{end_x, end_y}})
  }
  return lines
}

func add_to_map(number_of_lines *map[[2]int]int, pos [2]int) {
  _, ok := (*number_of_lines)[pos]
  if ok {
    (*number_of_lines)[pos] += 1
  } else {
    (*number_of_lines)[pos] = 1
  }
}

func midpoints(number_of_lines *map[[2]int]int, line Line) {
  diff := [2]int{line.start[0] - line.end[0], line.start[1] - line.end[1]}
  if diff[0] == 0 {
    incr := diff[1] / int(math.Abs(float64(diff[1])))
    for x := line.end[1]; x != line.start[1]; x += incr {
      add_to_map(number_of_lines, [2]int{line.start[0], x})
    }
    add_to_map(number_of_lines, line.start)
  } else if diff[1] == 0 {
    incr := diff[0] / int(math.Abs(float64(diff[0])))
    for x := line.end[0]; x != line.start[0]; x += incr {
      add_to_map(number_of_lines, [2]int{x, line.start[1]})
    }
    add_to_map(number_of_lines, line.start)
  } else if int(math.Abs(float64(diff[1]))) == int(math.Abs(float64(diff[0]))) {
    incr := [2]int{diff[0] / int(math.Abs(float64(diff[0]))), diff[1] / int(math.Abs(float64(diff[1])))}
    y := line.end[1]
    for x := line.end[0]; x != line.start[0]; x += incr[0] {
      add_to_map(number_of_lines, [2]int{x, y})
      y += incr[1]
    }
    add_to_map(number_of_lines, line.start)

  }
}

func part_one() {
  var result int
  start := time.Now()
  number_of_lines := make(map[[2]int]int)
  lines := read_file("INPUT")
  for _, line := range lines {
    if line.start[0] == line.end[0] || line.start[1] == line.end[1] {
      midpoints(&amp;number_of_lines, line)
    }
  }
  for _, ele := range number_of_lines {
    if ele &gt;= 2 {
      result += 1
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  number_of_lines := make(map[[2]int]int)
  lines := read_file("INPUT")
  for _, line := range lines {
    midpoints(&amp;number_of_lines, line)
  }
  for _, ele := range number_of_lines {
    if ele &gt;= 2 {
      result += 1
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2021" + Reset + " day " + Green + "5 - Hydrothermal Venture" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-6"><a class="header" href="#advent-of-code---year-2021-day-6">Advent of code - Year 2021 Day 6</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/6">day 6</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-43"><a class="header" href="#information-43">Information</a></h3>
<h4 id="part-1-42"><a class="header" href="#part-1-42">Part 1</a></h4>
<p>We setup an array of lanternfish based on their days until new reproduction cycle starts. Then we add the number of lanternfish which will reproduce to the end and also to the reset index. We will run this for <code>80</code> days.</p>
<h4 id="part-2-42"><a class="header" href="#part-2-42">Part 2</a></h4>
<p>We use the same simulation, only run it for <code>256</code> days.</p>
<h2 id="maingo-28"><a class="header" href="#maingo-28">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "regexp"
  "strconv"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) [9]int {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  regex := regexp.MustCompile("[0-9]+")
  found := regex.FindAllString(string(content), -1)
  var lanternfish [9]int
  for _, f := range found {
    index, _ := strconv.Atoi(f)
    lanternfish[index] += 1
  }
  return lanternfish
}

func simulate_life(lanternfish [9]int, days int) int {
  for i := 0; i &lt; days; i++ {
    first := lanternfish[0]
    for j := 1; j &lt; len(lanternfish); j++ {
      lanternfish[j-1] =lanternfish[j]
    }
    lanternfish[8] = first
    lanternfish[6] += first
  }
  sum := 0
  for i := 0; i &lt; len(lanternfish); i++ {
    sum += lanternfish[i]
  }
  return sum
}

func part_one() {
  var result int
  start := time.Now()
  lanternfish := read_file("INPUT")
  result = simulate_life(lanternfish, 80)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  lanternfish := read_file("INPUT")
  result = simulate_life(lanternfish, 256)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2021" + Reset + " day " + Green + "6 - Lanternfish" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-7"><a class="header" href="#advent-of-code---year-2021-day-7">Advent of code - Year 2021 Day 7</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/7">day 7</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-44"><a class="header" href="#information-44">Information</a></h3>
<h4 id="part-1-43"><a class="header" href="#part-1-43">Part 1</a></h4>
<p>In both cases we try all possibilities and find the optimum.</p>
<h4 id="part-2-43"><a class="header" href="#part-2-43">Part 2</a></h4>
<p>In the second part we only need to rewrite the operator for computing the distance.</p>
<h2 id="maingo-29"><a class="header" href="#maingo-29">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "math"
  "os"
  "regexp"
  "sort"
  "strconv"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) []int {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  regex := regexp.MustCompile("[0-9]+")
  found := regex.FindAllString(string(content), -1)
  var horizontal_positions []int
  for _, f := range found {
    nr, _ := strconv.Atoi(f)
    horizontal_positions = append(horizontal_positions, nr)
  }
  return horizontal_positions
}

func optimize_distance(numbers []int, op func(int, int) int) int {
  sort.Ints(numbers)
  result := op(numbers[0], numbers[len(numbers)-1]) * len(numbers)
  for x := numbers[0]; x &lt; numbers[len(numbers)-1]; x++ {
    sum := 0
    for _, pos := range numbers {
      sum += op(x, pos)
    }
    if sum &lt; result {
      result = sum
    }
  }
  return result
}

func part_one() {
  var result int
  start := time.Now()
  horizontal_positions := read_file("INPUT")
  dist := func(x, y int) int { return int(math.Abs(float64(x - y))) }
  result = optimize_distance(horizontal_positions, dist)
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  horizontal_positions := read_file("INPUT")
  scaled_dist := func(x, y int) int {
    diff := int(math.Abs(float64(x - y)))
    return (diff * (diff + 1)) / 2
  }
  result = optimize_distance(horizontal_positions, scaled_dist)
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2021" + Reset + " day " + Green + "7 - The Treachery of Whales" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-8"><a class="header" href="#advent-of-code---year-2021-day-8">Advent of code - Year 2021 Day 8</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/8">day 8</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-45"><a class="header" href="#information-45">Information</a></h3>
<h4 id="part-1-44"><a class="header" href="#part-1-44">Part 1</a></h4>
<p>For the first part we only compute the number of strings which have certain lengths: <code>2</code>, <code>3</code>, <code>4</code> and <code>7</code>.</p>
<h4 id="part-2-44"><a class="header" href="#part-2-44">Part 2</a></h4>
<h2 id="maingo-30"><a class="header" href="#maingo-30">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "strings"
  "time"
)

const (
  Blue   = "[1;34m"
  Yellow = "[1;33m"
  Green  = "[1;32m"
  Reset  = "[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

type Note struct {
  notes []string
  display []string
}

func read_file(file_path string) []Note {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  var notes []Note
  for _, line := range strings.Split(string(content), "\n") {
    if len(line) == 0 {
      continue
    }
    split := strings.Split(line, " | ")
    var note Note
    note.notes = strings.Split(split[0], " ")
    note.display = strings.Split(split[1], " ")
    notes = append(notes, note)
  }
  return notes
}

func part_one() {
  var result int
  start := time.Now()
  notes := read_file("INPUT")
  for _, note := range notes {
    for _, digit := range note.display {
      if len(digit) == 2 || len(digit) == 3 || len(digit) == 4 || len(digit) == 7 {
        result += 1
      }
    }
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2021" + Reset + " day " + Green + "8 - Claw Contraption" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-10"><a class="header" href="#advent-of-code---year-2021-day-10">Advent of code - Year 2021 Day 10</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/10">day 10</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-46"><a class="header" href="#information-46">Information</a></h3>
<h4 id="part-1-45"><a class="header" href="#part-1-45">Part 1</a></h4>
<p>In the first part we go though the characters. If they are opening add them to the stack and if it is closing one check the top of the stack and either return the value of the bracket or continue.</p>
<h4 id="part-2-45"><a class="header" href="#part-2-45">Part 2</a></h4>
<p>For the second part if the previous procedure did not exited we pop characters one by one and compute the sum, then we collect all sums and sort them to find the middle one.</p>
<h2 id="maingo-31"><a class="header" href="#maingo-31">main.go</a></h2>
<pre><code class="language-go">package main

import (
  "fmt"
  "log"
  "os"
  "sort"
  "strings"
  "time"
)

const (
  Blue   = "\033[1;34m"
  Yellow = "\033[1;33m"
  Green  = "\033[1;32m"
  Reset  = "\033[0m"
)

func print_result(dur time.Duration, part, result int) {
  fmt.Println("Part " + fmt.Sprint(part) + " [" + Blue + fmt.Sprint(dur) + Reset + "]: " + Yellow + fmt.Sprint(result) + Reset)
}

func read_file(file_path string) []string {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  lines := strings.Split(string(content), "\n")
  for i := 0; i &lt; len(lines); i++ {
    if len(lines[i]) == 0 {
      lines = append(lines[:i], lines[i+1:]...)
      i--
    }
  }
  return lines
}

func filter_or_fill(line string) (int, int) {
  var stack []byte
  for i := 0; i &lt; len(line); i++ {
    switch line[i] {
    case '&lt;', '(', '{', '[':
      stack = append(stack, line[i])
    case '&gt;', ')', '}', ']':
      top := stack[len(stack)-1]
      stack = stack[:len(stack)-1]
      if line[i] == '&gt;' &amp;&amp; top != '&lt;' {
        return 25137, 0
      } else if line[i] == ')' &amp;&amp; top != '(' {
        return 3, 0
      } else if line[i] == ']' &amp;&amp; top != '[' {
        return 57, 0
      } else if line[i] == '}' &amp;&amp; top != '{' {
        return 1197, 0
      }
    }
  }
  sum := 0
  for len(stack) &gt; 0 {
    top := stack[len(stack)-1]
    stack = stack[:len(stack)-1]
    sum *= 5
    switch top {
    case '(':
      sum += 1
    case '[':
      sum += 2
    case '{':
      sum += 3
    case '&lt;':
      sum += 4
    }
  }
  return 0, sum
}

func part_one() {
  var result int
  start := time.Now()
  lines := read_file("INPUT")
  for _, line := range lines {
    val, _ := filter_or_fill(line)
    result += val
  }
  end := time.Now()
  print_result(end.Sub(start), 1, result)
}

func part_two() {
  var result int
  start := time.Now()
  lines := read_file("INPUT")
  var scores []int
  for _, line := range lines {
    _, val := filter_or_fill(line)
    if val != 0 {
      scores = append(scores, val)
    }
  }
  sort.Ints(scores)
  result = scores[len(scores)/2]
  end := time.Now()
  print_result(end.Sub(start), 2, result)
}

func main() {
  fmt.Println("Year " + Green + "2021" + Reset + " day " + Green + "10 - Syntax Scoring" + Reset)
  part_one()
  part_two()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-11"><a class="header" href="#advent-of-code---year-2021-day-11">Advent of code - Year 2021 Day 11</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/11">day 11</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="first-partpy"><a class="header" href="#first-partpy">first-part.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

with open("INPUT") as f:
    array = []
    for i in range(10):
        array.append([])
        for j in range(10):
            array[i].append(0)
    index = 0
    for line in f:
        j = 0
        for char in line:
            if char != '\n':
                array[index][j] = (int(char))
                j += 1
        index += 1
    sum = 0
    for i in range(100):
        for j in range(len(array)):
            for k in range(len(array[j])):
                array[j][k] += 1
        stop = 1
        while stop == 1:
            stop = 0
            for j in range(len(array)):
                for k in range(len(array[j])):
                    if array[j][k] &gt; 9:
                        stop = 1
                        sum += 1
                        array[j][k] = 0
                        adjecent = [[j,k+1],[j+1,k],[j-1,k],[j,k-1],[j+1,k-1],[j-1,k+1],[j+1,k+1],[j-1,k-1]]
                        for ad in adjecent:
                            if ad[0] &gt;= 0 and ad[1] &gt;= 0 and ad[0] &lt; len(array) and ad[1] &lt; len(array[j]):
                                if (array[ad[0]][ad[1]] != 0):
                                    array[ad[0]][ad[1]] += 1
    print(sum)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-14"><a class="header" href="#advent-of-code---year-2021-day-14">Advent of code - Year 2021 Day 14</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/14">day 14</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="first-partpy-1"><a class="header" href="#first-partpy-1">first-part.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

with open("INPUT") as f:
    first = True
    plates = []
    second_plates = []
    rules = []
    for line in f:
        if first:
            first = False
            for j in range(len(line)-1):
                plates.append(line[j])
        else:
            t = line.split(" -&gt; ")
            t[1] = t[1][0]
            temp = [t[0], t[1]]
            rules.append(temp)
    for k in range(10):
        #print(f"Step: {k}: {plates}")
        second_plates = []
        second_plates.append(plates[0])
        for i in range(1, len(plates)):
            frst = plates[i-1]
            scnd = plates[i]
            adding = ""
            find = frst + scnd
            for j in range(len(rules)):
                if rules[j][0] == find:
                    adding = rules[j][1]
                    break
            second_plates.append(adding)
            second_plates.append(scnd)
        plates = second_plates
    found = []
    for i in range(len(plates)):
        find = False
        for j in range(len(found)):
            if found[j][0] == plates[i]:
                found[j][1] += 1
                find = True
        if find == False:
            found.append([plates[i], 0])
    maxximum = ["", 0]
    minimum = ["", 0]
    for i in range(len(found)):
        if maxximum[0] == "" or maxximum[1] &lt; found[i][1]:
            maxximum[0] = found[i][0]
            maxximum[1] = found[i][1]
        if minimum[0] == "" or minimum[1] &gt; found[i][1]:
            minimum = found[i]
    print(maxximum[1] - minimum[1])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2017"><a class="header" href="#advent-of-code---year-2017">Advent of code - Year 2017</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2017">year 2017</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days-4"><a class="header" href="#days-4">Days</a></h3>
<ul>
<li><a href="aoc/2017-1.html">Day 1</a></li>
<li><a href="aoc/2017-2.html">Day 2</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2017-day-1"><a class="header" href="#advent-of-code---year-2017-day-1">Advent of code - Year 2017 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2017/day/1">day 1</a>. Go back to year <a href="aoc/2017.html">2017</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-47"><a class="header" href="#information-47">Information</a></h3>
<h4 id="part-1-46"><a class="header" href="#part-1-46">Part 1</a></h4>
<p>In the first part we lineary check the two consecutive indexes and if they match add them. These are taken with modulo.</p>
<h4 id="part-2-46"><a class="header" href="#part-2-46">Part 2</a></h4>
<p>In the second part instead of looking at consecutive ones look at the ones that are hlafway apart.</p>
<h2 id="mainrs-14"><a class="header" href="#mainrs-14">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;

fn read_file(filepath: &amp;str) -&gt; String {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    binding.split('\n').next().unwrap().to_string()
}

fn part1() {
    let line = read_file("INPUT");
    let mut total: u32 = 0;
    for i in 0..line.len() {
        if line.chars().nth(i) == line.chars().nth((i + 1) % line.len()) {
            total += line.chars().nth(i).unwrap().to_digit(10).unwrap();
        }
    }
    println!("Part 1: {}", total);
}

fn part2() {
    let line = read_file("INPUT");
    let mut total: u32 = 0;
    for i in 0..line.len() {
        if line.chars().nth(i) == line.chars().nth((i + line.len() / 2) % line.len()) {
            total += line.chars().nth(i).unwrap().to_digit(10).unwrap();
        }
    }
    println!("Part 2: {}", total);
}

fn main() {
    println!("Year 2017 day 1 - Inverse Captcha");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2017-day-2"><a class="header" href="#advent-of-code---year-2017-day-2">Advent of code - Year 2017 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2017/day/2">day 2</a>. Go back to year <a href="aoc/2017.html">2017</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-48"><a class="header" href="#information-48">Information</a></h3>
<h4 id="part-1-47"><a class="header" href="#part-1-47">Part 1</a></h4>
<p>In the first part we use iterations. We compute the maximums and minimums. After that we zip those together and find the subtraction and sum it up.</p>
<h4 id="part-2-47"><a class="header" href="#part-2-47">Part 2</a></h4>
<p>In the second part we go through all posibilities and test if they are divisible or not. If they are add the division to the total and break the loop for the line.</p>
<h2 id="mainrs-15"><a class="header" href="#mainrs-15">main.rs</a></h2>
<pre><code class="language-rs">use std::cmp::{max, min};
use std::fs;
use std::iter::zip;

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Vec&lt;i64&gt;&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let numbers = binding
        .split('\n')
        .filter(|c| c.len() &gt; 0)
        .map(|c| {
            c.split('\t')
                .map(|val| val.parse::&lt;i64&gt;().unwrap())
                .collect()
        })
        .collect();
    numbers
}

fn part1() {
    let numbers = read_file("INPUT");
    let maximums: Vec&lt;i64&gt; = numbers
        .clone()
        .into_iter()
        .map(|vec| vec.into_iter().fold(0, |acc, x| max(acc, x)))
        .collect();
    let minimums: Vec&lt;i64&gt; = numbers
        .into_iter()
        .map(|vec| vec.into_iter().fold(i64::MAX, |acc, x| min(acc, x)))
        .collect();
    let res = zip(minimums, maximums).map(|(a, b)| b - a).sum::&lt;i64&gt;();
    println!("Part 1: {}", res);
}

fn part2() {
    let numbers = read_file("INPUT");
    let mut total: i64 = 0;
    for num_line in numbers {
        'line: for i in 0..num_line.len() {
            for j in i + 1..num_line.len() {
                if num_line[i] % num_line[j] == 0 {
                    total += num_line[i] / num_line[j];
                    break 'line;
                } else if num_line[j] % num_line[i] == 0 {
                    total += num_line[j] / num_line[i];
                    break 'line;
                }
            }
        }
    }
    println!("Part 2: {}", total);
}

fn main() {
    println!("Year 2017 day 2 - Corruption Checksum");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2016"><a class="header" href="#advent-of-code---year-2016">Advent of code - Year 2016</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2016">year 2016</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days-5"><a class="header" href="#days-5">Days</a></h3>
<ul>
<li><a href="aoc/2016-1.html">Day 1</a></li>
<li><a href="aoc/2016-2.html">Day 2</a></li>
<li><a href="aoc/2016-3.html">Day 3</a></li>
<li><a href="aoc/2016-4.html">Day 4</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2016-day-1"><a class="header" href="#advent-of-code---year-2016-day-1">Advent of code - Year 2016 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2016/day/1">day 1</a>. Go back to year <a href="aoc/2016.html">2016</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-49"><a class="header" href="#information-49">Information</a></h3>
<h4 id="part-1-48"><a class="header" href="#part-1-48">Part 1</a></h4>
<p>In the first part we jump from one place to another and then compute the manhattan distance. It is implemented to solve also the other part.</p>
<h4 id="part-2-48"><a class="header" href="#part-2-48">Part 2</a></h4>
<p>The second part we visit every single step in the middle and find the one which was already visited.</p>
<h2 id="mainrs-16"><a class="header" href="#mainrs-16">main.rs</a></h2>
<pre><code class="language-rs">use regex::Regex;
use std::collections::HashSet;
use std::fs;

#[derive(Copy, Clone, Eq, Debug, PartialEq, Ord, PartialOrd)]
enum Rotation {
    R,
    L,
}

struct Movement {
    rot: Rotation,
    mult: i64,
}

type Position = (i64, i64);

const NORTH: Position = (0, -1);
const SOUTH: Position = (0, 1);
const EAST: Position = (1, 0);
const WEST: Position = (-1, 0);

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Movement&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let mut movements: Vec&lt;Movement&gt; = vec![];
    let re = Regex::new(r"(R|L)([0-9]+)").unwrap();
    for (_, [rotation, movement]) in re.captures_iter(&amp;binding).map(|c| c.extract()) {
        if rotation == "R" {
            movements.push(Movement {
                rot: Rotation::R,
                mult: movement.parse().unwrap(),
            });
        } else {
            movements.push(Movement {
                rot: Rotation::L,
                mult: movement.parse().unwrap(),
            });
        }
    }
    movements
}

fn get_shift(rot: Rotation, direction: Position) -&gt; Position {
    match rot {
        Rotation::R =&gt; {
            if direction == NORTH {
                return EAST;
            } else if direction == EAST {
                return SOUTH;
            } else if direction == SOUTH {
                return WEST;
            } else {
                return NORTH;
            }
        }
        Rotation::L =&gt; {
            if direction == NORTH {
                return WEST;
            } else if direction == WEST {
                return SOUTH;
            } else if direction == SOUTH {
                return EAST;
            } else {
                return NORTH;
            }
        }
    }
}

fn distance(movements: &amp;Vec&lt;Movement&gt;, stop: bool) -&gt; i64 {
    let mut positions: HashSet&lt;Position&gt; = HashSet::new();
    let mut pos: Position = (0, 0);
    let mut shift: Position = NORTH;
    'outer: for mov in movements {
        shift = get_shift(mov.rot, shift);
        for _ in 0..mov.mult {
            pos.0 += shift.0;
            pos.1 += shift.1;
            if positions.contains(&amp;pos) &amp;&amp; stop {
                break 'outer;
            }
            positions.insert(pos);
        }
    }
    pos.0.abs() + pos.1.abs()
}

fn part1() {
    let movements = read_file("INPUT");
    println!("Part 1: {}", distance(&amp;movements, false));
}

fn part2() {
    let movements = read_file("INPUT");
    println!("Part 2: {}", distance(&amp;movements, true));
}

fn main() {
    println!("Year 2016 day 1 - No Time for a Taxicab");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2016-day-2"><a class="header" href="#advent-of-code---year-2016-day-2">Advent of code - Year 2016 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2016/day/2">day 2</a>. Go back to year <a href="aoc/2016.html">2016</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-50"><a class="header" href="#information-50">Information</a></h3>
<h4 id="part-1-49"><a class="header" href="#part-1-49">Part 1</a></h4>
<p>The first part can be done with aritmetics and matrix <code>3x3</code> and not to move out of boundaries.</p>
<h4 id="part-2-49"><a class="header" href="#part-2-49">Part 2</a></h4>
<p>In the second part we create a dialpads with boundaries so we never can reach out of it. So when we move we only check if there is empty symbol or not. This is also used for the first part to reuse the code.</p>
<h2 id="mainrs-17"><a class="header" href="#mainrs-17">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;

const EMPTY: char = '$';

const DIALPAD: [[char; 7]; 7] = [
    [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, '1', '2', '3', EMPTY, EMPTY],
    [EMPTY, EMPTY, '4', '5', '6', EMPTY, EMPTY],
    [EMPTY, EMPTY, '7', '8', '9', EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
];

const DIALPAD_ADVANCED: [[char; 7]; 7] = [
    [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, '1', EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, '2', '3', '4', EMPTY, EMPTY],
    [EMPTY, '5', '6', '7', '8', '9', EMPTY],
    [EMPTY, EMPTY, 'A', 'B', 'C', EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, 'D', EMPTY, EMPTY, EMPTY],
    [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
];

const MIDDLE: (usize, usize) = (3, 3);
const MIDDLE_ADVANCED: (usize, usize) = (3, 1);

fn read_file(filepath: &amp;str) -&gt; Vec&lt;String&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let lines = binding
        .split('\n')
        .filter(|c| c.len() &gt; 0)
        .map(|c| c.to_string())
        .collect();
    lines
}

fn step(start: (usize, usize), pad: &amp;[[char; 7]; 7], c: char) -&gt; (usize, usize) {
    let mut pos = start;
    match c {
        'U' =&gt; pos.0 = pos.0 - 1,
        'D' =&gt; pos.0 = pos.0 + 1,
        'L' =&gt; pos.1 = pos.1 - 1,
        'R' =&gt; pos.1 = pos.1 + 1,
        _ =&gt; pos = pos,
    }
    if pad[pos.0][pos.1] != EMPTY {
        return pos;
    }
    start
}

fn move_in_dialpad(start: (usize, usize), pad: &amp;[[char; 7]; 7], line: &amp;str) -&gt; (usize, usize) {
    let mut pos = start;
    for c in line.chars() {
        pos = step(pos, pad, c);
    }
    pos
}

fn part1() {
    let lines = read_file("INPUT");
    let mut code: String = "".to_string();
    let mut pos = MIDDLE;
    for line in lines {
        pos = move_in_dialpad(pos, &amp;DIALPAD, &amp;line);
        code.push(DIALPAD[pos.0][pos.1]);
    }
    println!("Part 1: {}", code);
}

fn part2() {
    let lines = read_file("INPUT");
    let mut code: String = "".to_string();
    let mut pos = MIDDLE_ADVANCED;
    for line in lines {
        pos = move_in_dialpad(pos, &amp;DIALPAD_ADVANCED, &amp;line);
        code.push(DIALPAD_ADVANCED[pos.0][pos.1]);
    }
    println!("Part 2: {}", code);
}

fn main() {
    println!("Year 2016 day 2 - Bathroom Security");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2016-day-3"><a class="header" href="#advent-of-code---year-2016-day-3">Advent of code - Year 2016 Day 3</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2016/day/3">day 3</a>. Go back to year <a href="aoc/2016.html">2016</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-51"><a class="header" href="#information-51">Information</a></h3>
<h4 id="part-1-50"><a class="header" href="#part-1-50">Part 1</a></h4>
<h4 id="part-2-50"><a class="header" href="#part-2-50">Part 2</a></h4>
<h2 id="mainrs-18"><a class="header" href="#mainrs-18">main.rs</a></h2>
<pre><code class="language-rs">use regex::Regex;
use std::fs;

struct Triangle {
    a: i64,
    b: i64,
    c: i64,
}

impl Triangle {
    fn new(a: i64, b: i64, c: i64) -&gt; Self {
        Triangle { a: a, b: b, c: c }
    }
    fn is_valid(&amp;self) -&gt; bool {
        (self.a + self.b &gt; self.c) &amp;&amp; (self.b + self.c &gt; self.a) &amp;&amp; (self.c + self.a &gt; self.b)
    }
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Triangle&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let re = Regex::new(r"([0-9]+)\s+([0-9]+)\s+([0-9]+)").unwrap();
    let mut triangles: Vec&lt;Triangle&gt; = vec![];
    for (_, [a, b, c]) in re.captures_iter(&amp;binding).map(|c| c.extract()) {
        triangles.push(Triangle::new(
            a.parse().unwrap(),
            b.parse().unwrap(),
            c.parse().unwrap(),
        ));
    }
    triangles
}

fn convert_triangles(triangles: &amp;Vec&lt;Triangle&gt;) -&gt; Vec&lt;Triangle&gt; {
    let mut column_triangles: Vec&lt;Triangle&gt; = vec![];
    for (i, _) in triangles.iter().enumerate().step_by(3) {
        column_triangles.push(Triangle::new(
            triangles[i].a,
            triangles[i + 1].a,
            triangles[i + 2].a,
        ));
        column_triangles.push(Triangle::new(
            triangles[i].b,
            triangles[i + 1].b,
            triangles[i + 2].b,
        ));
        column_triangles.push(Triangle::new(
            triangles[i].c,
            triangles[i + 1].c,
            triangles[i + 2].c,
        ));
    }
    column_triangles
}

fn part1() {
    let triangles = read_file("INPUT");
    let res = triangles
        .into_iter()
        .map(|t| if t.is_valid() { 1 } else { 0 })
        .sum::&lt;i64&gt;();
    println!("Part 1: {}", res);
}

fn part2() {
    let triangles = convert_triangles(&amp;read_file("INPUT"));
    let res = triangles
        .into_iter()
        .map(|t| if t.is_valid() { 1 } else { 0 })
        .sum::&lt;i64&gt;();
    println!("Part 2: {}", res);
}

fn main() {
    println!("Year 2016 day 3 - Squares With Three Sides");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2016-day-4"><a class="header" href="#advent-of-code---year-2016-day-4">Advent of code - Year 2016 Day 4</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2016/day/4">day 4</a>. Go back to year <a href="aoc/2016.html">2016</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-52"><a class="header" href="#information-52">Information</a></h3>
<h4 id="part-1-51"><a class="header" href="#part-1-51">Part 1</a></h4>
<p>In the first part we count all alfabet symbols, then sort the ones that have at least some appearance. And lastly match it with the <code>checksum</code>.</p>
<h4 id="part-2-51"><a class="header" href="#part-2-51">Part 2</a></h4>
<p>In the second part we normally shift the alfa by the given <code>id</code> and check if is equal to <code>northpole object storage</code>.</p>
<h2 id="mainrs-19"><a class="header" href="#mainrs-19">main.rs</a></h2>
<pre><code class="language-rs">use regex::Regex;
use std::fs;

const ALFA_LEN: usize = 'z' as usize - 'a' as usize + 1;

struct Room {
    name: String,
    id: i64,
    checksum: String,
}

fn shift_alfa(c: char, shift: i64) -&gt; char {
    ((((c as i64 - 'a' as i64) + shift) % ALFA_LEN as i64) + 'a' as i64) as u8 as char
}

impl Room {
    fn new(name: String, id: i64, checksum: String) -&gt; Self {
        Room {
            name: name,
            id: id,
            checksum: checksum,
        }
    }
    fn is_valid(&amp;self) -&gt; bool {
        let mut counters: [u64; ALFA_LEN] = [0; ALFA_LEN];
        for c in self.name.chars() {
            if c != '-' &amp;&amp; c != ' ' {
                let pos: usize = c as usize - 'a' as usize;
                counters[pos] += 1;
            }
        }
        let mut found: Vec&lt;(u64, char)&gt; = vec![];
        for i in 0..ALFA_LEN {
            if counters[i] &gt; 0 {
                found.push((counters[i], ('a' as u8 + i as u8) as char));
            }
        }
        found.sort_by(|(c1, _), (c2, _)| c2.cmp(&amp;c1));
        let mut cmp: String = "".to_string();
        for f in found {
            cmp.push(f.1);
        }
        cmp[..5] == self.checksum
    }
    fn decrypt(&amp;mut self) {
        let mut builder: String = "".to_string();
        for c in self.name.chars() {
            if c == '-' {
                builder.push(' ');
            } else {
                builder.push(shift_alfa(c, self.id));
            }
        }
        self.name = builder.clone();
    }
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Room&gt; {
    let contents = fs::read_to_string(filepath);
    let mut rooms: Vec&lt;Room&gt; = vec![];
    let binding = contents.expect("REASON");
    let re = Regex::new(r"([a-z\-]+)-([0-9]+)\[([a-z]+)\]").unwrap();
    for (_, [name, id, checksum]) in re.captures_iter(&amp;binding).map(|c| c.extract()) {
        rooms.push(Room::new(
            name.to_string(),
            id.parse().unwrap(),
            checksum.to_string(),
        ));
    }
    rooms
}

fn part1() {
    let rooms = read_file("INPUT");
    let res = rooms
        .into_iter()
        .map(|r| if r.is_valid() { r.id } else { 0 })
        .sum::&lt;i64&gt;();
    println!("Part 1: {}", res);
}

fn part2() {
    let mut rooms = read_file("INPUT");
    let mut res: i64 = 0;
    for room in &amp;mut rooms {
        room.decrypt();
        if room.name == "northpole object storage" {
            res = room.id;
            break;
        }
    }
    println!("Part 2: {}", res);
}

fn main() {
    println!("Year 2016 day 4 - Security Through Obscurity");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015"><a class="header" href="#advent-of-code---year-2015">Advent of code - Year 2015</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2015">year 2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days-6"><a class="header" href="#days-6">Days</a></h3>
<ul>
<li><a href="aoc/2015-1.html">Day 1</a></li>
<li><a href="aoc/2015-2.html">Day 2</a></li>
<li><a href="aoc/2015-3.html">Day 3</a></li>
<li><a href="aoc/2015-4.html">Day 4</a></li>
<li><a href="aoc/2015-5.html">Day 5</a></li>
<li><a href="aoc/2015-6.html">Day 6</a></li>
<li><a href="aoc/2015-7.html">Day 7</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-1"><a class="header" href="#advent-of-code---year-2015-day-1">Advent of code - Year 2015 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/1">day 1</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-53"><a class="header" href="#information-53">Information</a></h3>
<h4 id="part-1-52"><a class="header" href="#part-1-52">Part 1</a></h4>
<p>Simply just go through the list and count the floors.</p>
<h4 id="part-2-52"><a class="header" href="#part-2-52">Part 2</a></h4>
<p>Also just compute the floors and whenever we hit something <code>&lt;0</code> return index.</p>
<h2 id="mainrs-20"><a class="header" href="#mainrs-20">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;

fn read_file(filepath: &amp;str) -&gt; String {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let mut lines = binding.split('\n');
    return lines.next().unwrap().to_string();
}

fn basement(string: &amp;str) -&gt; i64 {
    let mut floor: i64 = 0;
    let mut i: i64 = 0;
    for c in string.chars() {
        i += 1;
        match c {
            '(' =&gt; floor += 1,
            ')' =&gt; floor -= 1,
            _ =&gt; floor = floor,
        }
        if floor &lt; 0 {
            return i;
        }
    }
    -1
}

fn part1() {
    let line = read_file("INPUT");
    let total: i64 = line
        .chars()
        .into_iter()
        .map(|c| if c == '(' { 1 } else { -1 })
        .sum();
    println!("Part 1: {}", total);
}

fn part2() {
    let line = read_file("INPUT");
    println!("Part 2: {}", basement(&amp;line));
}

fn main() {
    println!("Year 2015 day 01 - Not Quite Lisp");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-2"><a class="header" href="#advent-of-code---year-2015-day-2">Advent of code - Year 2015 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/2">day 2</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-54"><a class="header" href="#information-54">Information</a></h3>
<h4 id="part-1-53"><a class="header" href="#part-1-53">Part 1</a></h4>
<p>We simply compute the given formula.</p>
<h4 id="part-2-53"><a class="header" href="#part-2-53">Part 2</a></h4>
<p>Also just usage of the given formula.</p>
<h2 id="mainrs-21"><a class="header" href="#mainrs-21">main.rs</a></h2>
<pre><code class="language-rs">use std::cmp::min;
use std::fs;

struct Sizes {
    h: i64,
    w: i64,
    l: i64,
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Sizes&gt; {
    let contents = fs::read_to_string(filepath);
    let mut boxes: Vec&lt;Sizes&gt; = vec![];
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    for line in lines {
        if line == "" {
            continue;
        }
        let mut parts = line.split('x');
        let l = i64::from_str_radix(parts.next().unwrap(), 10).unwrap();
        let w = i64::from_str_radix(parts.next().unwrap(), 10).unwrap();
        let h = i64::from_str_radix(parts.next().unwrap(), 10).unwrap();
        boxes.push(Sizes { h: h, l: l, w: w });
    }
    return boxes;
}

fn wrapping_size(boxes: &amp;Vec&lt;Sizes&gt;) -&gt; i64 {
    let mut total: i64 = 0;
    for b in boxes {
        let area = 2 * b.l * b.w + 2 * b.l * b.h + 2 * b.h * b.w;
        let addition = min(min(b.l * b.w, b.l * b.h), b.h * b.w);
        total += area + addition;
    }
    total
}

fn ribbon_len(boxes: &amp;Vec&lt;Sizes&gt;) -&gt; i64 {
    let mut total: i64 = 0;
    for b in boxes {
        let bow = b.l * b.w * b.h;
        let mut ribbon = 0;
        if b.h &lt;= b.w &amp;&amp; b.h &lt;= b.l {
            ribbon += 2 * b.h + 2 * min(b.w, b.l);
        } else if b.w &lt;= b.h &amp;&amp; b.w &lt;= b.l {
            ribbon += 2 * b.w + 2 * min(b.h, b.l);
        } else {
            ribbon += 2 * b.l + 2 * min(b.w, b.h);
        }
        total += bow + ribbon;
    }
    total
}

fn part1() {
    let boxes = read_file("INPUT");
    println!("Part 1: {}", wrapping_size(&amp;boxes));
}

fn part2() {
    let boxes = read_file("INPUT");
    println!("Part 2: {}", ribbon_len(&amp;boxes));
}

fn main() {
    println!("Year 2015 day 02 - I Was Told There Would Be No Math");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-3"><a class="header" href="#advent-of-code---year-2015-day-3">Advent of code - Year 2015 Day 3</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/3">day 3</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-55"><a class="header" href="#information-55">Information</a></h3>
<h4 id="part-1-54"><a class="header" href="#part-1-54">Part 1</a></h4>
<p>In the first part we remember in a set whihc positins were visited and count the size of the set.</p>
<h4 id="part-2-54"><a class="header" href="#part-2-54">Part 2</a></h4>
<p>In the second part we only swap these values every time and after that we do the same thing. So we switch the santas.</p>
<h2 id="mainrs-22"><a class="header" href="#mainrs-22">main.rs</a></h2>
<pre><code class="language-rs">use std::collections::HashSet;
use std::fs;

type Pos = (i64, i64);
type Houses = HashSet&lt;Pos&gt;;

fn read_file(filepath: &amp;str) -&gt; String {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    binding.split('\n').next().unwrap().to_string()
}

fn found_houses(line: &amp;str, robo_santa: bool) -&gt; usize {
    let mut houses: Houses = HashSet::new();
    let mut pos: Pos = (0, 0);
    let mut robo_pos: Pos = (0, 0);
    houses.insert(pos);
    for c in line.chars() {
        match c {
            '&gt;' =&gt; pos = (pos.0, pos.1 + 1),
            '&lt;' =&gt; pos = (pos.0, pos.1 - 1),
            'v' =&gt; pos = (pos.0 + 1, pos.1),
            '^' =&gt; pos = (pos.0 - 1, pos.1),
            _ =&gt; pos = pos,
        }
        houses.insert(pos);
        if robo_santa {
            (pos, robo_pos) = (robo_pos, pos);
        }
    }
    houses.len()
}

fn part1() {
    let line = read_file("INPUT");
    println!("Part 1: {}", found_houses(&amp;line, false));
}

fn part2() {
    let line = read_file("INPUT");
    println!("Part 2: {}", found_houses(&amp;line, true));
}

fn main() {
    println!("Year 2015 day 3 - Perfectly Spherical Houses in a Vacuum");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-4"><a class="header" href="#advent-of-code---year-2015-day-4">Advent of code - Year 2015 Day 4</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/4">day 4</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-56"><a class="header" href="#information-56">Information</a></h3>
<h4 id="part-1-55"><a class="header" href="#part-1-55">Part 1</a></h4>
<p>First of all we import <code>md-5</code> library to compute the hashes. Then simply compute the hashses of <code>key</code> appended by iterating indexes.</p>
<h4 id="part-2-55"><a class="header" href="#part-2-55">Part 2</a></h4>
<p>The second part is same only we check six zeros.</p>
<h2 id="mainrs-23"><a class="header" href="#mainrs-23">main.rs</a></h2>
<pre><code class="language-rs">use md5::{Digest, Md5};
use std::fs;

fn read_file(filepath: &amp;str) -&gt; String {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    binding.split('\n').next().unwrap().to_string()
}

fn prefix_md5(origin: &amp;str, eq: &amp;str) -&gt; u64 {
    let mut i: u64 = 0;
    loop {
        let input = format!("{}{}", origin, i);
        let mut hasher = Md5::new();
        hasher.update(input);
        let result = hasher.finalize();
        let hash_string = format!("{:x}", result);
        if hash_string[0..eq.len()] == eq.to_string() {
            break;
        }
        i += 1;
    }
    i
}

fn part1() {
    let origin = read_file("INPUT");
    println!("Part 1: {}", prefix_md5(&amp;origin, "00000"));
}

fn part2() {
    let origin = read_file("INPUT");
    println!("Part 2: {}", prefix_md5(&amp;origin, "000000"));
}

fn main() {
    println!("Year 2015 day 4 - The Ideal Stocking Stuffer");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-5"><a class="header" href="#advent-of-code---year-2015-day-5">Advent of code - Year 2015 Day 5</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/5">day 5</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-57"><a class="header" href="#information-57">Information</a></h3>
<h4 id="part-1-56"><a class="header" href="#part-1-56">Part 1</a></h4>
<p>For the first part we only need to configure the right regexes to represent each type. And than either mathc them or count them.</p>
<h4 id="part-2-56"><a class="header" href="#part-2-56">Part 2</a></h4>
<p>The second part is similiar only we use different regexes.</p>
<h2 id="mainrs-24"><a class="header" href="#mainrs-24">main.rs</a></h2>
<pre><code class="language-rs">use fancy_regex::Regex as Rgx;
use regex::Regex;
use std::fs;

fn read_file(filepath: &amp;str) -&gt; Vec&lt;String&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let lines = binding
        .split('\n')
        .filter(|c| c.len() &gt; 0)
        .map(|c| c.to_string())
        .collect();
    lines
}

fn nice_string(lines: &amp;Vec&lt;String&gt;) -&gt; u64 {
    let mut total: u64 = 0;
    let vowels = Regex::new(r"a|e|i|o|u").unwrap();
    let pairs = Rgx::new(r"([a-z])\1").unwrap();
    let forb = Regex::new(r"ab|cd|pq|xy").unwrap();
    for line in lines {
        let nr_vowels = vowels.captures_iter(&amp;line).count();
        let exists_pairs = pairs.is_match(&amp;line).unwrap();
        let nr_forb = forb.captures_iter(&amp;line).count();
        if nr_vowels &gt;= 3 &amp;&amp; exists_pairs &amp;&amp; nr_forb &lt;= 0 {
            total += 1;
        }
    }
    total
}

fn nicer_string(lines: &amp;Vec&lt;String&gt;) -&gt; u64 {
    let mut total: u64 = 0;
    let pairs = Rgx::new(r"([a-z]{2}).*\1").unwrap();
    let middle = Rgx::new(r"([a-z])[a-z]\1").unwrap();
    for line in lines {
        let is_pair = pairs.is_match(&amp;line).unwrap();
        let is_middle = middle.is_match(&amp;line).unwrap();
        if is_pair &amp;&amp; is_middle {
            total += 1;
        }
    }
    total
}

fn part1() {
    let lines = read_file("INPUT");
    println!("Part 1: {}", nice_string(&amp;lines));
}

fn part2() {
    let lines = read_file("INPUT");
    println!("Part 2: {}", nicer_string(&amp;lines));
}

fn main() {
    println!("Year 2015 day 5 - Doesn't He Have Intern-Elves For This?");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-6"><a class="header" href="#advent-of-code---year-2015-day-6">Advent of code - Year 2015 Day 6</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/6">day 6</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-58"><a class="header" href="#information-58">Information</a></h3>
<h4 id="part-1-57"><a class="header" href="#part-1-57">Part 1</a></h4>
<p>We simply follow the given instructions on the <code>1000x1000</code> grid. Then compute those which are <code>true</code>.</p>
<h4 id="part-2-57"><a class="header" href="#part-2-57">Part 2</a></h4>
<p>In the second part we redefine the instructions and compute the sum.</p>
<h2 id="mainrs-25"><a class="header" href="#mainrs-25">main.rs</a></h2>
<pre><code class="language-rs">use regex::Regex;
use std::fs;

type Grid&lt;T&gt; = Vec&lt;Vec&lt;T&gt;&gt;;
type Pos = (usize, usize);

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd)]
enum InstructionType {
    TurnOff,
    TurnOn,
    Toggle,
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd)]
struct Instruction {
    start: Pos,
    end: Pos,
    instr_type: InstructionType,
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Instruction&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let mut instructions: Vec&lt;Instruction&gt; = vec![];
    let input =
        Regex::new(r"(turn off|turn on|toggle) ([0-9]+),([0-9]+) through ([0-9]+),([0-9]+)")
            .unwrap();
    for (_, [ty, s1, s2, e1, e2]) in input.captures_iter(&amp;binding).map(|c| c.extract()) {
        let instr_type: InstructionType;
        if ty == "turn off" {
            instr_type = InstructionType::TurnOff;
        } else if ty == "turn on" {
            instr_type = InstructionType::TurnOn;
        } else {
            instr_type = InstructionType::Toggle;
        }
        instructions.push(Instruction {
            instr_type: instr_type,
            start: (s1.parse().unwrap(), s2.parse().unwrap()),
            end: (e1.parse().unwrap(), e2.parse().unwrap()),
        });
    }
    instructions
}

fn part1() {
    let instructions = read_file("INPUT");
    let mut grid: Grid&lt;bool&gt; = vec![vec!(false; 1000); 1000];
    for ins in instructions {
        match ins.instr_type {
            InstructionType::Toggle =&gt; {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] = !grid[i][j];
                    }
                }
            }
            InstructionType::TurnOff =&gt; {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] = false;
                    }
                }
            }
            InstructionType::TurnOn =&gt; {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] = true;
                    }
                }
            }
        }
    }
    let lit_up: u64 = grid
        .into_iter()
        .map(|vec| vec.into_iter().map(|x| if x { 1 } else { 0 }).sum::&lt;u64&gt;())
        .sum();
    println!("Part 1: {}", lit_up);
}

fn part2() {
    let instructions = read_file("INPUT");
    let mut grid: Grid&lt;u64&gt; = vec![vec!(0_u64; 1000); 1000];
    for ins in instructions {
        match ins.instr_type {
            InstructionType::Toggle =&gt; {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] += 2;
                    }
                }
            }
            InstructionType::TurnOff =&gt; {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] = if grid[i][j] &gt; 0 {
                            grid[i][j] - 1
                        } else {
                            grid[i][j]
                        };
                    }
                }
            }
            InstructionType::TurnOn =&gt; {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] += 1;
                    }
                }
            }
        }
    }
    let lit_up: u64 = grid
        .into_iter()
        .map(|vec| vec.into_iter().sum::&lt;u64&gt;())
        .sum();
    println!("Part 2: {}", lit_up);
}

fn main() {
    println!("Year 2015 day 6 - Probably a Fire Hazard");
    part1();
    part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-7"><a class="header" href="#advent-of-code---year-2015-day-7">Advent of code - Year 2015 Day 7</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/7">day 7</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="information-59"><a class="header" href="#information-59">Information</a></h3>
<h4 id="part-1-58"><a class="header" href="#part-1-58">Part 1</a></h4>
<h4 id="part-2-58"><a class="header" href="#part-2-58">Part 2</a></h4>
<h2 id="mainrs-26"><a class="header" href="#mainrs-26">main.rs</a></h2>
<pre><code class="language-rs">use regex::Regex;
use std::collections::HashMap;
use std::fs;
use std::option::Option;

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
enum GateType {
    Or,
    And,
    LShift,
    RShift,
    Not,
    Simple,
}

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
struct Gate {
    inputs: [String; 2],
    gate_type: GateType,
    output: String,
}

impl Gate {
    fn eval(&amp;self, assigned: &amp;mut HashMap&lt;String, u16&gt;) {
        let mut first: u16 = 0;
        let mut second: u16 = 0;
        match get_number(&amp;self.inputs[0], assigned) {
            Some(nr) =&gt; first = nr,
            None =&gt; return,
        }
        match get_number(&amp;self.inputs[1], assigned) {
            Some(nr) =&gt; second = nr,
            None =&gt; return,
        }
        match self.gate_type {
            GateType::Or =&gt; assigned.insert(self.output.clone(), first | second),
            GateType::And =&gt; assigned.insert(self.output.clone(), first &amp; second),
            GateType::LShift =&gt; assigned.insert(self.output.clone(), first &lt;&lt; second),
            GateType::RShift =&gt; assigned.insert(self.output.clone(), first &gt;&gt; second),
            GateType::Not =&gt; assigned.insert(self.output.clone(), !first),
            GateType::Simple =&gt; assigned.insert(self.output.clone(), first),
        };
    }
}

fn get_number(written: &amp;str, assigned: &amp;HashMap&lt;String, u16&gt;) -&gt; Option&lt;u16&gt; {
    if assigned.contains_key(written) {
        return Some(assigned[written]);
    } else if written.chars().nth(0)?.is_digit(10) {
        return Some(written.parse::&lt;u16&gt;().unwrap());
    }
    None
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Gate&gt; {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let mut gates: Vec&lt;Gate&gt; = vec![];
    let bin_re = Regex::new(r"([^\s]+) (OR|AND|LSHIFT|RSHIFT) ([^\s]+) -&gt; (.+)").unwrap();
    let not_re = Regex::new(r"NOT ([^\s]+) -&gt; (.+)").unwrap();
    let simple_re = Regex::new(r"\n([^\s]+) -&gt; (.+)").unwrap();
    for (_, [first, oper, second, res]) in bin_re.captures_iter(&amp;binding).map(|c| c.extract()) {
        let operator: GateType;
        match oper {
            "OR" =&gt; operator = GateType::Or,
            "AND" =&gt; operator = GateType::And,
            "LSHIFT" =&gt; operator = GateType::LShift,
            "RSHIFT" =&gt; operator = GateType::RShift,
            _ =&gt; todo!(),
        }
        gates.push(Gate {
            inputs: [first.to_string(), second.to_string()],
            gate_type: operator,
            output: res.to_string(),
        });
    }
    for (_, [first, res]) in not_re.captures_iter(&amp;binding).map(|c| c.extract()) {
        gates.push(Gate {
            inputs: [first.to_string(), "".to_string()],
            gate_type: GateType::Not,
            output: res.to_string(),
        });
    }
    for (_, [first, res]) in simple_re.captures_iter(&amp;binding).map(|c| c.extract()) {
        gates.push(Gate {
            inputs: [first.to_string(), "".to_string()],
            gate_type: GateType::Simple,
            output: res.to_string(),
        });
    }
    gates
}

fn part1() {
    let gates = read_file("INPUT");
    let mut assigned: HashMap&lt;String, u16&gt; = HashMap::new();
    assigned.insert("".to_string(), 0);
    while !assigned.contains_key("a") {
        for gate in &amp;gates {
            gate.eval(&amp;mut assigned);
        }
    }
    println!("Part 1: {}", assigned["a"]);
}

fn part2() {
    println!("Part 2: {}", 0);
}

fn main() {
    println!("Year 2015 day 7 - Some Assembly Required");
    part1();
    part2();
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
