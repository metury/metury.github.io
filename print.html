<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Personal page</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Welcome page</a></li><li class="chapter-item affix "><li class="part-title">Main pages</li><li class="chapter-item "><a href="about.html"><strong aria-hidden="true">1.</strong> About</a></li><li class="chapter-item "><a href="mff.html"><strong aria-hidden="true">2.</strong> Matfyz</a></li><li class="chapter-item "><a href="projects.html"><strong aria-hidden="true">3.</strong> Projects</a></li><li class="chapter-item affix "><li class="part-title">Programming exercises</li><li class="chapter-item "><a href="programming.html"><strong aria-hidden="true">4.</strong> Sandbox</a></li><li class="chapter-item "><a href="exercises.html"><strong aria-hidden="true">5.</strong> Exercises</a></li><li class="chapter-item affix "><li class="part-title">Tenerife</li><li class="chapter-item "><a href="tenerife.html"><strong aria-hidden="true">6.</strong> Tenerife</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tenerife/travel.html"><strong aria-hidden="true">6.1.</strong> Cesta</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tenerife/items.html"><strong aria-hidden="true">6.1.1.</strong> Věci s sebou</a></li><li class="chapter-item "><a href="tenerife/flight.html"><strong aria-hidden="true">6.1.2.</strong> Let</a></li><li class="chapter-item "><a href="tenerife/cars-buses.html"><strong aria-hidden="true">6.1.3.</strong> Pohyb po ostrově</a></li></ol></li><li class="chapter-item "><a href="tenerife/tracks-places.html"><strong aria-hidden="true">6.2.</strong> Trasy a místa</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tenerife/nature.html"><strong aria-hidden="true">6.2.1.</strong> Příroda</a></li><li class="chapter-item "><a href="tenerife/towns.html"><strong aria-hidden="true">6.2.2.</strong> Města</a></li><li class="chapter-item "><a href="tenerife/playas.html"><strong aria-hidden="true">6.2.3.</strong> Pláže a bazény</a></li><li class="chapter-item "><a href="tenerife/extra.html"><strong aria-hidden="true">6.2.4.</strong> Další aktivity</a></li></ol></li><li class="chapter-item "><a href="tenerife/weather.html"><strong aria-hidden="true">6.3.</strong> Počasí</a></li><li class="chapter-item "><a href="tenerife/surroundings.html"><strong aria-hidden="true">6.4.</strong> Okolí Costa del Silencio</a></li></ol></li><li class="chapter-item "><li class="part-title">Miscellaneous</li><li class="chapter-item "><a href="boot.html"><strong aria-hidden="true">7.</strong> Boot</a></li><li class="chapter-item "><a href="dezinfo.html"><strong aria-hidden="true">8.</strong> (Dez)Informace</a></li><li class="chapter-item "><a href="movies.html"><strong aria-hidden="true">9.</strong> Movie list</a></li><li class="chapter-item "><a href="library.html"><strong aria-hidden="true">10.</strong> Books</a></li><li class="chapter-item affix "><li class="part-title">Advent of code</li><li class="chapter-item "><a href="adventofcode.html"><strong aria-hidden="true">11.</strong> Advent of code</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="aoc/2015.html"><strong aria-hidden="true">11.1.</strong> Year 2015</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="aoc/2015-1.html"><strong aria-hidden="true">11.1.1.</strong> Year 2015 day 1</a></li><li class="chapter-item "><a href="aoc/2015-2.html"><strong aria-hidden="true">11.1.2.</strong> Year 2015 day 2</a></li><li class="chapter-item "><a href="aoc/2015-3.html"><strong aria-hidden="true">11.1.3.</strong> Year 2015 day 3</a></li><li class="chapter-item "><a href="aoc/2015-4.html"><strong aria-hidden="true">11.1.4.</strong> Year 2015 day 4</a></li><li class="chapter-item "><a href="aoc/2015-5.html"><strong aria-hidden="true">11.1.5.</strong> Year 2015 day 5</a></li><li class="chapter-item "><a href="aoc/2015-6.html"><strong aria-hidden="true">11.1.6.</strong> Year 2015 day 6</a></li><li class="chapter-item "><a href="aoc/2015-7.html"><strong aria-hidden="true">11.1.7.</strong> Year 2015 day 7</a></li></ol></li><li class="chapter-item "><a href="aoc/2016.html"><strong aria-hidden="true">11.2.</strong> Year 2016</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="aoc/2016-1.html"><strong aria-hidden="true">11.2.1.</strong> Year 2016 day 1</a></li><li class="chapter-item "><a href="aoc/2016-2.html"><strong aria-hidden="true">11.2.2.</strong> Year 2016 day 2</a></li><li class="chapter-item "><a href="aoc/2016-3.html"><strong aria-hidden="true">11.2.3.</strong> Year 2016 day 3</a></li><li class="chapter-item "><a href="aoc/2016-4.html"><strong aria-hidden="true">11.2.4.</strong> Year 2016 day 4</a></li></ol></li><li class="chapter-item "><a href="aoc/2017.html"><strong aria-hidden="true">11.3.</strong> Year 2017</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="aoc/2017-1.html"><strong aria-hidden="true">11.3.1.</strong> Year 2017 day 1</a></li><li class="chapter-item "><a href="aoc/2017-2.html"><strong aria-hidden="true">11.3.2.</strong> Year 2017 day 2</a></li></ol></li><li class="chapter-item "><a href="aoc/2021.html"><strong aria-hidden="true">11.4.</strong> Year 2021</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="aoc/2021-1.html"><strong aria-hidden="true">11.4.1.</strong> Year 2021 day 1</a></li><li class="chapter-item "><a href="aoc/2021-2.html"><strong aria-hidden="true">11.4.2.</strong> Year 2021 day 2</a></li><li class="chapter-item "><a href="aoc/2021-3.html"><strong aria-hidden="true">11.4.3.</strong> Year 2021 day 3</a></li><li class="chapter-item "><a href="aoc/2021-4.html"><strong aria-hidden="true">11.4.4.</strong> Year 2021 day 4</a></li><li class="chapter-item "><a href="aoc/2021-5.html"><strong aria-hidden="true">11.4.5.</strong> Year 2021 day 5</a></li><li class="chapter-item "><a href="aoc/2021-6.html"><strong aria-hidden="true">11.4.6.</strong> Year 2021 day 6</a></li><li class="chapter-item "><a href="aoc/2021-7.html"><strong aria-hidden="true">11.4.7.</strong> Year 2021 day 7</a></li><li class="chapter-item "><a href="aoc/2021-8.html"><strong aria-hidden="true">11.4.8.</strong> Year 2021 day 8</a></li><li class="chapter-item "><a href="aoc/2021-11.html"><strong aria-hidden="true">11.4.9.</strong> Year 2021 day 11</a></li><li class="chapter-item "><a href="aoc/2021-14.html"><strong aria-hidden="true">11.4.10.</strong> Year 2021 day 14</a></li></ol></li><li class="chapter-item "><a href="aoc/2022.html"><strong aria-hidden="true">11.5.</strong> Year 2022</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="aoc/2022-1.html"><strong aria-hidden="true">11.5.1.</strong> Year 2022 day 1</a></li><li class="chapter-item "><a href="aoc/2022-2.html"><strong aria-hidden="true">11.5.2.</strong> Year 2022 day 2</a></li><li class="chapter-item "><a href="aoc/2022-3.html"><strong aria-hidden="true">11.5.3.</strong> Year 2022 day 3</a></li><li class="chapter-item "><a href="aoc/2022-4.html"><strong aria-hidden="true">11.5.4.</strong> Year 2022 day 4</a></li><li class="chapter-item "><a href="aoc/2022-5.html"><strong aria-hidden="true">11.5.5.</strong> Year 2022 day 5</a></li><li class="chapter-item "><a href="aoc/2022-6.html"><strong aria-hidden="true">11.5.6.</strong> Year 2022 day 6</a></li><li class="chapter-item "><a href="aoc/2022-7.html"><strong aria-hidden="true">11.5.7.</strong> Year 2022 day 7</a></li><li class="chapter-item "><a href="aoc/2022-8.html"><strong aria-hidden="true">11.5.8.</strong> Year 2022 day 8</a></li><li class="chapter-item "><a href="aoc/2022-9.html"><strong aria-hidden="true">11.5.9.</strong> Year 2022 day 9</a></li><li class="chapter-item "><a href="aoc/2022-11.html"><strong aria-hidden="true">11.5.10.</strong> Year 2022 day 11</a></li><li class="chapter-item "><a href="aoc/2022-12.html"><strong aria-hidden="true">11.5.11.</strong> Year 2022 day 12</a></li><li class="chapter-item "><a href="aoc/2022-13.html"><strong aria-hidden="true">11.5.12.</strong> Year 2022 day 13</a></li><li class="chapter-item "><a href="aoc/2022-14.html"><strong aria-hidden="true">11.5.13.</strong> Year 2022 day 14</a></li><li class="chapter-item "><a href="aoc/2022-15.html"><strong aria-hidden="true">11.5.14.</strong> Year 2022 day 15</a></li></ol></li><li class="chapter-item "><a href="aoc/2023.html"><strong aria-hidden="true">11.6.</strong> Year 2023</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="aoc/2023-1.html"><strong aria-hidden="true">11.6.1.</strong> Year 2023 day 1</a></li><li class="chapter-item "><a href="aoc/2023-2.html"><strong aria-hidden="true">11.6.2.</strong> Year 2023 day 2</a></li><li class="chapter-item "><a href="aoc/2023-3.html"><strong aria-hidden="true">11.6.3.</strong> Year 2023 day 3</a></li><li class="chapter-item "><a href="aoc/2023-4.html"><strong aria-hidden="true">11.6.4.</strong> Year 2023 day 4</a></li><li class="chapter-item "><a href="aoc/2023-5.html"><strong aria-hidden="true">11.6.5.</strong> Year 2023 day 5</a></li><li class="chapter-item "><a href="aoc/2023-6.html"><strong aria-hidden="true">11.6.6.</strong> Year 2023 day 6</a></li><li class="chapter-item "><a href="aoc/2023-7.html"><strong aria-hidden="true">11.6.7.</strong> Year 2023 day 7</a></li><li class="chapter-item "><a href="aoc/2023-8.html"><strong aria-hidden="true">11.6.8.</strong> Year 2023 day 8</a></li><li class="chapter-item "><a href="aoc/2023-9.html"><strong aria-hidden="true">11.6.9.</strong> Year 2023 day 9</a></li><li class="chapter-item "><a href="aoc/2023-11.html"><strong aria-hidden="true">11.6.10.</strong> Year 2023 day 11</a></li><li class="chapter-item "><a href="aoc/2023-12.html"><strong aria-hidden="true">11.6.11.</strong> Year 2023 day 12</a></li><li class="chapter-item "><a href="aoc/2023-13.html"><strong aria-hidden="true">11.6.12.</strong> Year 2023 day 13</a></li><li class="chapter-item "><a href="aoc/2023-14.html"><strong aria-hidden="true">11.6.13.</strong> Year 2023 day 14</a></li><li class="chapter-item "><a href="aoc/2023-15.html"><strong aria-hidden="true">11.6.14.</strong> Year 2023 day 15</a></li><li class="chapter-item "><a href="aoc/2023-16.html"><strong aria-hidden="true">11.6.15.</strong> Year 2023 day 16</a></li><li class="chapter-item "><a href="aoc/2023-17.html"><strong aria-hidden="true">11.6.16.</strong> Year 2023 day 17</a></li><li class="chapter-item "><a href="aoc/2023-18.html"><strong aria-hidden="true">11.6.17.</strong> Year 2023 day 18</a></li><li class="chapter-item "><a href="aoc/2023-19.html"><strong aria-hidden="true">11.6.18.</strong> Year 2023 day 19</a></li><li class="chapter-item "><a href="aoc/2023-21.html"><strong aria-hidden="true">11.6.19.</strong> Year 2023 day 21</a></li><li class="chapter-item "><a href="aoc/2023-22.html"><strong aria-hidden="true">11.6.20.</strong> Year 2023 day 22</a></li><li class="chapter-item "><a href="aoc/2023-23.html"><strong aria-hidden="true">11.6.21.</strong> Year 2023 day 23</a></li><li class="chapter-item "><a href="aoc/2023-24.html"><strong aria-hidden="true">11.6.22.</strong> Year 2023 day 24</a></li><li class="chapter-item "><a href="aoc/2023-25.html"><strong aria-hidden="true">11.6.23.</strong> Year 2023 day 25</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Personal page</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-my-personal-page"><a class="header" href="#welcome-to-my-personal-page">Welcome, to my personal page.</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::vec;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut interests : Vec&lt;&amp;str&gt; = vec!["Computer science",
                                         "Travel",
                                         "Music",
                                         "Movies"];

    println!("Welcome to my personal webpage.");
    println!("");
    println!("Here you may find some things I enjoy or do.");

    for int in &amp;interests {
        println!("\t- {}", int);
    }

    interests.push("Advent of code");

    println!("And also I cannot forget: {}", interests[interests.len() - 1]);

    let url = "github.com/metury/metury.github.io";
    let tools = vec!["Github pages", "MdBook"];

    println!("");
    println!("Source of this page can be found at the link: {}", url);
    println!("");
    println!("For the proper usecase I used {}.", tools.join(" and "));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="about-this-page"><a class="header" href="#about-this-page">About this page</a></h2>
<p>This is my own personal page. Feel free to see the pages.</p>
<h2 id="about-me"><a class="header" href="#about-me">About me</a></h2>
<p>I am a student at Charles University studying computer science. My CV can be found here:</p>
<ul>
<li><a href="./resources/CV_cs.pdf">Životopis</a></li>
<li><a href="./resources/CV_en.pdf">Resumé</a></li>
</ul>
<p>Also I am great fan of <a href="/adventofcode.html">Advent of Code</a> and I have all my (partial) solutions listed here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matfyz"><a class="header" href="#matfyz">Matfyz</a></h1>
<p>Tady je menší rozcestník pro matfyzácké věci. Jak už moje zápisky nebo odkazy na předměty, které mám zapsané.</p>
<h2 id="zápisky"><a class="header" href="#zápisky">Zápisky</a></h2>
<p>Občas stihnu sepsat nějaké zápisky z přednášky a pokud stojí (aspoň trochu) za to, tak se tady budou nacházet. Veškeré texty lze najív v repozitáři na <a href="https://github.com/metury/notes">GitHubu</a>.</p>
<ul>
<li><a href="./mff/fpc.pdf">Flows, paths and cuts</a></li>
<li><a href="./mff/grg.pdf">Geometric Representations of Graphs</a></li>
<li><a href="./mff/kg.pdf">Kombinatorika a grafy</a></li>
<li><a href="./mff/past-ii.pdf">Probability and statistics 2</a></li>
<li><a href="./mff/polyhedra.pdf">Polyhedral combinatorics</a></li>
<li><a href="./mff/temno.pdf">Teorie množin</a></li>
<li><a href="./mff/vybrane-kapitoly-kg.pdf">Vybrané kapitoly z kombinatoriky (not finished yet)</a></li>
</ul>
<h2 id="odkazy-na-předměty"><a class="header" href="#odkazy-na-předměty">Odkazy na předměty</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Předmět</th><th style="text-align: center">Odkazy</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>2425 - Zimní semestr</strong></td><td style="text-align: center"><strong>--</strong></td></tr>
<tr><td style="text-align: center">Constraint programming</td><td style="text-align: center"><a href="https://ktiml.mff.cuni.cz/~bartak/podminky/">Web</a> <a href="https://jbulin.github.io/teaching/fall/nopt042/">Cvičení</a> <a href="https://picat-lang.org/download/picat_guide.pdf">Picat Docs</a></td></tr>
<tr><td style="text-align: center">Introduction to Parameterized Algorithms</td><td style="text-align: center"><a href="https://research.koutecky.name/db/teaching:intro_par_alg2324">Web</a> <a href="https://www.mimuw.edu.pl/~malcin/book/parameterized-algorithms.pdf">Kniha</a> <a href="https://iuuk.mff.cuni.cz/~tung/teaching/fpt-ws2324/">Cvičení</a></td></tr>
<tr><td style="text-align: center">Programování v jazyce Rust</td><td style="text-align: center"><a href="https://d3s.mff.cuni.cz/teaching/nprg082/">Web</a></td></tr>
<tr><td style="text-align: center">Vybrané kapitoly z kombinatoriky 1</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Základy teorie kategorií</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Úvod do teorie čísel</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~klazar/UTC24.html">Web</a></td></tr>
<tr><td style="text-align: center"><strong>2324 - Letní semestr</strong></td><td style="text-align: center"><strong>--</strong></td></tr>
<tr><td style="text-align: center">Teorie Matroidů</td><td style="text-align: center"><a href="https://iuuk.mff.cuni.cz/~pangrac/vyuka/">Web</a> <a href="https://kam.mff.cuni.cz/~cerny/teach/23-24/matroids.html">Cviceni</a></td></tr>
<tr><td style="text-align: center">Datove struktury 2</td><td style="text-align: center"><a href="https://mj.ucw.cz/vyuka/2324/ds2/">Web</a> <a href="https://mj.ucw.cz/vyuka/dsnotes/ds.pdf">Skripta</a></td></tr>
<tr><td style="text-align: center">Matematické programování a polyedrální kombinatorika</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~kolman/matprog23.html">Web</a> <a href="https://iti.mff.cuni.cz/series/2013/601.pdf">úkol</a></td></tr>
<tr><td style="text-align: center">Matematické struktury</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~klazar/MSTR24.html">Web</a></td></tr>
<tr><td style="text-align: center">Grafové minory a stromové dekompozice</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~fiala/index.shtml.cs">Web</a> <a href="https://kam.mff.cuni.cz/~fiala/tw.pdf">Skripta</a></td></tr>
<tr><td style="text-align: center">Grafové algoritmy 2</td><td style="text-align: center"><a href="https://mj.ucw.cz/vyuka/2324/ga2/">Web</a> <a href="https://mj.ucw.cz/vyuka/ga/ga.pdf">Skripta</a> a <a href="http://adambuchsbaum.com/papers/ptrs-stoc98.pdf">Linear-Time Pointer-Machine Algorithms </a></td></tr>
<tr><td style="text-align: center">Geometrická reprezentace grafů 2</td><td style="text-align: center"><a href="https://dl1.cuni.cz/course/view.php?id=16103">Moodle</a></td></tr>
<tr><td style="text-align: center"><strong>2324 - Zimní semestr</strong></td><td style="text-align: center"><strong>--</strong></td></tr>
<tr><td style="text-align: center"><del>Pravděpodobnostní techniky</del></td><td style="text-align: center"><del><a href="https://kam.mff.cuni.cz/~tyomkyn/teaching/PT/PT.html">Web</a> <a href="https://www.cs.cmu.edu/~15850/handouts/matousek-vondrak-prob-ln.pdf">Skripta</a> <a href="https://kam.mff.cuni.cz/~dbulavka/teaching/ws2324/pt.html">Úkoly</a></del></td></tr>
<tr><td style="text-align: center">Barevnost grafů</td><td style="text-align: center"><a href="https://iuuk.mff.cuni.cz/~rakdver/index.php?which=uceni&amp;subject=bar">Web</a></td></tr>
<tr><td style="text-align: center">Geometrická reprezentace grafů</td><td style="text-align: center"><a href="https://is.cuni.cz/studium/predmety/index.php?id=b1110fec60a34e4c9eff4fbd6f73920d&amp;tid=&amp;do=predmet&amp;kod=NDMI037&amp;skr=2023&amp;fak=11320">Zápisky na SISu</a></td></tr>
<tr><td style="text-align: center">Datove struktury</td><td style="text-align: center"><a href="https://mj.ucw.cz/vyuka/2324/ds1/">Web</a> <a href="https://mj.ucw.cz/vyuka/dsnotes/ds.pdf">Skripta</a></td></tr>
<tr><td style="text-align: center">Základy složitosti a vyčíslitelnosti</td><td style="text-align: center"><a href="https://ktiml.mff.cuni.cz/~kucerap/NTIN090/NTIN090-poznamky.pdf">Skripta</a> <a href="https://kti.mff.cuni.cz/~maj/">Cvičení</a> <a href="https://dl1.cuni.cz/course/view.php?id=10131">Moodle</a></td></tr>
<tr><td style="text-align: center">Grafové algoritmy</td><td style="text-align: center"><a href="https://mj.ucw.cz/vyuka/2324/ga/">Web</a> <a href="https://mj.ucw.cz/vyuka/ga/ga.pdf">Skripta</a> a <a href="%5B90%5D(https://mj.ucw.cz/papers/saga/saga.pdf#page=90)">ET</a></td></tr>
<tr><td style="text-align: center">Kombinatorika a grafy 3</td><td style="text-align: center"><a href="https://iuuk.mff.cuni.cz/~rakdver/index.php?which=uceni&amp;subject=kg3">Web</a> <a href="http://gaubian.xyz/">úkoly</a></td></tr>
<tr><td style="text-align: center">Intervalove metody</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~hladik/IA/">Web</a> <a href="https://kam.mff.cuni.cz/~hladik/IA/text_ia.pdf">Skripta</a></td></tr>
<tr><td style="text-align: center">Toky, cesty a řezy</td><td style="text-align: center"><a href="https://kam.mff.cuni.cz/~kolman/tokyrezy23.html">Web</a></td></tr>
</tbody></table>
</div>
<h2 id="další-užitečné-odkazy"><a class="header" href="#další-užitečné-odkazy">Další užitečné odkazy</a></h2>
<ul>
<li><a href="https://pruvodce.ucw.cz/">Průvodce labyrintem algoritmů</a></li>
<li>Dobré poznámky má také <a href="https://slama.dev/">Tomáš Sláma</a></li>
<li>Některé odkazy lze najít na <a href="https://wiki.matfyz.cz/Home">Matfyzácké wiki</a></li>
</ul>
<h2 id="cvrp"><a class="header" href="#cvrp">CVRP</a></h2>
<ul>
<li><a href="./mff/cvrp/cvrp-presentation.pdf">Presentation</a></li>
<li><a href="./mff/cvrp/cvrp.pdf">Text describing the solution</a></li>
<li><a href="./mff/cvrp/solver.zip">Created solver</a></li>
</ul>
<h2 id="thesis-links"><a class="header" href="#thesis-links">Thesis links</a></h2>
<ul>
<li><a href="./mff/connected-cuts.pdf">My notes on connected cuts</a></li>
<li><a href="https://link.springer.com/article/10.1007/s10107-023-01987-9">On the minimum \(s-t\) cut problem with budget constraints</a></li>
<li><a href="https://epubs.siam.org/doi/abs/10.1137/120873996">Min max and small set expansion</a></li>
<li><a href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ESA.2021.26">Balanced Crown Decomposition for Connectivity Constraints</a></li>
</ul>
<h3 id="other-links"><a class="header" href="#other-links">Other links</a></h3>
<ul>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/195058.195216">Max cut</a></li>
<li><a href="https://www.researchgate.net/publication/2513735_Multicommodity_Flows_and_Approximation_Algorithms">\(s-t\) connected cuts</a></li>
<li><a href="https://arxiv.org/abs/1807.07143v2">\(k\) cuts</a> a <a href="https://arxiv.org/pdf/1807.07143v2">PDF</a></li>
<li><a href="https://kam.mff.cuni.cz/~kolman/papers/STC-2024.pdf">Petr Kolman STC</a></li>
<li><a href="https://kam.mff.cuni.cz/~kolman/papers/stc-ext-arx.pdf">Petr Kolman - other aproximation</a></li>
<li><a href="https://sites.cs.ucsb.edu/~daniello/papers/maximum_minimal_cut__Journal.pdf">Maximum connected cut</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project"><a class="header" href="#project">Project</a></h1>
<p>There is a small list of my projects.</p>
<h2 id="xtodo---this-is-in-progress-of-developing-new-version"><a class="header" href="#xtodo---this-is-in-progress-of-developing-new-version">xtodo - <em>this is in progress of developing new version</em></a></h2>
<p>Desktop app written in <code>C++</code> that is for organizing your to-dos in <code>todo.txt</code> format. It is divided into <code>xtodo-cli</code> and <code>xtodo</code>.</p>
<p><a href="https://github.com/metury/xtodo">GitHub</a> and <a href="../resources/docs/xtodo/index.html">Documentation</a></p>
<pre><code class="language-txt">x Create an example todo.txt
5.11.2023 Add documentation @xtodo
5.11.2023 6.11.2023 Update the page @page
</code></pre>
<h2 id="graphs"><a class="header" href="#graphs">graphs</a></h2>
<p>Library for graphs that is written in <code>Java</code>. There are some basic algorithms implemented as well.</p>
<p><a href="https://github.com/metury/graphs">GitHub</a> and <a href="../resources/docs/graphs/index.html">Documentation</a></p>
<h2 id="rodoc"><a class="header" href="#rodoc">rodoc</a></h2>
<p>My own bachelors project that is for organizing your own family tree.</p>
<p><a href="https://github.com/rodoc-app/rodoc-app">GitHub</a> and <a href="https://rodoc-app.github.io/">Page</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-languages"><a class="header" href="#programming-languages">Programming languages</a></h1>
<p>I am keeping a list of usefull links and tools one may be using.</p>
<!--
- [CPP]
- [Rust]
- [Python]
- [Go]
-->
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>Here are some usefull links:</p>
<ul>
<li><a href="https://www.rust-lang.org">Rust page</a></li>
<li><a href="https://play.rust-lang.org/">Rust playground</a></li>
<li><a href="https://crates.io/">crates.io</a></li>
<li><a href="https://lib.rs/">lib.rs</a></li>
</ul>
<h2 id="c"><a class="header" href="#c">C++</a></h2>
<p>Here are some links:</p>
<ul>
<li><a href="https://en.cppreference.com">Cpp reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-exercises"><a class="header" href="#programming-exercises">Programming exercises</a></h1>
<p>There are some more or less easy programming exercises that will get you into a programming. Yet I have not work out the exact style of these pages, now there is just a list of solutions to typical problems.</p>
<h2 id="ceaser-cipher"><a class="header" href="#ceaser-cipher">Ceaser cipher</a></h2>
<pre><code class="language-py"># Assume only whitespace and lovercase alphabet is present.

shift = int(input("Zadej posun: "))
word = input("Zadej zprávu: ")

for c in word:
	if ord(c) &gt;= ord('a') and ord(c) &lt;= ord('z'):
		print(chr(((ord(c) - ord('a') + shift) % (ord('z') - ord('a') + 1)) + ord('a')), end = "")
	else:
		print(c, end="")

print()
</code></pre>
<h1 id="k-th-min"><a class="header" href="#k-th-min">k-th min</a></h1>
<pre><code class="language-py">number = 0
array = list()
c = 100

def cap():
	if len(array) &gt; c: # Když to pole je moc velké
		array.pop(0) # Vyhoď na pozici x = 0
		# len(array) = c * 2 -&gt; tohle se nemůže stát
		# len(array) &lt;= c + 1

# array.pop(0) vs array.pop(len(array)-1)
# to prvni podstatne pomalejsi

def add(value):
	for i in range(len(array)): # Přes všechny indexy
		if array[i] &gt;= value:
			array.insert(i, value) # Vlož na i prvek value [0, 1, 2, 3] insert(1,50) -&gt; [0, 50, 1, 2, 3]
			cap()
			return
	array.append(value) # Přidej prvek na konec
	cap()

while number != -1:
	number = int(input())
	if number != -1:
		add(number)

k = int(input())

print(array[len(array) - k])
</code></pre>
<h2 id="linked-list"><a class="header" href="#linked-list">linked list</a></h2>
<pre><code class="language-py"># This is implementation of K-capped linked list.

class node:
	value = 0
	next_node = None
	def __init__(self, value, next_node):
		self.value = value
		self.next_node = next_node
	def setnext(self, next_node):
		self.next_node = next_node

class linked_list:
	head = None
	tail = None
	k = 100
	size = 0
	def __init__(self, k):
		self.k = k
		self.size = 0
	def remove(self):
		if self.size &gt;= self.k:
			counter = 0
			tmp = self.head
			for i in range(self.k - 1):
				tmp = tmp.next_node
			tmp.next_node = None
			self.size -= 1
	def add(self, value):
		if self.size &gt;= self.k and self.tail != None and self.tail.value &lt;= value:
			return
		elif self.head == None:
			self.tail = self.head = node(value, None)
			self.size += 1
		else:
			tmp = self.head
			previous = None
			while tmp != None and tmp.value &lt; value:
				previous = tmp
				tmp = tmp.next_node
			if previous == None:
				self.head = node(value, self.head)
			elif tmp == None:
				self.tail = previous.next_node = node(value, None)
			else:
				previous.setnext(node(value, tmp))
			self.size += 1
		self.remove()
	def print(self):
		tmp = self.head
		print("START -&gt; ", end="")
		while tmp != None:
			print(f"{tmp.value} -&gt; ", end = "")
			tmp = tmp.next_node
		print("END")

def main():
	ll = linked_list(4)
	ll.add(2)
	ll.add(3)
	ll.add(5)
	ll.add(1)
	ll.add(6)
	ll.add(8)
	ll.add(4)
	ll.print()

if __name__ == '__main__':
	main()
</code></pre>
<h2 id="k-heap"><a class="header" href="#k-heap">k-heap</a></h2>
<pre><code class="language-py"># Implementation of K-capped max heap.

class max_heap:
	array = list()
	k = 100
	def __init__(self, k):
		self.k = k
	def size(self):
		return len(self.array)
	def remove(self):
		self.array[0], self.array[len(self.array) - 1] = self.array[len(self.array) - 1], self.array[0]
		self.array.remove(self.array[len(self.array) - 1])
		i = 0
		while (2*i+1 &lt; self.size() and self.array[i] &lt; self.array[2 * i + 1]) or (2*i+2 &lt; self.size() and self.array[i] &lt; max(self.array[2 * i + 1], self.array[2 * i + 2])):
			if 2*i+2 &lt; self.size() and self.array[2 * i + 1] &lt; self.array[2 * i + 2]:
				self.array[i], self.array[2 * i + 2] = self.array[2 * i + 2], self.array[i]
				i = 2*i +2
			else:
				self.array[i], self.array[2 * i + 1] = self.array[2 * i + 1], self.array[i]
				i = 2*i +1
	def add(self, value):
		if self.size() &gt; 0 and value &gt;= self.array[0] and self.k == self.size():
			return
		else:
			self.array.append(value)
			i = self.size() - 1
			while i &gt;= 0 and self.array[(i - 1) // 2] &lt; self.array[i]:
				self.array[(i - 1) // 2], self.array[i] = self.array[i], self.array[(i - 1) // 2]
				if i == 0:
					break
		if self.size() &gt; self.k:
			self.remove()

def main():
	h = max_heap(3)
	print(h.size())
	h.add(1)
	h.add(2)
	h.add(3)
	h.add(4)
	h.add(0)
	print(h.size())
	print(h.array)
	h.remove()
	print(h.array)
	print(h.size())

if __name__ == "__main__":
	main()
</code></pre>
<h1 id="work-with-matrix"><a class="header" href="#work-with-matrix">Work with matrix</a></h1>
<pre><code class="language-py">"""
Tohle je přečtení vstupu, rozdělení a převedení do pole čísel.
Protože to pole je délky 2, tak to lze napsat takhle.
"""
height, width = [int(x) for x in input().strip().split(" ")]
matrix = list()

for _ in range(height):
	matrix.append([int(number) for number in input().strip()split(" ")])

"""
Najdi globální minimum.
"""
my_min = min([min(x) for x in matrix])

"""
Odečti minimum od všech.
"""
p_matrix = [[x - my_min for x in l] for l in matrix]

"""
Vytiskni matici.
"""
for row in p_matrix:
	for i in range(len(row)):
		if i == len(row) - 1:
			print(row[i])
		else:
			print(row[i], end=" ")
</code></pre>
<h1 id="trees"><a class="header" href="#trees">Trees</a></h1>
<pre><code class="language-py">"""
Tohle je třeba pro čtení vstupu dokud nezkončí.
Konec je v terminálu pomocí Ctrl+D.
"""
import sys

c = 100 # max size of field - Můžeš si to přepočítat.

"""
Woods je matice stromů. Respektive teček/hvězdiček.
Tento konstrukt vytvoří pole c*c s hodnotami False.
"""
woods = [[False for _ in range(c)] for _ in range(c)]

"""
Hranice vykreslitelného pole.
"""
boundaries = [c, c, 0, 0] # Xmin, Ymin, Xmax, Ymax


"""
Tohle je to pozorování. Ale ve zkratce.
# 0 0 3 1 [Y, X, K, L]
# How to compute this?
# ..*.. &lt;- at this level it is on pos [X, Y+K]
# .***. &lt;- at this level are the positions [X+1,Y+ K-1..K..K+1]
# ***** ... generally it is [X + i,Y+ K-i ... K+i]
# ..*.. &lt;- bottom is just [X + K, Y+K]
"""

"""
Tiskne matici stromů dle hranic.
"""
def print_woods(min_x, min_y, max_x, max_y):
	for i in range(min_x, max_x): # od min do max
		for j in range(min_y, max_y): # od min do max
			if woods[i][j]: # Pokud je True, tak hvězdička
				print("*", end="") # Na konec nic nedávej.
			else:
				print(".", end="")
		print() #Vytiskni konec řádky.

"""
Tady se aktualizují hranice, tedy minima a maxima pro x a y.
Zde možná je těžší se vyznat v daných maximech a minimech, tak si to
kdyžtak pomalu projdi a uprav tak aby to bylo lépe čitelné.
"""
def update(args):
	if boundaries[0] &gt; args[0]: #update xmin
		boundaries[0] = args[0]
	if boundaries[1] &gt; args[1]: #update ymin
		boundaries[1] = args[1]
	if boundaries[2] &lt; args[1] + args[2] + args[3]: #update xmax
		boundaries[2] = args[1] + args[2] + args[3]
	if boundaries[3] &lt; args[0] + 2*args[2] - 1: #update ymax
		boundaries[3] = args[0] + 2*args[2] - 1

"""
Přidej strom do pole. Args je pole [X, Y, K, L]
Tady se použivá celé pozorování a výpočet indexů.
"""
def add_tree(args):
	boundaries = update(args)
	for i in range(args[2]):
		for j in range(i + 1):
			woods[args[1] + i][args[0] + args[2] - j - 1] = True
			woods[args[1] + i][args[0] + args[2] + j - 1] = True
			# Note middle is twice
	for i in range(args[3]):
		woods[args[1]+args[2] + i][args[0]+args[2] - 1] = True

# This is bad. We need to use sys.stdin.
"""
while((l := input()) != None):
	add_tree([int(x) for x in l.split(" ")])
	print_woods(boundaries[0], boundaries[1], boundaries[2], boundaries[3])
"""

"""
Dokud nezkončí vstup čti řádky.
"""
for line in sys.stdin:
	add_tree([int(x) for x in line.split(" ")]) # Tohle je vlastně read z předchozího úkolu.

"""
Už jen vytiskni les.
"""
print_woods(boundaries[0], boundaries[1], boundaries[2], boundaries[3])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jednoduchý-průvodce-po-tenerife"><a class="header" href="#jednoduchý-průvodce-po-tenerife">Jednoduchý průvodce po Tenerife</a></h1>
<p>Zde můžete najít pár tipů a rad ohledně návštěvy Španělského ostrova Tenerife. Mimo samotné cesty můžete zde najít pár zajímavých míst a taky několik konkrétních tras.</p>
<p>Vše berte trochu s ohledem. Ne všechny trasy jsou vhodné pro každého a také se v průběhu času mohou měnit konkrétní mistní podmínky a situace. Tento průvodce je občas aktualizován, ale je to pouze moje volnočasová aktivita.</p>
<p>Všechny typy a rady jsou na Vaše vlastní nebezpečí a tímto nijak neodpovídám, že případné potíže.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cesta"><a class="header" href="#cesta">Cesta</a></h1>
<p>Zde si nejdříve představím doporučení na věci, které by šlo vzít s sebou a následně nějaké komentáře ohledně cesty letadlem.</p>
<p>Závěrem také stručně představím, jak se lze po ostrově pohybovat.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="co-si-vzít-s-sebou"><a class="header" href="#co-si-vzít-s-sebou">Co si vzít s sebou</a></h1>
<p>Koneckonců přesný seznam závisí na potřebách každého z Vás. Nicméně i tak dodám nějaké doporučení, které mi přijde užitečné.</p>
<p>Pokud si budete brát velký kufr, tak tohle není moc potřeba. Většinou stačí jen příruční zavazadlo, které nabývají rozměrů batohu, do kterého se vejde dost potřebných věcí.</p>
<p>Díky dobrému počasí toho člověk zas tak moc nepotřebuje. Jako boty stačí jen nějaké <strong>botasky</strong> na normální chození a pak se hodí nějaké <strong>pořádnější boty</strong> do hor. Do hor se taky málokdy hodí i teplejší oblečení, ale většinou to nebývá třeba (je třeba dodat, že moc na ostrově zima nebývá). Proto pokud letíte někdy v zimních termínech, tak se do letadla oblečte v dlouhém oblečení a jděte v pořádnějších botách a díky tomu věci, které zabírají nejvíce místa nemusíte mít v batohu.</p>
<p>Pak nějaké základní věci jako ručníky bývávají na ubytování (ale záleží kde jste ubytováni). Pak už snad jen plavky a normální oblečení do tepla. Popřípadě se vše dá dokoupit v místních obchodech, které poslední dobou bývají snad i levnější než v Česku.</p>
<p>Detaily psát nechci, jednak bych na něco určitě zapomněl a taky každý chce s sebou něco jiného, takže mi to nedává smysl.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cesta-letadlem"><a class="header" href="#cesta-letadlem">Cesta letadlem</a></h1>
<p>Přijde mi, že ne všichni mají nějaké nedávné zkušenosti s létáním. Pokud ale jo, tak tohle číst nemusíte.</p>
<h2 id="aerolinky"><a class="header" href="#aerolinky">Aerolinky</a></h2>
<p>Doporučené letové trasy za levné peníze jsou z Katowic a Vídně. Postupem času mohou být užitečné i nepřímé spoje z Prahy, ale není to vždy nejlevnější spojení.</p>
<p>Nějaké konkrétní tipy na aerolinky:</p>
<ul>
<li><a href="https://wizzair.com/">WIZZ Air</a></li>
<li><a href="https://www.ryanair.com/">Ryanair</a></li>
<li><a href="https://www.vueling.com/en">Vuelingu</a></li>
</ul>
<h2 id="cesta-na-letiště"><a class="header" href="#cesta-na-letiště">Cesta na letiště</a></h2>
<h3 id="katowice"><a class="header" href="#katowice">Katowice</a></h3>
<p>Klasicky se na letiště lze dostat autem, nicméně to je třeba pak zaparkovat. Například v Katowicích ve vedlejší vesnici <em>Pyrzowice</em> je spoustu domů, které mají místo zahrady parkoviště.</p>
<p>Alternativně se lze dopravit pomocí autobusů a vlaků. Myslím, že na letiště ve Vídní jezdí už přímo linky (minimálně z Brna) ale na letiště do Katowic už moc ne, ale tam jezdí místní <a href="https://rj.metropoliaztm.pl/rozklady/1-ap/76430/1/162106/">MHD</a> z hlavního nádraží na letiště. Lístky se dají koupit (i kartou, ale ne vždy) na nádraží.</p>
<ul>
<li><a href="https://www.flixbus.cz/">FlixBus</a></li>
<li><a href="https://www.studentagency.cz/">Student agency</a></li>
<li><a href="https://www.gepard.com/">Gepard express</a></li>
</ul>
<h3 id="vídeň"><a class="header" href="#vídeň">Vídeň</a></h3>
<p>V případě vídně je lepší použít hromadné dopravy, které jsem již dříve zmínil. Pokud byste chtěli jet autem, tak lze použít oficiální parkoviště, nicméně to bývá dražší. Dostal jsem doporučení na jedno parkoviště, které je celkem blízko a mělo by být levnější.</p>
<ul>
<li><a href="https://www.mazur-parken.at/en">Mazur parking</a></li>
</ul>
<h2 id="samotný-let"><a class="header" href="#samotný-let">Samotný let</a></h2>
<p>Na co je dobré upozornit (z vlastní zkušenosti) je lepší si vzít nějaké jídlo a pak buď na letišti (za kontrolou!) koupit pití anebo si vzít láhev a pak si ji naplnit. Popřípadě si lze občerstvení zakoupit v letadle, ale to si opět připlatíte.</p>
<p>Tohle snad nebude potřeba dodávat, ale na cestu letadlem si s sebou nesmíte do příručního zavazadla brát ostré nebo nebezpečné předměty a také nesmíte brát tekutiny. V případě tekutin je omezení myslím do 100 ml. Takže bacha třeba na kosmetiku.</p>
<p>Potom také v případě odbaveného zavazadla nesmí obsahovat baterie. Ty pak musí být v příručním zavazadle. Mimo jiné existuje i celkové omezení na velikost baterií, ale ty snad nikdo nepřesáhne.</p>
<p>Pokud s sebou budete brát jen normální věci, tak to nejhorší co se může stát je, že vám danou věc vyhodí. Aspoň budete mít pěknou historku.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="jak-se-pohybovat-po-ostrově"><a class="header" href="#jak-se-pohybovat-po-ostrově">Jak se pohybovat po ostrově</a></h2>
<p>Buď se dá půjčit auto. Proto jsou dobré půjčovny jako následující:</p>
<ul>
<li><a href="https://autoreisen.com/car-hire/car-hire.php">AutoReisen</a></li>
<li><a href="https://www.cicar.com/EN">Cicar</a></li>
<li><a href="https://www.pluscar-tenerife.com/booking.php?lang=en">PlusCar</a></li>
</ul>
<p>Jako další možnost je používat místní autobusy. Autobusy nemají až tak přísný řád, ale jezdí docela dost dobře. Pro ně je lepší si zařídit jejich kartičku <a href="https://tenmas.es/">TenMas</a>. Kartička se dá pořídit hned na letišti. Pak je většinou lepší si ji dát jako kreditní (<em>purse</em>) a nabýt si ji. Hlavní výhoda je, že pokud přestupujete, tak cena je o hodně levnější, protože se vlastně počítá celá cesta dohromady a ne dvě separátní cesty. Použití této karty je hodně jednoduché. Při vstupu si pípnete a <strong>PŘI VÝCHODU TAKY</strong> (na to se celkem často zapomíná, potom se bere jako cena až do konečné stanice). Pokud na kartu jede více lidí, tak je třeba předem říct řidiči kolik vás je a kam jedete. Následně pro hledání spojů se dá vyhledat přes <em>google maps</em> anebo použít jejich aplikaci <a href="https://play.google.com/store/apps/details?id=com.diodev.guaguas&amp;gl=US">Guaguas</a> (<em>už není moc funkční</em>) ale nehledal jsem jestli existuje i verze na iOS.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trasy-a-místa"><a class="header" href="#trasy-a-místa">Trasy a místa</a></h1>
<p>V textu zmiňuji <strong>Jih</strong> a <strong>Sever</strong> ostrova. Tato terminologie je tak, jak by člověk očekával. Přesněji to beru vůči Teide.</p>
<p>Také přidám <strong>GPX</strong> soubor s konkrétními místy, které budu v textu zmiňovat.</p>
<ul>
<li>Pár tras už jsem dal do toho co navštívit, ale je možné, že tady taky nějaké přidám. Jako hlavní zdroj doporučuji pro různé trasy pomocí <a href="https://www.geocaching.com/">Geocaching</a> a taky i někdy přímo <a href="https://wherigo.com/">WhereIGo</a>,ale to je vlastně spojené s Geocachingem také.</li>
<li>Takové doporučení jak si naplánovat den je, že ráno se vyjede někam na výlet a odpoledne se zajede na nějakou blízkou pláž a tam si člověk hodně odpočine.</li>
<li>Samozřejmě je potřeba nepřecenit svoje možnosti a taky nejlépe nejít sám a nepodcenit pitný režim. Možná bych ještě doporučil pokrývku hlavy. A taky v nějakých oblastech už není moc dobrý signál. Neznamená to, že máte mít satelitní telefon, ale nespoléhat se na připojení k internetu.</li>
<li>Je asi dobré si naplánovat svoje vlastní trasy, ale jako inspiraci přidám pár tras, které byly celkem pěkné.</li>
<li>Jinak jako aplikaci na mapy doporučuji klasické <a href="https://mapy.cz/">mapy.cz</a> které mají dobré turistické trasy a taky umí import/export gpx.</li>
</ul>
<h2 id="okolí-teide"><a class="header" href="#okolí-teide">Okolí Teide</a></h2>
<ul>
<li>Jedna kratší cesta poblíž výhledu <a href="tenerife/../../resources/Samara.gpx" title="resources/Samara.gpx">Samara</a>.</li>
<li>Pak výlet na horu <a href="tenerife/../../resources/Sombrero.gpx" title="resources/Sombrero.gpx">Sombrero</a> ze které je výhled na park Teide.</li>
<li>Pak ještě <a href="tenerife/../../resources/teide-view.gpx" title="resources/teide-view.gpx">trasa</a> poblíž, ale z opačné strany poblíž Roques de Garcia.</li>
</ul>
<h2 id="pohoří-anaga"><a class="header" href="#pohoří-anaga">Pohoří Anaga</a></h2>
<ul>
<li>Trasa okolo hory <a href="tenerife/../resources/Taborno.gpx" title="resources/Taborno.gpx">Taborno</a>.</li>
</ul>
<h2 id="pohoří-teno"><a class="header" href="#pohoří-teno">Pohoří Teno</a></h2>
<ul>
<li>Tady je jedna pěkná <a href="https://www.geocaching.com/geocache/GC65QKW">Where I Go</a> ohledně pána prstenů. Není potřeba přidat trasu ale popř. je to zhruba <a href="tenerife/../../resources/tlotr.gpx" title="resources/tlotr.gpx">tahle</a>.</li>
<li>Ještě je zajímavé jiné Where I Go také poblíž a to <a href="https://www.geocaching.com/geocache/GC8J7A3">reverzní keš</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="příroda"><a class="header" href="#příroda">Příroda</a></h2>
<p>Na celém ostrově je spoustu zajímavých přírodních úkazů. Při výběru berte v potaz to, jestli se bojíte výšek (nebo dokonce máte závratě). Většinu tras jsem osobně zvládl, ale každý má jiné hranice.\</p>
<h3 id="parque-national-del-teide"><a class="header" href="#parque-national-del-teide">Parque National del Teide</a></h3>
<p>Samozřejmostí je středobod Tenerife <a href="https://goo.gl/maps/qYmkyHaMSfNSbAkY7">Pico del Teide</a>. Pokud by se někdo chtěl dostat až na vrchol, tak je třeba si zajistit včas <a href="https://www.reservasparquesnacionales.es/real/ParquesNac/usu/html/listado-actividades-oapn.aspx?cen=2">permit</a>. A i tak to není zaručené kvůli počasí, protože nahoře můžou být klidně i závěje sněhu. Na samotný vrchol jezdí lanovka, ale lze zvolit i cestu po svých.</p>
<p>Dalším místem je <a href="https://goo.gl/maps/QTHVNU92jzp3gDeBA">Roques de Garcia</a>, což jsou skály uprostřed "pouště". Je tady jeden kratší <a href="tenerife/../../resources/garcia.gpx" title="resources/garcia.gpx">okruh</a>, který se dá jít, ale výrazně doporučuji jít daným směrem, kvůli výškovému profilu.</p>
<h3 id="anaga"><a class="header" href="#anaga">Anaga</a></h3>
<p>Celý sever je také hodně hornatý. Pohoří se jmenuje <a href="https://goo.gl/maps/Y49XMutjRv124ZSr7">Anaga</a>. Tady se dají najít zajímavé trasy. Ale cesta autem už je dost záživnější (jak když polechtáš hada #snake). A trasy už jsou také intenzivnější, ale s pěknými výhledy.</p>
<h3 id="teno"><a class="header" href="#teno">Teno</a></h3>
<p>Dalším pohořím je Teno ve kterém se mimo jiné nachází nejvýše postavená vesnice <a href="https://goo.gl/maps/byGNbp8r4mAbzukL8">Masca</a>. Ve které je taky <a href="tenerife/../../resources/masca.gpx" title="resources/masca.gpx">trasa</a> údolím. Cesta autem bývá jedna z těch nejhorších a to ne kvůli serpentinám, ale protože tam je velký provoz. Lze zvolit autobus a to někdy bývá i větší zážitek než cesta autem.</p>
<p>Součástí pohoří Teno jsou skály vysoce se tyčící přímo z oceánu  <a href="https://goo.gl/maps/oQFcwSWWEjWE9V1k6">Los Gigantes</a>. Pak zase záleží jak blízko chce člověk jít, protože se dá jít <a href="tenerife/../../resources/gigantes.gpx" title="resources/gigantes.gpx">trasa</a> po Los Gigantes.</p>
<h3 id="další"><a class="header" href="#další">Další</a></h3>
<p>Další v pořadí je <a href="https://www.barrancodelinfierno.es/en/">Barranco del Infierno</a>. Jedná se o celkem pěkné údolí akorát kvůli ne zas tak dávné nehodě se vstup hodně hlídá a člověk je nucen koupit si vstup a jít tam z helmou. Řekl bych, že to není zas tak zajímavé. Ale přišlo mi blbé to aspoň neříct.</p>
<p>Co mě ještě napadlo jsou skály známé jako <a href="https://goo.gl/maps/FZuzgERWUWpBjWQT7">Paisaje Lunar</a>("měsíční krajina"). Buď lze zastavit ve Vilafloru a jít celou trasu pěšky anebo se jde i více přiblížit autem, ale pokud dobře vím, tak tam není moc dobrá cesta vzhledem k povrchu.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="města"><a class="header" href="#města">Města</a></h2>
<p>Možná pokud by někdo chtěl navštívit spíše kulturu, tak pak zajímavá města by mohla být.</p>
<h3 id="garachico"><a class="header" href="#garachico">Garachico</a></h3>
<p>Městečko <a href="https://goo.gl/maps/mHCb6RYfBmf5BGFE7">Garachico</a> které kdysi bylo zalité lávou. Také zde jezdíme na <a href="https://goo.gl/maps/Xfbu3stRrEJknuax7">jídlo</a> (králík naložený v místní omáčce) a pak tu jsou přírodní bazénky, ale tam se mockrát nedá plavat, protože to tam je spíše jako v pračce. Pokud si náhodou někdy pamatuje, jak bývalo ve zprávách, že na Tenerife se kvůli bouři ničí baráky z přívalových vln, tak to bylo v těchto oblastech.</p>
<h3 id="candelarioa"><a class="header" href="#candelarioa">Candelarioa</a></h3>
<p>Další město je <a href="https://goo.gl/maps/6e3SA1BZ9FwFJ6JN6">Candelaria</a>. Tady je to hlavně známé svojí katedrálou (nebo co to je) a pokud si to správně pamatuji tak v ní je "černá Madonna".</p>
<h3 id="la-orotava"><a class="header" href="#la-orotava">La Orotava</a></h3>
<p>Dále bych řekl <a href="https://goo.gl/maps/T3zynzWUvovTTgLBA">La Orotava</a>, které je také dost pěkné a to svými parky.</p>
<h3 id="la-laguna"><a class="header" href="#la-laguna">La Laguna</a></h3>
<p>Nesmí chybět ani <a href="https://goo.gl/maps/xEwbv2aDbRi3DyDT6">La Laguna</a>, které je prakticky spojené i s hlavním městem <a href="https://goo.gl/maps/e9t6WvGBUK4GF4To7">Santa Cruz de Tenerife - hlavní město</a>. V La Laguně je hodně kostelů a pěkná architektury.</p>
<h3 id="santa-cruz-de-tenerife"><a class="header" href="#santa-cruz-de-tenerife">Santa Cruz de Tenerife</a></h3>
<h3 id="buenavista-del-norte"><a class="header" href="#buenavista-del-norte">Buenavista del Norte</a></h3>
<p>Jako poslední bych dodal asi <a href="https://goo.gl/maps/aKKuDLBAECqJuccF8">Buenovista del Norte</a> ani ne tím, že by to bylo pěkné město, ale vede odsuď cesta na severní cíp ostrova. To se musí ale už busem.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pláže"><a class="header" href="#pláže">Pláže</a></h2>
<p>Samozřejmě nesmí ani chybět pár známých pláží.</p>
<h3 id="severní-pobřeží"><a class="header" href="#severní-pobřeží">Severní pobřeží</a></h3>
<p>Na severnějším pobřežím pláže spíš bývají kamenité a také více divoké, za to nabízejí pěkné pohledy.</p>
<p>Nebo také se zde občas vyskytují "přírodní" bazénky např. <a href="https://goo.gl/maps/SQPZC5LWMhPEGWzk9">Bajamar</a> anebo v jak jsem říkal i v Garachicu.</p>
<h3 id="jižní-pobřeží"><a class="header" href="#jižní-pobřeží">Jižní pobřeží</a></h3>
<p>Pláže nacházející se na jižním pobřeží bývají spíše písečné a jsou spíše zaměřené pro turisty.</p>
<p>Za hlavním městem je <a href="https://goo.gl/maps/UnD8CAmhuvKnnt7u9">Playa de las Teresitas</a> která je asi největší pláž, nicméně je uměle vytvořená z písku ze Sahary.</p>
<p>Další je taky <a href="https://goo.gl/maps/8buUpg68wUNmJHkE6">Playa de la Tejita</a>, kterou si pamatuji tím, že tam byla asi tak nejteplejší voda (nevím čím to je). Ale bývá tam také větrno a velké vlny. K tomu pak patří i pláže v El Medanu. Tam je to spíše pro windsurfing.</p>
<p>Pak Pláže v <a href="https://goo.gl/maps/bB9e8AdtTUhw9VGE80">Los Cristianos (např.)</a> a také vedlejší <a href="https://goo.gl/maps/p4sZm2meg3KCcwbC9">Las Americas</a>, tady už není co dodat.</p>
<p>Významnou pláží je <a href="https://goo.gl/maps/A3bQHKSqsY8x4aQG7">Playa de la Arena</a> na které je černý písek. To nese i svoji špatnou stránku, protože může být až vařící a nedá se po něm chodit. Také zde bývají vlny. Ale jinak je to celkem menší pláž.</p>
<p>Dodám ještě kamenitou (ne štěrkovou) pláž poblíž žluté hory. Tato pláž je dobrá pro potápění.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vedlejší"><a class="header" href="#vedlejší">Vedlejší</a></h2>
<p>Jednou z nejznámější atrakcí je <a href="https://www.loroparque.com/index.php/en/">Loro Parque</a>, což je jednoduše řečeno velká zoo. Aby se to pořádně vyplatilo a člověk viděl vše, tak je to zhruba na celý den. Protože zde jsou naplánované všemožné show.</p>
<p>Podobný jako Loro Parque je <a href="https://www.siampark.net/index.php/en/">Siam Park</a> akorát tady se jedná o akvapark. Rozhodně se vyplatí jít během nějakého dne kdy není svátek nebo volno aby tam nebylo úplně narváno.</p>
<p>Pokud chcete klidně strávený den, tak jako možnost doporučuji si vyjet směrem k Teide a pak cestou se nachází u cesty "kempy" ve kterých je spousta volně dostupných "grilů". Člověk si musí přinést něco co dobře hoří a jídlo a cokoliv co chce. Pokud si správně pamatuji tak je tam přístup k vodě a také je tam toaleta. Jenom přidám jeden <a href="https://goo.gl/maps/VyYMBCxJ1tVeZEQLA">příklad</a> ale je jich tam více a na vícero cestách.</p>
<p><em>Nejspíše jsem toho spoustu vynechal, ale to už je na vás, abyste to našli sami.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="počasí"><a class="header" href="#počasí">Počasí</a></h1>
<p>Tady není moc co dodat. Během celého roku se teplota pohybuje kolem 25 stupňů. Samozřejmě není vždy zcela konstatní. Občas můžete narazit na studené noci s 16 stupni anebo zažít 40ti stupňové dny.</p>
<p>Je dobré dodat, že tohle se týká jižní části ostrova. Kvůli tomu jak uprostřed ostrova je Teide, tak vzniká to, že na severu častěji prší a také zde bývá trochu nižší teplota, ale ne s nějakým velkým rozdílem. Respektive dobrá rada je, že pokud na jedné části ostrova prší, tak na druhé nejspíše ne.</p>
<p>Ještě bych řekl, že občas nastane něco čemu místní říkají <strong>"Calima"</strong> a to je pro písek, který je kvůli bouři vynesen ze Sahary a dále putuje nejenom na Kanárské ostrovy. Pokud to nastane, tak je poznat, že ve vzduchu je písek a taky se zvýší teplota. Proto se moc nedoporučuje dělat fyzicky náročné aktivity. Jednak protože je hodně horko, ale taky člověk vdechuje písek.</p>
<p>Jako poslední (spíše taková zajímavost) je, že na Teide (popř. i v národním parku okolo Teide někdy může nasněžit. To ale není moc časté. Nicméně pokud se pojedé do národního parku podívat, tak u cest uvidíte dvojbarevné tyče, které slouží k použití pluhu.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="okolí-costa-del-silencio"><a class="header" href="#okolí-costa-del-silencio">Okolí Costa del Silencio</a></h1>
<p>Tady sepíšu to co je v okolí Costa del Silencio a Las Galletas, která se pár čtenářům může hodit.</p>
<h2 id="restaurace"><a class="header" href="#restaurace">Restaurace:</a></h2>
<p>Jednou z nejlevnějších je restaurace <a href="https://goo.gl/maps/3t8R4k3FGjeEEkBL7">3,60</a>. Bacha v pondělí mají zavřeno, ale jak název určuje, tak ceny jsou 3.60 EUR. (Snad se v blízké době neplánují přejmenovat.)</p>
<p>V blízkém okolí ve stejné ulici je spoustu dalších restaurací.</p>
<p>Pak také dobrá <a href="https://g.page/el-patio-del-coral?share">restaurace</a> kde dělají dobré speciality jako např. krevety na víně.</p>
<p>Ale myslím si, že vlastním výběrem nějaké jiné restaurace člověk neudělá chybu.</p>
<h2 id="obchody"><a class="header" href="#obchody">Obchody:</a></h2>
<ul>
<li>Jedním z nejlepších obchodů, který je sice dál je <a href="https://goo.gl/maps/wp2s7g8y9tYnRZYQ8">Mercadonna</a> což je přímo řetězec a existuje vícero míst kde tyhle obchody jsou, ale tenhle je poměrně blízko.</li>
<li>V docházkové vzdálenosti je taky <a href="https://goo.gl/maps/5zCdqZXhgD9STP2s7">HyperDino</a>, což je taky velký řetězec a tyto pobočky bývají skoro všude. A levnější, ale vzdálenější je <a href="https://maps.app.goo.gl/MsiFrkcgy76godm98">Superdino</a>.</li>
<li>A taky <a href="https://goo.gl/maps/7U93xPvPrC4DEchw7">Hermussa</a> kde mývají i jiné potraviny bližší českému.</li>
<li>Podstatný další místo je <a href="https://goo.gl/maps/TH3TqrZP95npKrZW7">rybí market</a>, kde skoro každý ráno mají čerstvé ryby.</li>
<li>Také v centru Las Galletas je místní obchod s ovocem a zeleninou, kde mají místní věci. Přesnou ulici si nepamatuji, ale aspoň si člověk může projít ne tak velké centrum.</li>
<li>Kdo by chtěl spíše obchod, který zná tak i v dojezdové vzdálenosti je <a href="https://goo.gl/maps/ZwaZ35cjsRfCVap1A">Lidl</a>.</li>
<li>Pak ještě na odlet většinou aerolinky vyžadují mít vytištěné letenky. Sice to většinou není zcela třeba, ale jsou zde místa podobné "internetovým kavárnám" kde mají i tiskárny. Jedna je poblíž <a href="https://goo.gl/maps/HvZCsYA1RXkQ9Twm9">tohoto místa</a> a jiná je taky v centrum Las Galletas. (Ani já už si nepamatuji v jaké ulici to přímo je.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fresh-instalation-of-debian-computer"><a class="header" href="#fresh-instalation-of-debian-computer">Fresh instalation of <a href="https://www.debian.org">Debian</a> computer.</a></h1>
<p>Update and upgrade repos.</p>
<pre><code class="language-sh">apt update
apt upgrade
</code></pre>
<h2 id="common-apps"><a class="header" href="#common-apps">Common apps</a></h2>
<pre><code class="language-sh">apt install firefox-esr thunderbird vlc freefilesync filezilla vim gimp inkscape handbrake easytag asunder openshot-qt obs-studio telegram-desktop k3b kdenlive
</code></pre>
<h2 id="programming-languages-1"><a class="header" href="#programming-languages-1">Programming languages</a></h2>
<pre><code class="language-sh">apt install sagemath cpp octave jupyter default-jre default-jdk perl golang git python3 ruby jekyll ghc ghc-prof ghc-doc doxygen polymake meson cmake make swi-prolog-full valgrind cppcheck
</code></pre>
<h2 id="office"><a class="header" href="#office">Office</a></h2>
<pre><code class="language-sh">apt install texstudio libreoffice meld texlive-full pandoc ipe
</code></pre>
<h2 id="terminal-apps"><a class="header" href="#terminal-apps">Terminal apps</a></h2>
<pre><code class="language-sh">apt install neofetch htop tree curl nnn exiftool nvim
</code></pre>
<h2 id="rust-and-apps-with-cargo"><a class="header" href="#rust-and-apps-with-cargo">Rust and apps with <code>cargo</code></a></h2>
<p>Add alias to <code>.bashrc</code> for easier use.</p>
<pre><code class="language-sh">alias rustinstall="curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"
</code></pre>
<p>Then install rust.</p>
<pre><code class="language-sh">rustinstall
</code></pre>
<p>And other programs with cargo.</p>
<pre><code class="language-sh">cargo install juliaup
cargo install mdbook
</code></pre>
<h1 id="my-bashrc"><a class="header" href="#my-bashrc">My bashrc</a></h1>
<pre><code class="language-txt">export EDITOR='nvim'
export VISUAL='nvim'

# Git aliases
alias gtpl='git pull'
alias gtps='git push'
alias gadd='git add .'
alias gcom='git commit'
alias gdif='git diff'

# Meson aliases
alias mess='meson setup build/'
alias mesc='meson compile -C build/'
alias mesi='meson install -C build/'

# Programming languages aliases
alias p='python3'
alias c='g++ -o main *.cpp'
alias h='ghci'

# Update joplin and remove it.
alias updatejoplin='wget -O - https://raw.githubusercontent.com/laurent22/joplin/dev/Joplin_install_and_update.sh | bash'
alias removejoplin='rm -fr $(find ~ -regex .*local.*joplin.*) &amp;&amp; rm -fr ~/.joplin'

# Update and install Rust language.
alias rustinstall="curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"
</code></pre>
<h1 id="cz-programming-keyboard"><a class="header" href="#cz-programming-keyboard">CZ programming keyboard</a></h1>
<p>If you are missing CZ programming keyboard then use this <a href="https://github.com/sedlons/czech-programmer-keyboard-layout-xkb">repo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boj-proti-dezinformacím"><a class="header" href="#boj-proti-dezinformacím">Boj proti dezinformacím</a></h1>
<p>Tady je můj menší seznam stránek a zdrojů, které slouží proti šíření dezinformací.</p>
<ul>
<li>Uskupení <a href="https://cesti-elfove.cz/">čeští elfové</a> a jejich projekt <a href="https://eldariel.cesti-elfove.cz/">Eldariel</a> monitorující řetězové maily.</li>
<li>Fact checker <a href="https://demagog.cz/">Demagog</a>.</li>
<li>Informace o dezinformacích:
<ul>
<li><a href="https://www.fakticke.info/">Fakticke info</a></li>
<li><a href="https://manipulatori.cz/">Manipulátoři</a></li>
</ul>
</li>
</ul>
<p>Obecně je dobré se opírat o již plně fungující instituce, jako je třeba <a href="https://www.avcr.cz/cs/">Akademie věd</a>.</p>
<p>Dále také doporučuji si poslechnout <a href="https://www.kanarci.online/">Kanárky v síti</a>.</p>
<p>Dodatečně se zatím jen podporuje a vytváří <a href="https://www.donio.cz/neskakej-jim-na-spek">nový projekt</a>.</p>
<h1 id="satira-sarkasmus-a-ironie"><a class="header" href="#satira-sarkasmus-a-ironie">Satira, sarkasmus a ironie</a></h1>
<p>Pokudněkoho baví používá sarkasmus a satiru, tak si můžete přečíst paper na <a href="./resources/fialova.pdf">fialovou</a> barvu.</p>
<p>Popřípadě doporučuji <a href="https://paralelnilisty.cz/">paralelní listy</a>.</p>
<p>Nebo oproti standardní <a href="https://en.wikipedia.org/wiki/Main_Page">Wikipedii</a> se můžete podívat na informace z <a href="https://necyklopedie.org/">Necyklopedie</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="movies"><a class="header" href="#movies">Movies</a></h1>
<p>There is a list of movies or series.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Links</th></tr></thead><tbody>
<tr><td style="text-align: center">The Big Lebowski</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Dune</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Dune: Part Two</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Inherent Vice</td><td style="text-align: center"><a href="https://www.imdb.com/title/tt1791528/">IMDB</a></td></tr>
<tr><td style="text-align: center">Last Looks</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Kiss Kiss Bang Bang</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Everything Everywhere All at Once</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Grand Budapest Hotel</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">See How They Run</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Seven Psychopaths</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Scott Pilgrim vs. the World</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Big Trouble in Little China</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Man Who Killed Don Quixote</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Godfather</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Godfather part II</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Godfather part III</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Pulp Fiction</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Kill Bill: Vol. 1</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Kill Bill: Vol. 2</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Knives Out</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Glass Onion: A Knives Out Mystery</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Fight club</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Druk</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">American History X</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">12 Angry Men</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Spider-Man: Into the Spider-Verse</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Spider-Man: Across the Spider-Verse</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Puss in Boots: The Last Wish</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Dungeons &amp; Dragons: Honor Among Thieves</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Basic Instinct</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Deadpool &amp; Wolverine</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Hitchhiker's Guide to the Galaxy</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Monty Python and the Holy Grail</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Life of Brian</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Kingsman: The Secret Service</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Kingsman: The Golden Circle</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Argylle</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Bullet Train</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Planet Terror</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Guardians of the Galaxy</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Guardians of the Galaxy Vol. 2</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Guardians of the Galaxy Vol. 3</td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<h2 id="simple-comedies"><a class="header" href="#simple-comedies">Simple comedies</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Links</th></tr></thead><tbody>
<tr><td style="text-align: center">Dumb and Dumber</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Dumb and Dumber To</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">A Million Ways to Die in the West</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">You Don't Mess with the Zohan</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Napoleon Dynamite</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Top Secret!</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Airplane!</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Airplane II: The Sequel</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Little Nicky</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Zoolander</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Zoolander 2</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sur la piste du Marsupilami</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Poliziotto superpiù</td><td style="text-align: center"><a href="https://www.imdb.com/title/tt0082924/">IMDB</a></td></tr>
<tr><td style="text-align: center">Masterminds</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Spy Hard</td><td style="text-align: center"><a href="https://www.imdb.com/title/tt0117723/">IMDB</a></td></tr>
<tr><td style="text-align: center">Hunt for the Wilderpeople</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Tropic Thunder</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Spaceballs</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Mystery Men</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Hot Rod</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Hot Shots!</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Hot Shots! Part Deux</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Naked Gun: From the Files of Police Squad!</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Naked Gun 2½: The Smell of Fear</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Naked Gun 33⅓: The Final Insult</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Nacho Libre</td><td style="text-align: center"><a href="https://www.imdb.com/title/tt0457510/">IMDB</a></td></tr>
</tbody></table>
</div>
<h2 id="musicals"><a class="header" href="#musicals">Musicals</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Links</th></tr></thead><tbody>
<tr><td style="text-align: center">Corpse Bride</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sweeney Todd: The Demon Barber of Fleet Street</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">West Side Story</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Chicago</td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<h2 id="series"><a class="header" href="#series">Series</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Links</th></tr></thead><tbody>
<tr><td style="text-align: center">Red Dwarf</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">IT Crowd</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Parks and Recreation</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Office</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Toast of London</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Toast of</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Boys</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Invincible</td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<h2 id="shark-b-movies"><a class="header" href="#shark-b-movies">Shark B-movies</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Links</th></tr></thead><tbody>
<tr><td style="text-align: center">Trailer Park Shark</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sharknado</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sharknado 2: The Second One</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sharknado 3: Oh Hell No!</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sharknado 4: The 4th Awakens</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Sharknado 5: Global Swarming</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">The Last Sharknado: It's About Time</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">6-Headed Shark Attack</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Shark Side of the Moon</td><td style="text-align: center"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="books"><a class="header" href="#books">Books</a></h1>
<p>There is a table of books, that I have read. I know not a big list, but it will keep on growing, hopefully.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Author</th><th>ISBN</th></tr></thead><tbody>
<tr><td>Nanos</td><td>Timo Leibig</td><td>978-80-7585-527-5</td></tr>
<tr><td>Práskač</td><td>Jan-Erik Fjell</td><td>978-80-7390-790-7</td></tr>
<tr><td>Pokoj stínů</td><td>Jan-Erik Fjell</td><td>978-80-7585-175-8</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code"><a class="header" href="#advent-of-code">Advent of code</a></h1>
<p>They are my solutions to <a href="https://adventofcode.com/">advent of code</a> tasks. There are separated to each year and day. All of this can be found on <a href="https://github.com/metury/advent-of-code">GitHub</a>, also with the script that generates these pages.
Plus you may also play a small <a href="https://aoc-bingo.fly.dev/">Bingo</a> that someone made. Also you may consider joining <a href="https://www.reddit.com/r/adventofcode/">Reddit</a> where you may find useful tips, or help someone.</p>
<h3 id="years"><a class="header" href="#years">Years</a></h3>
<ul>
<li><a href="./aoc/2015.html">Year 2015</a></li>
<li><a href="./aoc/2016.html">Year 2016</a></li>
<li><a href="./aoc/2017.html">Year 2017</a></li>
<li><a href="./aoc/2021.html">Year 2021</a></li>
<li><a href="./aoc/2022.html">Year 2022</a></li>
<li><a href="./aoc/2023.html">Year 2023</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015"><a class="header" href="#advent-of-code---year-2015">Advent of code - Year 2015</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2015">year 2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days"><a class="header" href="#days">Days</a></h3>
<ul>
<li><a href="aoc/2015-1.html">Day 1</a></li>
<li><a href="aoc/2015-2.html">Day 2</a></li>
<li><a href="aoc/2015-3.html">Day 3</a></li>
<li><a href="aoc/2015-4.html">Day 4</a></li>
<li><a href="aoc/2015-5.html">Day 5</a></li>
<li><a href="aoc/2015-6.html">Day 6</a></li>
<li><a href="aoc/2015-7.html">Day 7</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-1"><a class="header" href="#advent-of-code---year-2015-day-1">Advent of code - Year 2015 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/1">day 1</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info"><a class="header" href="#info">Info</a></h3>
<h4 id="part-1"><a class="header" href="#part-1">Part 1</a></h4>
<p>Simply just go through the list and count the floors.</p>
<h4 id="part-2"><a class="header" href="#part-2">Part 2</a></h4>
<p>Also just compute the floors and whenever we hit something <code>&lt;0</code> return index.</p>
<h2 id="mainrs"><a class="header" href="#mainrs">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;

fn read_file(filepath: &amp;str) -&gt; String{
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let mut lines = binding.split('\n');
  return lines.next().unwrap().to_string();
}

fn basement(string: &amp;str) -&gt; i64 {
  let mut floor: i64 = 0;
  let mut i: i64 = 0;
  for c in string.chars() {
    i += 1;
    match c {
      '(' =&gt; floor += 1,
      ')' =&gt; floor -= 1,
      _   =&gt; floor = floor,
    }
    if floor &lt; 0 {
      return i;
    }
  }
  -1
}

fn part1(){
  let line = read_file("INPUT");
  let total: i64 = line.chars().into_iter()
      .map(|c| if c == '(' { 1 } else { -1 })
      .sum();
  println!("Part 1: {}", total);
}

fn part2(){
  let line = read_file("INPUT");
  println!("Part 2: {}", basement(&amp;line));
}

fn main() {
  println!("Year 2015 day 01 - Not Quite Lisp");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-2"><a class="header" href="#advent-of-code---year-2015-day-2">Advent of code - Year 2015 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/2">day 2</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-1"><a class="header" href="#info-1">Info</a></h3>
<h4 id="part-1-1"><a class="header" href="#part-1-1">Part 1</a></h4>
<p>We simply compute the given formula.</p>
<h4 id="part-2-1"><a class="header" href="#part-2-1">Part 2</a></h4>
<p>Also just usage of the given formula.</p>
<h2 id="mainrs-1"><a class="header" href="#mainrs-1">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::cmp::min;

struct Sizes {
  h: i64,
  w: i64,
  l: i64,
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Sizes&gt; {
  let contents = fs::read_to_string(filepath);
  let mut boxes: Vec&lt;Sizes&gt; = vec!();
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  for line in lines{
    if line == "" {
      continue;
    }
    let mut parts = line.split('x');
    let l = i64::from_str_radix(parts.next().unwrap(), 10).unwrap();
    let w = i64::from_str_radix(parts.next().unwrap(), 10).unwrap();
    let h = i64::from_str_radix(parts.next().unwrap(), 10).unwrap();
    boxes.push(Sizes{h: h, l: l, w: w});
  }
  return boxes;
}

fn wrapping_size(boxes: &amp;Vec&lt;Sizes&gt;) -&gt; i64 {
  let mut total: i64 = 0;
  for b in boxes {
    let area = 2 * b.l * b.w + 2 * b.l* b.h + 2 * b.h * b.w;
    let addition = min(min(b.l * b.w, b.l* b.h), b.h * b.w);
    total += area + addition;
  }
  total
}

fn ribbon_len(boxes: &amp;Vec&lt;Sizes&gt;) -&gt; i64 {
  let mut total: i64 = 0;
  for b in boxes {
    let bow = b.l * b.w * b.h;
    let mut ribbon = 0;
    if b.h &lt;= b.w &amp;&amp; b.h &lt;= b.l {
      ribbon += 2 * b.h + 2 * min(b.w, b.l);
    }
    else if b.w &lt;= b.h &amp;&amp; b.w &lt;= b.l {
      ribbon += 2 * b.w + 2 * min(b.h, b.l);
    }
    else {
      ribbon += 2 * b.l + 2 * min(b.w, b.h);
    }
    total += bow + ribbon;
  }
  total
}

fn part1() {
  let boxes = read_file("INPUT");
  println!("Part 1: {}", wrapping_size(&amp;boxes));
}

fn part2() {
  let boxes = read_file("INPUT");
  println!("Part 2: {}", ribbon_len(&amp;boxes));
}

fn main() {
  println!("Year 2015 day 02 - I Was Told There Would Be No Math");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-3"><a class="header" href="#advent-of-code---year-2015-day-3">Advent of code - Year 2015 Day 3</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/3">day 3</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-2"><a class="header" href="#info-2">Info</a></h3>
<h4 id="part-1-2"><a class="header" href="#part-1-2">Part 1</a></h4>
<p>In the first part we remember in a set whihc positins were visited and count the size of the set.</p>
<h4 id="part-2-2"><a class="header" href="#part-2-2">Part 2</a></h4>
<p>In the second part we only swap these values every time and after that we do the same thing. So we switch the santas.</p>
<h2 id="mainrs-2"><a class="header" href="#mainrs-2">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::collections::HashSet;

type Pos = (i64, i64);
type Houses = HashSet&lt;Pos&gt;;

fn read_file(filepath: &amp;str) -&gt; String {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  binding.split('\n').next().unwrap().to_string()
}

fn found_houses(line: &amp;str, robo_santa:  bool) -&gt; usize {
  let mut houses: Houses = HashSet::new();
  let mut pos: Pos = (0,0);
  let mut robo_pos: Pos = (0,0);
  houses.insert(pos);
  for c in line.chars() {
    match c {
      '&gt;' =&gt; pos = (pos.0, pos.1 + 1),
      '&lt;' =&gt; pos = (pos.0, pos.1 - 1),
      'v' =&gt; pos = (pos.0 + 1, pos.1),
      '^' =&gt; pos = (pos.0 - 1, pos.1),
       _  =&gt; pos = pos,
    }
    houses.insert(pos);
    if robo_santa {
      (pos, robo_pos) = (robo_pos, pos);
    }
  }
  houses.len()
}

fn part1() {
  let line = read_file("INPUT");
  println!("Part 1: {}", found_houses(&amp;line, false));
}

fn part2() {
  let line = read_file("INPUT");
  println!("Part 2: {}", found_houses(&amp;line, true));
}

fn main() {
  println!("Year 2015 day 3 - Perfectly Spherical Houses in a Vacuum");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-4"><a class="header" href="#advent-of-code---year-2015-day-4">Advent of code - Year 2015 Day 4</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/4">day 4</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-3"><a class="header" href="#info-3">Info</a></h3>
<h4 id="part-1-3"><a class="header" href="#part-1-3">Part 1</a></h4>
<p>First of all we import <code>md-5</code> library to compute the hashes. Then simply compute the hashses of <code>key</code> appended by iterating indexes.</p>
<h4 id="part-2-3"><a class="header" href="#part-2-3">Part 2</a></h4>
<p>The second part is same only we check six zeros.</p>
<h2 id="mainrs-3"><a class="header" href="#mainrs-3">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use md5::{Md5, Digest};

fn read_file(filepath: &amp;str) -&gt; String {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  binding.split('\n').next().unwrap().to_string()
}

fn prefix_md5(origin: &amp;str, eq: &amp;str) -&gt; u64 {
  let mut i: u64 = 0;
  loop {
    let input = format!("{}{}", origin, i);
    let mut hasher = Md5::new();
    hasher.update(input);
    let result = hasher.finalize();
    let hash_string = format!("{:x}", result);
    if hash_string[0..eq.len()] == eq.to_string() {
      break;
    }
    i += 1;
  }
  i
}

fn part1() {
  let origin = read_file("INPUT");
  println!("Part 1: {}", prefix_md5(&amp;origin, "00000"));
}

fn part2() {
  let origin = read_file("INPUT");
  println!("Part 2: {}", prefix_md5(&amp;origin, "000000"));
}

fn main() {
  println!("Year 2015 day 4 - The Ideal Stocking Stuffer");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-5"><a class="header" href="#advent-of-code---year-2015-day-5">Advent of code - Year 2015 Day 5</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/5">day 5</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-4"><a class="header" href="#info-4">Info</a></h3>
<h4 id="part-1-4"><a class="header" href="#part-1-4">Part 1</a></h4>
<p>For the first part we only need to configure the right regexes to represent each type. And than either mathc them or count them.</p>
<h4 id="part-2-4"><a class="header" href="#part-2-4">Part 2</a></h4>
<p>The second part is similiar only we use different regexes.</p>
<h2 id="mainrs-4"><a class="header" href="#mainrs-4">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use regex::Regex;
use fancy_regex::Regex as Rgx;

fn read_file(filepath: &amp;str) -&gt; Vec&lt;String&gt; {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let lines = binding.split('\n')
    .filter(|c| c.len() &gt; 0)
    .map(|c| c.to_string()).collect();
  lines
}

fn nice_string(lines: &amp;Vec&lt;String&gt;) -&gt; u64 {
  let mut total: u64 = 0;
  let vowels = Regex::new(r"a|e|i|o|u").unwrap();
  let pairs = Rgx::new(r"([a-z])\1").unwrap();
  let forb = Regex::new(r"ab|cd|pq|xy").unwrap();
  for line in lines {
    let nr_vowels = vowels.captures_iter(&amp;line).count();
    let exists_pairs = pairs.is_match(&amp;line).unwrap();
    let nr_forb = forb.captures_iter(&amp;line).count();
    if nr_vowels &gt;= 3 &amp;&amp; exists_pairs &amp;&amp; nr_forb &lt;= 0 {
      total += 1;
    }
  }
  total
}

fn nicer_string(lines: &amp;Vec&lt;String&gt;) -&gt; u64 {
  let mut total: u64 = 0;
  let pairs = Rgx::new(r"([a-z]{2}).*\1").unwrap();
  let middle = Rgx::new(r"([a-z])[a-z]\1").unwrap();
  for line in lines {
    let is_pair = pairs.is_match(&amp;line).unwrap();
    let is_middle = middle.is_match(&amp;line).unwrap();
    if is_pair &amp;&amp; is_middle {
      total += 1;
    }
  }
  total
}

fn part1() {
  let lines = read_file("INPUT");
  println!("Part 1: {}", nice_string(&amp;lines));
}

fn part2() {
  let lines = read_file("INPUT");
  println!("Part 2: {}", nicer_string(&amp;lines));
}

fn main() {
  println!("Year 2015 day 5 - Doesn't He Have Intern-Elves For This?");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-6"><a class="header" href="#advent-of-code---year-2015-day-6">Advent of code - Year 2015 Day 6</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/6">day 6</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-5"><a class="header" href="#info-5">Info</a></h3>
<h4 id="part-1-5"><a class="header" href="#part-1-5">Part 1</a></h4>
<p>We simply follow the given instructions on the <code>1000x1000</code> grid. Then compute those which are <code>true</code>.</p>
<h4 id="part-2-5"><a class="header" href="#part-2-5">Part 2</a></h4>
<p>In the second part we redefine the instructions and compute the sum.</p>
<h2 id="mainrs-5"><a class="header" href="#mainrs-5">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use regex::Regex;

type Grid&lt;T&gt; = Vec&lt;Vec&lt;T&gt;&gt;;
type Pos = (usize, usize);

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd)]
enum InstructionType {
  TurnOff,
  TurnOn,
  Toggle,
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd)]
struct Instruction {
  start: Pos,
  end: Pos,
  instr_type: InstructionType,
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Instruction&gt; {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let mut instructions: Vec&lt;Instruction&gt; = vec!();
  let input = Regex::new(r"(turn off|turn on|toggle) ([0-9]+),([0-9]+) through ([0-9]+),([0-9]+)").unwrap();
  for (_, [ty, s1, s2, e1, e2]) in input.captures_iter(&amp;binding).map(|c| c.extract()) {
    let instr_type: InstructionType;
    if ty == "turn off" {
      instr_type = InstructionType::TurnOff;
    } else if ty == "turn on" {
      instr_type = InstructionType::TurnOn;
    } else {
      instr_type = InstructionType::Toggle;
    }
    instructions.push(Instruction{instr_type: instr_type,
      start: (s1.parse().unwrap(), s2.parse().unwrap()),
      end: (e1.parse().unwrap(), e2.parse().unwrap()),
    });
  }
  instructions
}

fn part1() {
  let instructions = read_file("INPUT");
  let mut grid: Grid&lt;bool&gt; = vec![vec!(false; 1000); 1000];
  for ins in instructions {
    match ins.instr_type {
      InstructionType::Toggle =&gt; {
        for i in ins.start.0 .. ins.end.0 + 1 {
          for j in ins.start.1 .. ins.end.1 + 1 {
            grid[i][j] = !grid[i][j];
          }
        }
      },
      InstructionType::TurnOff =&gt; {
        for i in ins.start.0 .. ins.end.0 + 1 {
          for j in ins.start.1 .. ins.end.1 + 1 {
            grid[i][j] = false;
          }
        }
      },
      InstructionType::TurnOn =&gt; {
        for i in ins.start.0 .. ins.end.0 + 1{
          for j in ins.start.1 .. ins.end.1 + 1 {
            grid[i][j] = true;
          }
        }
      },
    }
  }
  let lit_up: u64 = grid.into_iter().map(|vec| vec.into_iter().map(|x| if x {1} else {0}).sum::&lt;u64&gt;()).sum();
  println!("Part 1: {}", lit_up);
}

fn part2() {
  let instructions = read_file("INPUT");
  let mut grid: Grid&lt;u64&gt; = vec![vec!(0_u64; 1000); 1000];
  for ins in instructions {
    match ins.instr_type {
      InstructionType::Toggle =&gt; {
        for i in ins.start.0 .. ins.end.0 + 1 {
          for j in ins.start.1 .. ins.end.1 + 1 {
            grid[i][j] += 2;
          }
        }
      },
      InstructionType::TurnOff =&gt; {
        for i in ins.start.0 .. ins.end.0 + 1 {
          for j in ins.start.1 .. ins.end.1 + 1 {
            grid[i][j] = if grid[i][j] &gt; 0 {grid[i][j] - 1} else {grid[i][j]};
          }
        }
      },
      InstructionType::TurnOn =&gt; {
        for i in ins.start.0 .. ins.end.0 + 1{
          for j in ins.start.1 .. ins.end.1 + 1 {
            grid[i][j] += 1;
          }
        }
      },
    }
  }
  let lit_up: u64 = grid.into_iter().map(|vec| vec.into_iter().sum::&lt;u64&gt;()).sum();
  println!("Part 2: {}", lit_up);
}

fn main() {
  println!("Year 2015 day 6 - Probably a Fire Hazard");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2015-day-7"><a class="header" href="#advent-of-code---year-2015-day-7">Advent of code - Year 2015 Day 7</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2015/day/7">day 7</a>. Go back to year <a href="aoc/2015.html">2015</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-6"><a class="header" href="#info-6">Info</a></h3>
<h4 id="part-1-6"><a class="header" href="#part-1-6">Part 1</a></h4>
<h4 id="part-2-6"><a class="header" href="#part-2-6">Part 2</a></h4>
<h2 id="mainrs-6"><a class="header" href="#mainrs-6">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use regex::Regex;
use std::collections::HashMap;
use std::option::Option;

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
enum GateType {
  Or,
  And,
  LShift,
  RShift,
  Not,
  Simple,
}

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
struct Gate {
  inputs: [String; 2],
  gate_type: GateType,
  output: String,
}

impl Gate {
  fn eval(&amp;self, assigned: &amp;mut HashMap&lt;String, u16&gt;) {
    let mut first: u16 = 0;
    let mut second: u16 = 0;
    match get_number(&amp;self.inputs[0], assigned) {
      Some(nr) =&gt; first = nr,
      None =&gt; return,
    }
    match get_number(&amp;self.inputs[1], assigned) {
      Some(nr) =&gt; second = nr,
      None =&gt; return,
    }
    match self.gate_type {
      GateType::Or =&gt; assigned.insert(self.output.clone(), first | second),
      GateType::And =&gt; assigned.insert(self.output.clone(), first &amp; second),
      GateType::LShift =&gt; assigned.insert(self.output.clone(), first &lt;&lt; second),
      GateType::RShift =&gt; assigned.insert(self.output.clone(), first &gt;&gt; second),
      GateType::Not =&gt; assigned.insert(self.output.clone(), !first),
      GateType::Simple =&gt; assigned.insert(self.output.clone(), first),
    };
  }
}

fn get_number(written: &amp;str, assigned: &amp;HashMap&lt;String, u16&gt;) -&gt; Option&lt;u16&gt; {
  if assigned.contains_key(written){
    return Some(assigned[written]);
  } else if written.chars().nth(0)?.is_digit(10) {
    return Some(written.parse::&lt;u16&gt;().unwrap());
  }
  None
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Gate&gt; {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let mut gates: Vec&lt;Gate&gt; = vec!();
  let bin_re = Regex::new(r"([^\s]+) (OR|AND|LSHIFT|RSHIFT) ([^\s]+) -&gt; (.+)").unwrap();
  let not_re = Regex::new(r"NOT ([^\s]+) -&gt; (.+)").unwrap();
  let simple_re = Regex::new(r"\n([^\s]+) -&gt; (.+)").unwrap();
  for (_, [first, oper, second, res]) in bin_re.captures_iter(&amp;binding).map(|c| c.extract()) {
    let operator: GateType;
    match oper {
      "OR" =&gt; operator = GateType::Or,
      "AND" =&gt; operator = GateType::And,
      "LSHIFT" =&gt; operator = GateType::LShift,
      "RSHIFT" =&gt; operator = GateType::RShift,
      _ =&gt; todo!(),
    }
    gates.push(Gate {inputs: [first.to_string(), second.to_string()], gate_type: operator, output: res.to_string()});
  }
  for (_, [first, res]) in not_re.captures_iter(&amp;binding).map(|c| c.extract()) {
    gates.push(Gate {inputs: [first.to_string(), "".to_string()], gate_type: GateType::Not, output: res.to_string()});
  }
  for (_, [first, res]) in simple_re.captures_iter(&amp;binding).map(|c| c.extract()) {
    gates.push(Gate {inputs: [first.to_string(), "".to_string()], gate_type: GateType::Simple, output: res.to_string()});
  }
  gates
}



fn part1() {
  let gates = read_file("INPUT");
  let mut assigned: HashMap&lt;String, u16&gt; = HashMap::new();
  assigned.insert("".to_string(), 0);
  while !assigned.contains_key("a") {
    for gate in &amp;gates {
      gate.eval(&amp;mut assigned);
    }
  }
  println!("Part 1: {}", assigned["a"]);
}

fn part2() {
  println!("Part 2: {}", 0);
}

fn main() {
  println!("Year 2015 day 7 - Some Assembly Required");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2016"><a class="header" href="#advent-of-code---year-2016">Advent of code - Year 2016</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2016">year 2016</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days-1"><a class="header" href="#days-1">Days</a></h3>
<ul>
<li><a href="aoc/2016-1.html">Day 1</a></li>
<li><a href="aoc/2016-2.html">Day 2</a></li>
<li><a href="aoc/2016-3.html">Day 3</a></li>
<li><a href="aoc/2016-4.html">Day 4</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2016-day-1"><a class="header" href="#advent-of-code---year-2016-day-1">Advent of code - Year 2016 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2016/day/1">day 1</a>. Go back to year <a href="aoc/2016.html">2016</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-7"><a class="header" href="#info-7">Info</a></h3>
<h4 id="part-1-7"><a class="header" href="#part-1-7">Part 1</a></h4>
<p>In the first part we jump from one place to another and then compute the manhattan distance. It is implemented to solve also the other part.</p>
<h4 id="part-2-7"><a class="header" href="#part-2-7">Part 2</a></h4>
<p>The second part we visit every single step in the middle and find the one which was already visited.</p>
<h2 id="mainrs-7"><a class="header" href="#mainrs-7">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use regex::Regex;
use std::collections::HashSet;

#[derive(Copy, Clone, Eq, Debug, PartialEq, Ord, PartialOrd)]
enum Rotation {
  R,
  L,
}

struct Movement {
  rot: Rotation,
  mult: i64
}

type Position = (i64, i64);

const NORTH: Position = (0, -1);
const SOUTH: Position = (0, 1);
const EAST: Position = (1, 0);
const WEST: Position = (-1, 0);

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Movement&gt; {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let mut movements: Vec&lt;Movement&gt; = vec!();
  let re = Regex::new(r"(R|L)([0-9]+)").unwrap();
  for(_, [rotation, movement]) in re.captures_iter(&amp;binding).map(|c| c.extract()) {
    if rotation == "R" {
      movements.push(Movement{rot: Rotation::R, mult: movement.parse().unwrap()});
    } else {
      movements.push(Movement{rot: Rotation::L, mult: movement.parse().unwrap()});
    }
  }
  movements
}

fn get_shift(rot: Rotation, direction: Position) -&gt; Position {
  match rot {
    Rotation::R =&gt; {
      if direction == NORTH {return EAST;}
      else if direction == EAST {return SOUTH;}
      else if direction == SOUTH {return WEST;}
      else {return NORTH;}
    },
    Rotation::L =&gt; {
      if direction == NORTH {return WEST;}
      else if direction == WEST {return SOUTH;}
      else if direction == SOUTH {return EAST;}
      else {return NORTH;}
    },
  }
}

fn distance(movements: &amp;Vec&lt;Movement&gt;, stop: bool) -&gt; i64 {
  let mut positions: HashSet&lt;Position&gt; = HashSet::new();
  let mut pos: Position = (0,0);
  let mut shift: Position = NORTH;
  'outer: for mov in movements {
    shift = get_shift(mov.rot, shift);
    for _ in 0 .. mov.mult {
      pos.0 += shift.0;
      pos.1 += shift.1;
      if positions.contains(&amp;pos) &amp;&amp; stop {
        break 'outer;
      }
      positions.insert(pos);
    }
  }
  pos.0.abs() + pos.1.abs()
}

fn part1() {
  let movements = read_file("INPUT");
  println!("Part 1: {}", distance(&amp;movements, false));
}

fn part2() {
  let movements = read_file("INPUT");
  println!("Part 2: {}", distance(&amp;movements, true));
}

fn main() {
  println!("Year 2016 day 1 - No Time for a Taxicab");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2016-day-2"><a class="header" href="#advent-of-code---year-2016-day-2">Advent of code - Year 2016 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2016/day/2">day 2</a>. Go back to year <a href="aoc/2016.html">2016</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-8"><a class="header" href="#info-8">Info</a></h3>
<h4 id="part-1-8"><a class="header" href="#part-1-8">Part 1</a></h4>
<p>The first part can be done with aritmetics and matrix <code>3x3</code> and not to move out of boundaries.</p>
<h4 id="part-2-8"><a class="header" href="#part-2-8">Part 2</a></h4>
<p>In the second part we create a dialpads with boundaries so we never can reach out of it. So when we move we only check if there is empty symbol or not. This is also used for the first part to reuse the code.</p>
<h2 id="mainrs-8"><a class="header" href="#mainrs-8">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;

const EMPTY: char = '$';

const DIALPAD: [[char; 7]; 7] = [[EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
                                 [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
                                 [EMPTY, EMPTY,   '1',   '2',   '3', EMPTY, EMPTY],
                                 [EMPTY, EMPTY,   '4',   '5',   '6', EMPTY, EMPTY],
                                 [EMPTY, EMPTY,   '7',   '8',   '9', EMPTY, EMPTY],
                                 [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
                                 [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY]];

const DIALPAD_ADVANCED: [[char; 7]; 7] = [[EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY],
                                          [EMPTY, EMPTY, EMPTY,   '1', EMPTY, EMPTY, EMPTY],
                                          [EMPTY, EMPTY,   '2',   '3',   '4', EMPTY, EMPTY],
                                          [EMPTY,   '5',   '6',   '7',   '8',   '9', EMPTY],
                                          [EMPTY, EMPTY,   'A',   'B',   'C', EMPTY, EMPTY],
                                          [EMPTY, EMPTY, EMPTY,   'D', EMPTY, EMPTY, EMPTY],
                                          [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY]];

const MIDDLE: (usize, usize) = (3,3);
const MIDDLE_ADVANCED: (usize, usize) = (3,1);

fn read_file(filepath: &amp;str) -&gt; Vec&lt;String&gt; {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let lines = binding.split('\n')
    .filter(|c| c.len() &gt; 0)
    .map(|c| c.to_string()).collect();
  lines
}

fn step(start: (usize, usize), pad: &amp;[[char; 7]; 7], c: char) -&gt; (usize, usize) {
  let mut pos = start;
  match c {
    'U' =&gt; pos.0 = pos.0 - 1,
    'D' =&gt; pos.0 = pos.0 + 1,
    'L' =&gt; pos.1 = pos.1 - 1,
    'R' =&gt; pos.1 = pos.1 + 1,
     _  =&gt; pos = pos,
   }
   if pad[pos.0][pos.1] != EMPTY {
     return pos;
   }
   start
}

fn move_in_dialpad(start: (usize, usize), pad: &amp;[[char; 7]; 7], line: &amp;str) -&gt; (usize, usize) {
  let mut pos = start;
  for c in line.chars() {
    pos = step(pos, pad, c);
  }
  pos
}

fn part1() {
  let lines = read_file("INPUT");
  let mut code: String = "".to_string();
  let mut pos = MIDDLE;
  for line in lines {
    pos = move_in_dialpad(pos, &amp;DIALPAD, &amp;line);
    code.push(DIALPAD[pos.0][pos.1]);
  }
  println!("Part 1: {}", code);
}

fn part2() {
  let lines = read_file("INPUT");
  let mut code: String = "".to_string();
  let mut pos = MIDDLE_ADVANCED;
  for line in lines {
    pos = move_in_dialpad(pos, &amp;DIALPAD_ADVANCED, &amp;line);
    code.push(DIALPAD_ADVANCED[pos.0][pos.1]);
  }
  println!("Part 2: {}", code);
}

fn main() {
  println!("Year 2016 day 2 - Bathroom Security");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2016-day-3"><a class="header" href="#advent-of-code---year-2016-day-3">Advent of code - Year 2016 Day 3</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2016/day/3">day 3</a>. Go back to year <a href="aoc/2016.html">2016</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-9"><a class="header" href="#info-9">Info</a></h3>
<h4 id="part-1-9"><a class="header" href="#part-1-9">Part 1</a></h4>
<h4 id="part-2-9"><a class="header" href="#part-2-9">Part 2</a></h4>
<h2 id="mainrs-9"><a class="header" href="#mainrs-9">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use regex::Regex;

struct Triangle {
  a: i64,
  b: i64,
  c: i64,
}

impl Triangle {
  fn new(a: i64, b: i64, c: i64) -&gt; Self {
    Triangle {a: a, b: b, c: c}
  }
  fn is_valid(&amp;self) -&gt; bool {
    (self.a + self.b &gt; self.c) &amp;&amp; (self.b + self.c &gt; self.a) &amp;&amp; (self.c + self.a &gt; self.b)
  }
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Triangle&gt; {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let re = Regex::new(r"([0-9]+)\s+([0-9]+)\s+([0-9]+)").unwrap();
  let mut triangles: Vec&lt;Triangle&gt; = vec!();
  for (_, [a, b, c]) in re.captures_iter(&amp;binding).map(|c| c.extract()) {
    triangles.push(Triangle::new(a.parse().unwrap(), b.parse().unwrap(), c.parse().unwrap()));
  }
  triangles
}

fn convert_triangles(triangles: &amp;Vec&lt;Triangle&gt;) -&gt; Vec&lt;Triangle&gt; {
  let mut column_triangles: Vec&lt;Triangle&gt; = vec!();
  for (i,_) in triangles.iter().enumerate().step_by(3) {
    column_triangles.push(Triangle::new(triangles[i].a, triangles[i + 1].a, triangles[i + 2].a));
    column_triangles.push(Triangle::new(triangles[i].b, triangles[i + 1].b, triangles[i + 2].b));
    column_triangles.push(Triangle::new(triangles[i].c, triangles[i + 1].c, triangles[i + 2].c));
  }
  column_triangles
}

fn part1() {
  let triangles = read_file("INPUT");
  let res = triangles.into_iter().map(|t| if t.is_valid() {1} else {0}).sum::&lt;i64&gt;();
  println!("Part 1: {}", res);
}

fn part2() {
  let triangles = convert_triangles(&amp;read_file("INPUT"));
  let res = triangles.into_iter().map(|t| if t.is_valid() {1} else {0}).sum::&lt;i64&gt;();
  println!("Part 2: {}", res);
}

fn main() {
  println!("Year 2016 day 3 - Squares With Three Sides");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2016-day-4"><a class="header" href="#advent-of-code---year-2016-day-4">Advent of code - Year 2016 Day 4</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2016/day/4">day 4</a>. Go back to year <a href="aoc/2016.html">2016</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-10"><a class="header" href="#info-10">Info</a></h3>
<h4 id="part-1-10"><a class="header" href="#part-1-10">Part 1</a></h4>
<p>In the first part we count all alfabet symbols, then sort the ones that have at least some appearance. And lastly match it with the <code>checksum</code>.</p>
<h4 id="part-2-10"><a class="header" href="#part-2-10">Part 2</a></h4>
<p>In the second part we normally shift the alfa by the given <code>id</code> and check if is equal to <code>northpole object storage</code>.</p>
<h2 id="mainrs-10"><a class="header" href="#mainrs-10">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use regex::Regex;

const ALFA_LEN: usize = 'z' as usize - 'a' as usize + 1;

struct Room {
  name: String,
  id: i64,
  checksum: String,
}

fn shift_alfa(c: char, shift: i64) -&gt; char {
  ((((c as i64 - 'a' as i64) + shift) % ALFA_LEN as i64) + 'a' as i64) as u8 as char
}

impl Room {
  fn new(name: String, id: i64, checksum: String) -&gt; Self {
    Room{name: name, id: id, checksum: checksum}
  }
  fn is_valid(&amp;self) -&gt; bool {
    let mut counters: [u64; ALFA_LEN] = [0; ALFA_LEN];
    for c in self.name.chars() {
      if c != '-' &amp;&amp; c != ' ' {
        let pos: usize = c as usize - 'a' as usize;
        counters[pos] += 1;
      }
    }
    let mut found: Vec&lt;(u64, char)&gt; = vec!();
    for i in 0 .. ALFA_LEN {
      if counters[i] &gt; 0 {
        found.push((counters[i], ('a' as u8 + i as u8) as char));
      }
    }
    found.sort_by(|(c1, _), (c2, _)| c2.cmp(&amp;c1));
    let mut cmp: String = "".to_string();
    for f in found {
      cmp.push(f.1);
    }
    cmp[..5] == self.checksum
  }
  fn decrypt(&amp;mut self) {
    let mut builder: String = "".to_string();
    for c in self.name.chars() {
      if c == '-' {
        builder.push(' ');
      } else {
        builder.push(shift_alfa(c, self.id));
      }
    }
    self.name = builder.clone();
  }
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Room&gt; {
  let contents = fs::read_to_string(filepath);
  let mut rooms: Vec&lt;Room&gt; = vec!();
  let binding = contents.expect("REASON");
  let re = Regex::new(r"([a-z\-]+)-([0-9]+)\[([a-z]+)\]").unwrap();
  for (_, [name, id, checksum]) in re.captures_iter(&amp;binding).map(|c| c.extract()) {
    rooms.push(Room::new(name.to_string(), id.parse().unwrap(), checksum.to_string()));
  }
  rooms
}

fn part1() {
  let rooms = read_file("INPUT");
  let res = rooms.into_iter().map(|r| if r.is_valid() {r.id} else {0}).sum::&lt;i64&gt;();
  println!("Part 1: {}", res);
}

fn part2() {
  let mut rooms = read_file("INPUT");
  let mut res: i64 = 0;
  for room in &amp;mut rooms {
    room.decrypt();
    if room.name == "northpole object storage" {
      res = room.id;
      break;
    }
  }
  println!("Part 2: {}", res);
}

fn main() {
  println!("Year 2016 day 4 - Security Through Obscurity");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2017"><a class="header" href="#advent-of-code---year-2017">Advent of code - Year 2017</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2017">year 2017</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days-2"><a class="header" href="#days-2">Days</a></h3>
<ul>
<li><a href="aoc/2017-1.html">Day 1</a></li>
<li><a href="aoc/2017-2.html">Day 2</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2017-day-1"><a class="header" href="#advent-of-code---year-2017-day-1">Advent of code - Year 2017 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2017/day/1">day 1</a>. Go back to year <a href="aoc/2017.html">2017</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-11"><a class="header" href="#info-11">Info</a></h3>
<h4 id="part-1-11"><a class="header" href="#part-1-11">Part 1</a></h4>
<p>In the first part we lineary check the two consecutive indexes and if they match add them. These are taken with modulo.</p>
<h4 id="part-2-11"><a class="header" href="#part-2-11">Part 2</a></h4>
<p>In the second part instead of looking at consecutive ones look at the ones that are hlafway apart.</p>
<h2 id="mainrs-11"><a class="header" href="#mainrs-11">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;

fn read_file(filepath: &amp;str) -&gt; String {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  binding.split('\n').next().unwrap().to_string()
}

fn part1() {
  let line = read_file("INPUT");
  let mut total: u32 = 0;
  for i in 0 .. line.len() {
    if line.chars().nth(i) == line.chars().nth((i+1) % line.len()) {
      total += line.chars().nth(i).unwrap().to_digit(10).unwrap();
    }
  }
  println!("Part 1: {}", total);
}

fn part2() {
  let line = read_file("INPUT");
  let mut total: u32 = 0;
  for i in 0 .. line.len() {
    if line.chars().nth(i) == line.chars().nth((i + line.len() / 2) % line.len()) {
      total += line.chars().nth(i).unwrap().to_digit(10).unwrap();
    }
  }
  println!("Part 2: {}", total);
}

fn main() {
  println!("Year 2017 day 1 - Inverse Captcha");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2017-day-2"><a class="header" href="#advent-of-code---year-2017-day-2">Advent of code - Year 2017 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2017/day/2">day 2</a>. Go back to year <a href="aoc/2017.html">2017</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-12"><a class="header" href="#info-12">Info</a></h3>
<h4 id="part-1-12"><a class="header" href="#part-1-12">Part 1</a></h4>
<p>In the first part we use iterations. We compute the maximums and minimums. After that we zip those together and find the subtraction and sum it up.</p>
<h4 id="part-2-12"><a class="header" href="#part-2-12">Part 2</a></h4>
<p>In the second part we go through all posibilities and test if they are divisible or not. If they are add the division to the total and break the loop for the line.</p>
<h2 id="mainrs-12"><a class="header" href="#mainrs-12">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::cmp::{max, min};
use std::iter::zip;

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Vec&lt;i64&gt;&gt; {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let numbers = binding.split('\n')
    .filter(|c| c.len() &gt; 0)
    .map(|c| c.split('\t')
      .map(|val| val.parse::&lt;i64&gt;().unwrap()).collect())
    .collect();
  numbers
}

fn part1() {
  let numbers = read_file("INPUT");
  let maximums: Vec&lt;i64&gt; = numbers.clone().into_iter()
    .map(|vec| vec.into_iter().fold(0, |acc, x| max(acc, x)))
    .collect();
  let minimums: Vec&lt;i64&gt; = numbers.into_iter()
    .map(|vec| vec.into_iter().fold(i64::MAX, |acc, x| min(acc, x)))
    .collect();
  let res = zip(minimums, maximums).map(|(a,b)| b - a).sum::&lt;i64&gt;();
  println!("Part 1: {}", res);
}

fn part2() {
  let numbers = read_file("INPUT");
  let mut total: i64 = 0;
  for num_line in numbers {
    'line: for i in 0 .. num_line.len() {
      for j in i + 1 .. num_line.len() {
        if num_line[i] % num_line[j] == 0 {
          total += num_line[i] / num_line[j];
          break 'line;
        } else if num_line[j] % num_line[i] == 0 {
          total += num_line[j] / num_line[i];
          break 'line;
        }
      }
    }
  }
  println!("Part 2: {}", total);
}

fn main() {
  println!("Year 2017 day 2 - Corruption Checksum");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021"><a class="header" href="#advent-of-code---year-2021">Advent of code - Year 2021</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2021">year 2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days-3"><a class="header" href="#days-3">Days</a></h3>
<ul>
<li><a href="aoc/2021-1.html">Day 1</a></li>
<li><a href="aoc/2021-2.html">Day 2</a></li>
<li><a href="aoc/2021-3.html">Day 3</a></li>
<li><a href="aoc/2021-4.html">Day 4</a></li>
<li><a href="aoc/2021-5.html">Day 5</a></li>
<li><a href="aoc/2021-6.html">Day 6</a></li>
<li><a href="aoc/2021-7.html">Day 7</a></li>
<li><a href="aoc/2021-8.html">Day 8</a></li>
<li><a href="aoc/2021-11.html">Day 11</a></li>
<li><a href="aoc/2021-14.html">Day 14</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-1"><a class="header" href="#advent-of-code---year-2021-day-1">Advent of code - Year 2021 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/1">day 1</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="first-partcpp"><a class="header" href="#first-partcpp">first-part.cpp</a></h2>
<pre><code class="language-cpp">#include&lt;fstream&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;

int main(int argc, char ** argv){
  std::fstream stream;
  stream.open("INPUT");
  std::string line;
  int last = -1;
  int increase = 0;
  while(getline(stream, line)){
    int new_ = std::stoi(line);
    if (last != -1 &amp;&amp; last &lt; new_){
      increase += 1;
    }
    last = new_;
  }
  std::cout &lt;&lt; increase &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<h2 id="second-partcpp"><a class="header" href="#second-partcpp">second-part.cpp</a></h2>
<pre><code class="language-cpp">#include&lt;fstream&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;array&gt;

void prepare_file(){
  std::fstream stream;
  std::ofstream file;
  file.open("output.txt");
  stream.open("input.txt");
  std::string line;
  std::array&lt;int, 3&gt; list = {0};
  while(getline(stream, line)){
      int new_ = stoi(line);
      int i = 0;
      list[0] += new_;
      file &lt;&lt; list[0] &lt;&lt; std::endl;
      list[1] += new_;
      list[2] += new_;
      list[0] = list[1];
      list[1] = list[2];
      list[2] = 0;
  }
}

int count(){
  std::fstream stream;
  stream.open("output.txt");
  std::string line;
  int last = -1;
  int increase = -2;
  while(getline(stream, line)){
    int new_ = std::stoi(line);
    if (last != -1 &amp;&amp; last &lt; new_){
      increase += 1;
    }
    last = new_;
  }
  return increase;
}

int main(int argc, char ** argv){
  prepare_file();
  int result = count();
  std::cout &lt;&lt; result &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-2"><a class="header" href="#advent-of-code---year-2021-day-2">Advent of code - Year 2021 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/2">day 2</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="maincpp"><a class="header" href="#maincpp">main.cpp</a></h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;

int main(int argc, char * * argv){
  std::ifstream stream;
  stream.open("INPUT");
  std::string line;
  int depth = 0;
  int forward = 0;
  int aim = 0;
  while(getline(stream, line)){
    int now = std::stoi(line.substr(line.length()-2, line.length()-1));
    if (line[0] == 'u'){
      aim -= now;
    }
    else if (line[0] == 'f'){
      forward += now;
      depth += (aim*now);
    }
    else{
      aim += now;
    }
  }
  std::cout &lt;&lt; "Depth: " &lt;&lt; depth &lt;&lt; ", forward: " &lt;&lt; forward &lt;&lt; std::endl;
  long mult = depth*forward;
  std::cout &lt;&lt; mult &lt;&lt; std::endl; 
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-3"><a class="header" href="#advent-of-code---year-2021-day-3">Advent of code - Year 2021 Day 3</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/3">day 3</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="first-partcpp-1"><a class="header" href="#first-partcpp-1">first-part.cpp</a></h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;
#include&lt;array&gt;

int main(int argc, char * * argv){
    std::fstream stream;
    stream.open("INPUT");
    std::string line;
    const size_t length = 12;
    std::array&lt;int, length&gt; ones = {0};
    std::array&lt;int, length&gt; zeros = {0};
    int gamma = 0;
    int epsilon = 0;
    while(getline(stream, line)){
        for (size_t i = 0; i &lt; length; ++i){
            if (line[i] == '0'){
                if (ones[i] &gt;= 1){
                    ones[i] -= 1;
                }
                else{
                    zeros[i] += 1;
                }
            }
            else if (line[i] == '1'){
                if (zeros[i] &gt;= 1){
                    zeros[i] -= 1;
                }
                else{
                    ones[i] += 1;
                }
            }
        }
    }
    int two = 2048; //16;
    int max = 0;
    for (size_t j = 0; j &lt; length; ++j){
        if (zeros[j] == 0){
            gamma += two;
        }
        else if (ones[j] == 0){
            epsilon += two;
        }
        max += two;
        two /= 2;
    }
    std::cout &lt;&lt; "Gamma: " &lt;&lt; gamma &lt;&lt; std::endl;
    std::cout &lt;&lt; "Epsilon: " &lt;&lt; epsilon &lt;&lt; std::endl;
    std::cout &lt;&lt; "Max: " &lt;&lt; max &lt;&lt; std::endl;
    std::cout &lt;&lt; "Sum: " &lt;&lt; gamma + epsilon &lt;&lt; std::endl;
    long compute = epsilon*gamma;
    std::cout &lt;&lt; compute &lt;&lt; std::endl;  
    return 0;
}
</code></pre>
<h2 id="second-partcpp-1"><a class="header" href="#second-partcpp-1">second-part.cpp</a></h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;
#include&lt;array&gt;

int write_file(std::string finput, std::string foutput, int compare, char comparison){
    std::ifstream input;
    std::ofstream output;
    input.open(finput);
    output.open(foutput);
    std::string line;
    int number = 0;
    while(getline(input, line)){
        if (line[compare] == comparison){
            output &lt;&lt; line &lt;&lt; std::endl;
            ++number;
        }
    }
    return number;
}

void compute(std::string f1, std::string f2){
    std::ifstream i1;
    std::ifstream i2;
    i1.open(f1);
    i2.open(f2);
    std::string line;
    size_t p;
    getline(i1, line);
    int first = stoi(line, &amp;p, 2);
    getline(i2, line);
    int second = stoi(line, &amp;p, 2);
    std::cout &lt;&lt; "First: " &lt;&lt; first &lt;&lt; std::endl;
    std::cout &lt;&lt; "Second: " &lt;&lt; second &lt;&lt; std::endl;
    std::cout &lt;&lt; first*second &lt;&lt; std::endl;
}

char filter_most(std::string file, int i){
    std::fstream stream;
    stream.open(file);
    std::string line;
    const size_t length = 12;
    int ones = 0;
    int zeros = 0;
    while(getline(stream, line)){
        if (line[i] == '0'){
            if (ones &gt;= 1){
                ones -= 1;
            }
            else{
                zeros += 1;
            }
        }
        else if (line[i] == '1'){
            if (zeros &gt;= 1){
                zeros -= 1;
            }
            else{
                ones += 1;
            }
        }
    }
    if (zeros == 0){
        return '1';
    }
    else{
        return '0';
    }
}

char filter_least(std::string file, int i){
    std::fstream stream;
    stream.open(file);
    std::string line;
    const size_t length = 12;
    int ones = {0};
    int zeros = {0};
    while(getline(stream, line)){
        if (line[i] == '0'){
            if (ones &gt;= 1){
                ones -= 1;
            }
            else{
                zeros += 1;
            }
        }
        else if (line[i] == '1'){
            if (zeros &gt;= 1){
                zeros -= 1;
            }
            else{
                ones += 1;
            }
        }
    }
    if (zeros == 0){
        return '0';
    }
    else{
        return '1';
    }
}

int main(int argc, char * * argv){
    std::string first = "1";
    std::string second = "2";
    char gamma = filter_most(first, 0);
    int i = 0;
    while (write_file(first, second, i, gamma) &gt; 1){
        std::string temp = second;
        second = first;
        first = temp;
        ++i;
        gamma = filter_most(first, i);
    }
    first = "3";
    second = "4";
    char epsilon = filter_least(first, 0);
    i = 0;
    while (write_file(first, second, i, epsilon) &gt; 1){
            std::string temp = second;
            second = first;
            first = temp;
            ++i;
            epsilon = filter_least(first, i);
        }
    first = "3";
    second = "1";
    compute(first, second);
    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-4"><a class="header" href="#advent-of-code---year-2021-day-4">Advent of code - Year 2021 Day 4</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/4">day 4</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="first-partcpp-2"><a class="header" href="#first-partcpp-2">first-part.cpp</a></h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;
#include&lt;array&gt;
#include&lt;vector&gt;

struct Square{
    public:
        int number;
        bool used;
};

using board = std::array&lt; std::array &lt; Square, 5&gt;, 5&gt;;

void read(std::vector&lt;int&gt;&amp; numbers, std::vector&lt;board&gt;&amp; boards){
    std::ifstream file;
    file.open("INPUT");
    std::string line;
    bool first = true;
    while (getline(file, line)){
        if (first){
            for (size_t i = 0; i &lt; line.length(); ++i){
                size_t shift = 0;
                int now = std::stoi(line.substr(i, line.length()), &amp;shift);
                i += shift;
                numbers.push_back(now);
            }
            first = false;
            getline(file, line);
        }
        else{
            board temp;
            for (size_t j = 0; j &lt; 5; ++j){
                size_t l = 0;
                for (size_t i = 0; i &lt; line.length(); ++i){
                    Square sq;
                    size_t shift;
                int now = std::stoi(line.substr(i, line.length()), &amp;shift);
                    i += shift;
                sq.number = now;
                    temp[j][l] = sq;
                    ++l;
                }
                getline(file, line);
            }
            boards.push_back(temp);
        }
    }
}

bool check (board&amp; brd){
    std::array&lt;bool, 5&gt; rows = {true, true, true, true, true};
    std::array&lt;bool, 5&gt; columns = {true, true, true, true, true};
    bool succes = false;
    for (size_t i = 0; i &lt; 5; ++i){
        for (size_t j = 0; j &lt; 5; ++j){
            rows[i] = rows[i] &amp;&amp; brd[i][j].used;
            columns[j] = columns[j] &amp;&amp; brd[i][j].used;
        }
    }
    for (size_t i = 0; i &lt; 5; ++i){
        succes = succes || rows[i];
        succes = succes || columns[i];
    }
    return succes;
}

int calculate(int number, board&amp; brd){
    int result = 0;
    for (size_t i = 0; i &lt; 5; ++i){
        for (size_t j = 0; j &lt; 5; ++j){
            if (!brd[i][j].used){
                result += brd[i][j].number;
            }
        }
    }
    std::cout &lt;&lt; "Sum: " &lt;&lt; result &lt;&lt; std::endl;
    result *= number;
    return result;
}

void print_matrix(board&amp; brd){
std::cout &lt;&lt; "Matrix:" &lt;&lt; std::endl;
for (size_t i = 0; i &lt; 5; ++i){
    for (size_t j = 0; j &lt; 5; ++j){
            std::cout &lt;&lt; brd[i][j].number &lt;&lt; ":" &lt;&lt; brd[i][j].used &lt;&lt; " ";
    }
std::cout &lt;&lt; std::endl;
}
}

int compute(std::vector&lt;int&gt;&amp; numbers, std::vector&lt;board&gt;&amp; boards){
    for (auto&amp; num : numbers){
        for (auto&amp; brd : boards){
            for (size_t i = 0; i &lt; 5; ++i){
                for (size_t j = 0; j &lt; 5; ++j){
                    if(brd[i][j].number == num){
                        brd[i][j].used = true;          
                    }
                }
            }
            if (check(brd)){
                std::cout &lt;&lt; "Number: " &lt;&lt; num &lt;&lt; std::endl;
                print_matrix(brd);
                return calculate(num, brd);
            }
        }
    }
    return 0;
}

int main(int argc, char * * argv){
    std::vector&lt;int&gt; numbers;
    std::vector&lt;board&gt; boards;
    read(numbers, boards);
    int result = compute(numbers, boards);
    std::cout &lt;&lt; result &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<h2 id="second-partcpp-2"><a class="header" href="#second-partcpp-2">second-part.cpp</a></h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;
#include&lt;array&gt;
#include&lt;vector&gt;

struct Square{
    public:
        int number;
        bool used;
};

using board = std::array&lt; std::array &lt; Square, 5&gt;, 5&gt;;

void read(std::vector&lt;int&gt;&amp; numbers, std::vector&lt;board&gt;&amp; boards){
    std::ifstream file;
    file.open("input.txt");
    std::string line;
    bool first = true;
    while (getline(file, line)){
        if (first){
            for (size_t i = 0; i &lt; line.length(); ++i){
                size_t shift = 0;
                int now = std::stoi(line.substr(i, line.length()), &amp;shift);
                i += shift;
                numbers.push_back(now);
            }
            first = false;
            getline(file, line);
        }
        else{
            board temp;
            for (size_t j = 0; j &lt; 5; ++j){
                size_t l = 0;
                for (size_t i = 0; i &lt; line.length(); ++i){
                    Square sq;
                    size_t shift;
                int now = std::stoi(line.substr(i, line.length()), &amp;shift);
                    i += shift;
                sq.number = now;
                    temp[j][l] = sq;
                    ++l;
                }
                getline(file, line);
            }
            boards.push_back(temp);
        }
    }
}

bool check (board&amp; brd){
    std::array&lt;bool, 5&gt; rows = {true, true, true, true, true};
    std::array&lt;bool, 5&gt; columns = {true, true, true, true, true};
    bool succes = false;
    for (size_t i = 0; i &lt; 5; ++i){
        for (size_t j = 0; j &lt; 5; ++j){
            rows[i] = rows[i] &amp;&amp; brd[i][j].used;
            columns[j] = columns[j] &amp;&amp; brd[i][j].used;
        }
    }
    for (size_t i = 0; i &lt; 5; ++i){
        succes = succes || rows[i];
        succes = succes || columns[i];
    }
    return succes;
}

int calculate(int number, board&amp; brd){
    int result = 0;
    for (size_t i = 0; i &lt; 5; ++i){
        for (size_t j = 0; j &lt; 5; ++j){
            if (!brd[i][j].used){
                result += brd[i][j].number;
            }
        }
    }
    std::cout &lt;&lt; "Sum: " &lt;&lt; result &lt;&lt; std::endl;
    result *= number;
    return result;
}

void print_matrix(board&amp; brd){
std::cout &lt;&lt; "Matrix:" &lt;&lt; std::endl;
for (size_t i = 0; i &lt; 5; ++i){
    for (size_t j = 0; j &lt; 5; ++j){
            std::cout &lt;&lt; brd[i][j].number &lt;&lt; ":" &lt;&lt; brd[i][j].used &lt;&lt; " ";
    }
std::cout &lt;&lt; std::endl;
}
}

int compute(std::vector&lt;int&gt;&amp; numbers, std::vector&lt;board&gt;&amp; boards){
    std::array&lt;bool, 100&gt; used_boards;
    int left = 100;
    board last;
    int lastnum;
    for (auto&amp; num : numbers){
        int index = 0;
        for (auto&amp; brd : boards){
            if (!used_boards[index]){
                for (size_t i = 0; i &lt; 5; ++i){
                    for (size_t j = 0; j &lt; 5; ++j){
                        if(brd[i][j].number == num){
                            brd[i][j].used = true;          
                        }
                    }
                }
                if (check(brd)){
                    --left;
                    used_boards[index] = true;
                    last = brd;
                    lastnum = num;
                    if (left == 0){
                        std::cout &lt;&lt; "Number: " &lt;&lt; num &lt;&lt; std::endl;
                        print_matrix(brd);
                        return calculate(num, brd);
                    }
                }
            }
            ++index;
        }
    }
    std::cout &lt;&lt; "Number: " &lt;&lt; lastnum &lt;&lt; std::endl;
    print_matrix(last);
    return calculate(lastnum, last);
}

int main(int argc, char * * argv){
    std::vector&lt;int&gt; numbers;
    std::vector&lt;board&gt; boards;
    read(numbers, boards);
    int result = compute(numbers, boards);
    std::cout &lt;&lt; result &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-5"><a class="header" href="#advent-of-code---year-2021-day-5">Advent of code - Year 2021 Day 5</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/5">day 5</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="first-partpy"><a class="header" href="#first-partpy">first-part.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

with open("INPUT") as f:
    array = []
    for i in range(1000):
        array.append([])
        for j in range(1000):
            array[i].append(0)
    for line in f:
        separate = line.split(" -&gt; ")
        first = separate[0].split(",")
        second = separate[1].split(",")
        x1 = int(first[0])
        y1 = int(first[1])
        x2 = int(second[0])
        y2 = int(second[1])
        if x1 == x2:
            if y1 &gt; y2:
                y1, y2 = y2, y1
            for i in range(y1, y2+1):
                array[x1][i] += 1
        elif y1 == y2:
            if x1 &gt; x2:
                x1, x2 = x2, x1
            for i in range(x1, x2+1):
                array[i][y1] += 1
    sum = 0
    for line in array:
        for box in line:
            if box &gt;= 2:
                sum += 1
    print(sum)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-6"><a class="header" href="#advent-of-code---year-2021-day-6">Advent of code - Year 2021 Day 6</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/6">day 6</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="first-partpy-1"><a class="header" href="#first-partpy-1">first-part.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

with open("INPUT") as f:
    line = f.readline()
    splitted = line.split(',')
    integers = []
    for box in splitted:
        integers.append(int(box))
    for i in range(80):
        for i in range(len(integers)):
            integers[i] -= 1
            if integers[i] == -1:
                integers[i] = 6
                integers.append(8)
    sum = len(integers)
    print(sum)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-7"><a class="header" href="#advent-of-code---year-2021-day-7">Advent of code - Year 2021 Day 7</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/7">day 7</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="first-partpy-2"><a class="header" href="#first-partpy-2">first-part.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

with open("input.txt") as f:
    line = f.readline()
    separated = line.split(",")
    integers = []
    for box in separated:
        integers.append(int(box))
    integers.sort()
    middle = integers[len(integers)//2]
    print(middle)
    sum = 0
    for sub in integers:
        if sub &lt;= middle:
            sum += (middle - sub)
        else:
            sum += (sub - middle)
    print(sum)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-8"><a class="header" href="#advent-of-code---year-2021-day-8">Advent of code - Year 2021 Day 8</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/8">day 8</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="first-partpy-3"><a class="header" href="#first-partpy-3">first-part.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

with open("INPUT") as f:
    stack = []
    sum = 0
    for line in f:
        for char in line:
            if char == "&lt;" or char == "(" or char == "{" or char == "[":
                stack.append(char)
            elif char == "&gt;" or char == ")" or char == "}" or char == "]":
                temp = stack.pop()
                if (temp == "&lt;" and char != "&gt;") or (temp == "(" and char != ")") or (temp == "[" and char != "]") or (temp == "{" and char != "}"):
                    if char == "&gt;":
                        sum += 25137
                    elif char == "}":
                        sum += 1197
                    elif char == ")":
                        sum += 3
                    elif char == "]":
                        sum += 57
    print(sum)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-11"><a class="header" href="#advent-of-code---year-2021-day-11">Advent of code - Year 2021 Day 11</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/11">day 11</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="first-partpy-4"><a class="header" href="#first-partpy-4">first-part.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

with open("INPUT") as f:
    array = []
    for i in range(10):
        array.append([])
        for j in range(10):
            array[i].append(0)
    index = 0
    for line in f:
        j = 0
        for char in line:
            if char != '\n':
                array[index][j] = (int(char))
                j += 1
        index += 1
    sum = 0
    for i in range(100):
        for j in range(len(array)):
            for k in range(len(array[j])):
                array[j][k] += 1
        stop = 1
        while stop == 1:
            stop = 0
            for j in range(len(array)):
                for k in range(len(array[j])):
                    if array[j][k] &gt; 9:
                        stop = 1
                        sum += 1
                        array[j][k] = 0
                        adjecent = [[j,k+1],[j+1,k],[j-1,k],[j,k-1],[j+1,k-1],[j-1,k+1],[j+1,k+1],[j-1,k-1]]
                        for ad in adjecent:
                            if ad[0] &gt;= 0 and ad[1] &gt;= 0 and ad[0] &lt; len(array) and ad[1] &lt; len(array[j]):
                                if (array[ad[0]][ad[1]] != 0):
                                    array[ad[0]][ad[1]] += 1
    print(sum)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2021-day-14"><a class="header" href="#advent-of-code---year-2021-day-14">Advent of code - Year 2021 Day 14</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2021/day/14">day 14</a>. Go back to year <a href="aoc/2021.html">2021</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="first-partpy-5"><a class="header" href="#first-partpy-5">first-part.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

with open("INPUT") as f:
    first = True
    plates = []
    second_plates = []
    rules = []
    for line in f:
        if first:
            first = False
            for j in range(len(line)-1):
                plates.append(line[j])
        else:
            t = line.split(" -&gt; ")
            t[1] = t[1][0]
            temp = [t[0], t[1]]
            rules.append(temp)
    for k in range(10):
        #print(f"Step: {k}: {plates}")
        second_plates = []
        second_plates.append(plates[0])
        for i in range(1, len(plates)):
            frst = plates[i-1]
            scnd = plates[i]
            adding = ""
            find = frst + scnd
            for j in range(len(rules)):
                if rules[j][0] == find:
                    adding = rules[j][1]
                    break
            second_plates.append(adding)
            second_plates.append(scnd)
        plates = second_plates
    found = []
    for i in range(len(plates)):
        find = False
        for j in range(len(found)):
            if found[j][0] == plates[i]:
                found[j][1] += 1
                find = True
        if find == False:
            found.append([plates[i], 0])
    maxximum = ["", 0]
    minimum = ["", 0]
    for i in range(len(found)):
        if maxximum[0] == "" or maxximum[1] &lt; found[i][1]:
            maxximum[0] = found[i][0]
            maxximum[1] = found[i][1]
        if minimum[0] == "" or minimum[1] &gt; found[i][1]:
            minimum = found[i]
    print(maxximum[1] - minimum[1])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022"><a class="header" href="#advent-of-code---year-2022">Advent of code - Year 2022</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2022">year 2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days-4"><a class="header" href="#days-4">Days</a></h3>
<ul>
<li><a href="aoc/2022-1.html">Day 1</a></li>
<li><a href="aoc/2022-2.html">Day 2</a></li>
<li><a href="aoc/2022-3.html">Day 3</a></li>
<li><a href="aoc/2022-4.html">Day 4</a></li>
<li><a href="aoc/2022-5.html">Day 5</a></li>
<li><a href="aoc/2022-6.html">Day 6</a></li>
<li><a href="aoc/2022-7.html">Day 7</a></li>
<li><a href="aoc/2022-8.html">Day 8</a></li>
<li><a href="aoc/2022-9.html">Day 9</a></li>
<li><a href="aoc/2022-11.html">Day 11</a></li>
<li><a href="aoc/2022-12.html">Day 12</a></li>
<li><a href="aoc/2022-13.html">Day 13</a></li>
<li><a href="aoc/2022-14.html">Day 14</a></li>
<li><a href="aoc/2022-15.html">Day 15</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-1"><a class="header" href="#advent-of-code---year-2022-day-1">Advent of code - Year 2022 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/1">day 1</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy"><a class="header" href="#mainpy">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

calories_max = 0
calories_sec_max = 0
calories_third_max = 0

with open('INPUT') as f:
  buffer = 0
  for line in f:
    if line == "\n":
      if buffer &gt; calories_max:
        calories_third_max = calories_sec_max
        calories_sec_max = calories_max
        calories_max = buffer
      elif buffer &gt; calories_sec_max:
        calories_third_max = calories_sec_max
        sec_max = buffer
      elif buffer &gt; calories_third_max:
        calories_third_max = buffer
      buffer = 0      
    else:
      buffer += int(line)

print(f"První: {calories_max}")
print(f"Druhý: {calories_max + sec_max + third_max}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-2"><a class="header" href="#advent-of-code---year-2022-day-2">Advent of code - Year 2022 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/2">day 2</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-1"><a class="header" href="#mainpy-1">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

WIN = 6
TIE = 3

win_sum = 0
opt_sum = 0
MODULO = 4
same = ord("X") - ord("A")

def addType(prio, pl, mod):
  tmp = (prio + 1 + pl)
  if tmp &gt;= mod:
    return tmp - mod + 1
  return tmp

with open("INPUT") as f:
  for line in f:
    fir = line[0]
    sec = line[2]
    if ord(sec) - ord(fir) == same:
      win_sum += TIE
    elif (fir == "A" and sec == "Y") or (fir == "B" and sec == "Z") or (fir == "C" and sec == "X"):
      win_sum += WIN
    win_sum += addType(ord(sec) - ord("X"), 0, MODULO)
    if sec == "Z":
      opt_sum += WIN
      opt_sum += addType(ord(fir) - ord("A"), 1, MODULO)
    elif sec == "Y":
      opt_sum += TIE
      opt_sum += addType(ord(fir) - ord("A"), 0, MODULO)
    else:
      opt_sum += addType(ord(fir) - ord("A"), 2, MODULO)
      
print(f"První: {win_sum}")
print(f"Druhý: {opt_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-3"><a class="header" href="#advent-of-code---year-2022-day-3">Advent of code - Year 2022 Day 3</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/3">day 3</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-2"><a class="header" href="#mainpy-2">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

length = ord('z') - ord('a')

def index(char):
  if ord(char) &gt; ord('Z'):
    return ord(char) - ord('a')
  else:
    return ord(char) - ord('A') + length + 1

total_sum = 0
type_sum = 0

with open("INPUT") as f:
  current = 0
  types = [True for _ in range(2*length + 2)]
  for line in f:
    if len(line) &gt; 0:
      first_half = [0 for _ in range(2*length + 2)]
      second_half = [0 for _ in range(2*length + 2)]
      current_types = [False for _ in range(2*length + 2)]
      mid = (len(line) - 1)//2
      one = line[:mid]
      two = line[mid:]
      for i in range(mid):
        first_half[index(one[i])] += 1
        second_half[index(two[i])] += 1
        current_types[index(one[i])] = True
        current_types[index(two[i])] = True
      for j in range(2*length + 2):
        total_sum += min(min(first_half[j], second_half[j]),1) * (j+1)
        types[j] = types[j] and current_types[j]
      current += 1
      if current == 3:
        current = 0;
        for j in range(2*length + 2):
          if types[j]:
            type_sum += j+1
            break
        types = [True for _ in range(2*length + 2)]
            
      
print(f"Prvni: {total_sum}")
print(f"Druha: {type_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-4"><a class="header" href="#advent-of-code---year-2022-day-4">Advent of code - Year 2022 Day 4</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/4">day 4</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-3"><a class="header" href="#mainpy-3">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

total_sum = 0
overlap_sum = 0

with open("INPUT") as f:
  for line in f:
    if line != '\n':
      comp = line.split(",")
      first = comp[0].split("-")
      second = comp[1].split("-")
      diff1 = int(first[0]) - int(second[0])
      diff2 = int(first[1]) - int(second[1])
      overlap1 = int(first[1]) - int(second[0])
      overlap2 = int(first[0]) - int(second[1])
      if (diff1 &lt;= 0 and diff2 &gt;= 0) or (diff1 &gt;= 0 and diff2 &lt;= 0):
        total_sum += 1
      if (overlap1 == 0 or overlap2 == 0) or (overlap1 &gt; 0 and overlap2 &lt; 0) or (overlap1 &lt; 0 and overlap2 &gt; 0):
        overlap_sum += 1

print(f"Prvni: {total_sum}")
print(f"Druhy: {overlap_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-5"><a class="header" href="#advent-of-code---year-2022-day-5">Advent of code - Year 2022 Day 5</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/5">day 5</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-4"><a class="header" href="#mainpy-4">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def frearrange(stack, count, fstack, tostack):
  for _ in range(count):
    if (stack[fstack] != []):
      stack[tostack].append(stack[fstack][-1])
      stack[fstack] = stack[fstack][:-1]

def srearrange(stack, count, fstack, tostack):
  realCount = min(count, len(stack[fstack]))
  tmp = stack[fstack][-realCount:]
  stack[fstack] = stack[fstack][:-realCount]
  for i in range(len(tmp)):
    stack[tostack].append(tmp[i])

def compute(rearrange, text):
  stack = [[] for _ in range(9)]
  with open("INPUT") as f:
    for line in f:
      if line != '\n':
        if line[0] != 'm' and line[1] != '1':
          for i in range(len(stack)):
            if(line[(4*i)+1]) != ' ':
              stack[i].append(line[(4*i)+1])
        elif line[1] == '1':
          for i in range(len(stack)):
            stack[i] = stack[i][::-1]
        elif line[0] == 'm':
          comp = line.split(' ')
          count = int(comp[1])
          fstack = int(comp[3]) - 1
          tostack = int(comp[5]) - 1
          rearrange(stack, count, fstack, tostack)
  print(text, end = "")
  for i in range(len(stack)):
    if stack[i] != []:
      print(stack[i][-1], end = "")
  print()

compute(frearrange, "Prvni: ")
compute(srearrange, "Druhy: ")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-6"><a class="header" href="#advent-of-code---year-2022-day-6">Advent of code - Year 2022 Day 6</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/6">day 6</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-5"><a class="header" href="#mainpy-5">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def check(array):
  sarray = sorted(array)
  for i in range(len(array) - 1):
    if sarray[i] == sarray[i+1] or sarray[i] == -1:
      return False
  return True

with open("INPUT") as f:
  for line in f:
    four = [-1 for _ in range(4)]
    message = [-1 for _ in range(14)]
    current = 0
    current_msg = 0
    first = False
    for i,char in enumerate(line):
      four[current] = ord(char)
      message[current_msg] = ord(char)
      current = (current + 1) % 4
      current_msg = (current_msg + 1) % 14
      if check(four) and not first:
        print(f"První: {i+1}")
        first = True
      if check(message):
        print(f"Druhá: {i+1}")
        break
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-7"><a class="header" href="#advent-of-code---year-2022-day-7">Advent of code - Year 2022 Day 7</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/7">day 7</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-6"><a class="header" href="#mainpy-6">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

class directory:
  def __init__(self, name, parent = ""):
    self.name = name
    self.parent = parent
    self.subdirs = []
    self.files = []
    self.tot_sum = 0
  def sum_all(self):
    for f in self.files:
      self.tot_sum += f
    for d in self.subdirs:
      self.tot_sum += d.sum_all()
    return self.tot_sum
  def add_all(self):
    tmp = 0
    if self.tot_sum &lt;= 100000:
      tmp += self.tot_sum
    for d in self.subdirs:
      tmp += d.add_all()
    return tmp
  def return_min(self, size):
    if self.tot_sum &gt; size:
      tmp = self.tot_sum
    else:  
      tmp = 70000000
    for d in self.subdirs:
      tmp = min(tmp, d.return_min(size))
    return tmp
  def same_name(self, name):
    return name == self.name
  def add_subdir(self, n, c):
    self.subdirs.append(directory(n, c))
  def cd(self, name):
    if name == '..\n':
      return self.parent
    for d in self.subdirs:
      if d.same_name(name):
        return d

root = directory('/')

with open("INPUT") as f:
  current = root
  for line in f:
    if line != '\n':
      if line[0] == '$':
        if line[2] == 'c':
          tmp = line.split(' ')
          if tmp[2] == '/\n':
            current = root
          else:
            current = current.cd(tmp[2])
      elif line[0] == 'd':
        current.add_subdir((line.split(' '))[1], current)
      else:
        number = int((line.split(' '))[0])
        current.files.append(number)

space = 70000000 - root.sum_all() 
needed = 30000000 - space
print(f"Prvni {root.add_all()}")
print(f"Druhy {root.return_min(needed)}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-8"><a class="header" href="#advent-of-code---year-2022-day-8">Advent of code - Year 2022 Day 8</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/8">day 8</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-7"><a class="header" href="#mainpy-7">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def read():
  forest = []
  with open("INPUT") as f:
    for line in f:
      tmp = line[:-1]
      forest.append([int(c) for c in tmp])
  return forest

def compute_visible(forest, visible, consti, constj, multi, multj, swap):
  for i in range(len(forest)):
    minimum = -1
    for j in range(len(forest[i])):
      if swap:
        i,j = j,i
      #print(f"Hledáme: {consti + multi*i} a {constj + multj*j}")
      if forest[consti + multi*i][constj + multj*j] &gt; minimum:
        minimum = forest[consti + multi*i][constj + multj*j]
        visible[consti + multi*i][constj + multj*j] = True
      if swap:
        i,j = j,i
  return visible

def total_sum(visible):
  tot_sum = 0
  for line in visible:
    for cell in line:
      if cell:
        tot_sum += 1
  print(f"Prvni: {tot_sum}")

def first_part(forest):
  visible = [[False for _ in range(len(a))] for a in forest]
  visible = compute_visible(forest, visible, 0, 0, 1, 1, False)
  visible = compute_visible(forest, visible, 0, len(forest)-1, 1, -1, False)
  visible = compute_visible(forest, visible, 0, 0, 1, 1, True)
  visible = compute_visible(forest, visible, len(forest)-1, 0, -1,  1, True)
  total_sum(visible)

def around(i, j, length, multi, multj):
  current_view = 0
  for l in range(length):
    if forest[i+multi*(l+1)][j+multj*(l+1)] &lt; forest[i][j]:
      current_view += 1
    else:
      current_view += 1
      break
  return current_view

def second_part(forest):
  max_score = 0
  for i in range(len(forest)):
    for j in range(len(forest[i])):
      score = 1
      score *= around(i,j, j, 0, -1)
      score *= around(i,j, len(forest[i]) - j - 1, 0, 1)
      score *= around(i,j, i, -1, 0)
      score *= around(i,j, len(forest) - i - 1, 1, 0)
      if score &gt; max_score:
        max_score = score
  print(f"Druhy: {max_score}")

forest = read()
first_part(forest)
second_part(forest)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-9"><a class="header" href="#advent-of-code---year-2022-day-9">Advent of code - Year 2022 Day 9</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/9">day 9</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-8"><a class="header" href="#mainpy-8">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

class rope:
  def __init__(self, count):
    self.head = (0,0)
    self.nodes = [(0,0) for _ in range(count)]
    self.tail = (0,0)
    self.visited = {self.tail}
  def one_close(self, fir, sec, thi, fou, eq):
    if eq*(fir - sec) &gt; eq**2:
      if thi == fou:
        second = thi
      elif thi &gt; fou:
        second = thi - 1
      else:
        second = thi + 1
      first = fir - eq
      return first, second, True
    return fir, sec, False
  def is_close(self, node1, node2):
    first, second, found = self.one_close(node1[0], node2[0], node1[1], node2[1], 1)
    if found:
      return (first,second)
    first, second, found = self.one_close(node1[0], node2[0], node1[1], node2[1], -1)
    if found:
      return (first,second)
    second, first, found = self.one_close(node1[1], node2[1], node1[0], node2[0], 1)
    if found:
      return (first,second)
    second, first, found = self.one_close(node1[1], node2[1], node1[0], node2[0], -1)
    if found:
      return (first,second)
    return (node1[0], node1[1])
  def move(self, move, length):
    for _ in range(int(length)):
      if move == 'R':
        self.head = (self.head[0], self.head[1]-1)
      elif move == 'L':
        self.head = (self.head[0], self.head[1]+1)
      elif move == 'D':
        self.head = (self.head[0]-1, self.head[1])
      elif move == 'U':
        self.head = (self.head[0]+1, self.head[1])
      self.nodes_moves()
  def nodes_moves(self):
    tmp = self.head
    for i in range(len(self.nodes)):
      self.nodes[i] = self.is_close(self.nodes[i], tmp)
      tmp = self.nodes[i]
    self.tail = self.is_close(self.tail, tmp)
    self.visited.add(self.tail)
  def get_visited(self):
    return len(self.visited)

with open("INPUT") as f:
  my_rope = rope(0)
  sec_part = rope(8)
  for line in f:
    if line != '\n':
      tmp = line.split(' ')
      my_rope.move(tmp[0],tmp[1])
      sec_part.move(tmp[0],tmp[1])
  print(f"Prvni: {my_rope.get_visited()}")
  print(f"Druhy: {sec_part.get_visited()}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-11"><a class="header" href="#advent-of-code---year-2022-day-11">Advent of code - Year 2022 Day 11</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/11">day 11</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-9"><a class="header" href="#mainpy-9">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

import operator

class Monkey:
  def __init__(self, items, operation, test, trmon, flsmon, nr):
    self.items = items
    self.operation = operation
    self.test = test
    self.counter = 0
    self.falsemonkey = flsmon
    self.truemonkey = trmon
    if nr == 'old':
      self.nr = 'old'
    else:
      self.nr = int(nr)
  def bind(self, true, false):
    self.true = true
    self.false = false
  def set_mod(self,mod):
    self.mod = mod
  def single_oper(self, item, div, mod):
    if self.nr == 'old':
      titem = self.operation(item,item)
    else:
      titem = self.operation(item, self.nr)
    if div:
      titem = titem // 3
    else:
      titem = titem % mod
    if titem % self.test == 0:
      self.true.add(titem)
    else:
      self.false.add(titem)
  def operate(self, mod, div):
    self.counter += len(self.items)
    for item in self.items:
      self.single_oper(item, div, mod)
    self.items = []
  def add(self, item):
    self.items.append(item)
  def print(self):
    print(self.items)


def read():
  monkeys = []
  with open("INPUT") as f:
    tmplist = []
    tmpoper = operator.mul;
    tmptest = 1
    truemonkey = 0
    falsemonkey = 0
    tmnr = 0
    tmmod = 1
    for line in f:
      parts = line.split(' ')
      if len(parts) &lt; 2:
        monkeys.append(Monkey(tmplist, tmpoper, tmptest, truemonkey, falsemonkey, tmnr))
        tmplist = []
      elif parts[0] == 'Monkey':
        continue
      elif parts[3] == 'items:':
        for nr in parts[4:]:
          tmplist.append(int(nr[:-1]))
      elif parts[3] == 'new':
        if parts[6] == '+':
          tmpoper = operator.add;
        else:
          tmpoper = operator.mul;
        tmnr = parts[7][:-1]
      elif parts[3] == 'divisible':
        tmptest = int(parts[5])
        tmmod *= int(parts[5])
      elif parts[5] == 'true:':
        truemonkey = int(parts[9])
      elif parts[5] == 'false:':
        falsemonkey = int(parts[9])
  for monkey in monkeys:
    monkey.bind(monkeys[monkey.truemonkey], monkeys[monkey.falsemonkey])
  return monkeys, tmmod

def common(div, count):
  monkeys, mod = read()
  for i in range(count):
    for monkey in monkeys:
      monkey.operate(mod, div)
  max1 = 0
  max2 = 0
  for monkey in monkeys:
    if max1 &lt; monkey.counter:
      max2 = max1
      max1 = monkey.counter
    elif max2 &lt; monkey.counter:
      max2 = monkey.counter
  return max1*max2

def first_part():
  print(f"Prvni: {common(True, 20)}")
  
def second_part():
  print(f"Druhy: {common(False, 10000)}")

first_part()
second_part()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-12"><a class="header" href="#advent-of-code---year-2022-day-12">Advent of code - Year 2022 Day 12</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/12">day 12</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="maincpp-1"><a class="header" href="#maincpp-1">main.cpp</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;climits&gt;
#include &lt;queue&gt;

int start[] = {0,0};
int end[] = {0,0};
std::vector&lt;int&gt; sPoints;

std::vector&lt;std::vector&lt;int&gt;&gt; read(){
  std::ifstream input = std::ifstream();
  input.open("INPUT");
  std::string line;
  std::vector&lt;std::vector&lt;int&gt;&gt; heights;
  int x = 0;
  while(getline(input, line)){
    heights.push_back(std::vector&lt;int&gt;());
    for(size_t i = 0; i &lt; line.length(); ++i){
      char c = line[i];
      if(c == 'S'){
        start[0] = x;
        start[1] = i;
        heights[x].push_back(0);
      }
      else if(c == 'E'){
        end[0] = x;
        end[1] = i;
        heights[x].push_back(int('z') - int('a'));
      }
      else if(c != '\n'){
        heights[x].push_back(int(c) - int('a'));
      }
      if (c == 'a'){
        int y = i;
        sPoints.push_back(x);
        sPoints.push_back(y);
      }
    }
    ++x;
  }
  return heights;
}

void onePath(std::queue&lt;int&gt;&amp; q, int x, int y, const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; h, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; v, int p0, int p1, int step){
  bool in_matrix = (p1 + x &gt;= 0) &amp;&amp; (p1 + y &gt;= 0) &amp;&amp; (p0 + x &lt; h.size()) &amp;&amp; (p1 + y &lt; h[0].size());
  if(!in_matrix){
    return;
  }
  bool possible =  h[p0 + x][p1 + y] &lt;= h[p0][p1] + 1;
  if(!possible){
    return;
  }
  bool worth = v[p0 + x][p1 + y] &gt; step + 1;
  if(!worth){
    return;
  }
  v[p0 + x][p1 + y] = step + 1;
  if (end[0] == p0 + x &amp;&amp; end[1] == p1 + y){
    return;
  }
  q.push(p0+x);
  q.push(p1+y);
  q.push(++step);
}

int findPath(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; h, int s0, int s1){
  std::queue&lt;int&gt; q;
  std::vector&lt;std::vector&lt;int&gt;&gt; visited;
  for(size_t i = 0; i &lt; h.size(); ++i){
    visited.push_back(std::vector&lt;int&gt;());
    for(size_t j = 0; j &lt; h[i].size(); ++j){
      visited[i].push_back(INT_MAX);
    }
  }
  visited[s0][s1] = 0;
  q.push(s0);
  q.push(s1);
  q.push(0);
  int neigh[][2] = { {-1, 0}, {1, 0}, {0, 1}, {0,-1} };
  while(!q.empty()){
    int p0 = q.front();
    q.pop();
    int p1 = q.front();
    q.pop();
    int step = q.front();
    q.pop();
    for(auto &amp;&amp; n : neigh){
      onePath(q, n[0], n[1], h, visited, p0, p1, step);
    }
  }
  return visited[end[0]][end[1]];
}

int main(int argc, char * * argv){
  std::vector&lt;std::vector&lt;int&gt;&gt; h = read();
  int min = findPath(h, start[0], start[1]);
  std::cout &lt;&lt; "Prvni: " &lt;&lt; min &lt;&lt; std::endl;
  std::cout &lt;&lt; "Druhy: ";
  for(size_t i = 0; i &lt; sPoints.size(); i += 2){
    int tmp = findPath(h, sPoints[i], sPoints[i+1]);
    if(tmp &lt; min){
      min = tmp;
    }
  }
  std::cout &lt;&lt; min &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-13"><a class="header" href="#advent-of-code---year-2022-day-13">Advent of code - Year 2022 Day 13</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/13">day 13</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-10"><a class="header" href="#mainpy-10">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3
from functools import cmp_to_key

def read(string):
  inp = []
  number = 0
  was_number = False
  i = 0
  while i &lt; len(string):
    c = string[i]
    if c == '[':
      np, index = read(string[i+1:])
      was_number = False
      inp.append(np)
      i += index + 1
    elif c == ']':
      if was_number:
        inp.append(number)
      return inp, i
    elif c == ',':
      if was_number:
        inp.append(number)
      number = 0
      was_number = False
    else:
      was_number = True
      number *= 10
      number += int(c)
    i += 1
  return np

def compare(x,y):
  if type(x) != type(y):
    return compare([x],y) if type(x) is int else compare(x,[y])
  else:
    if type(x) is int:
      if x != y:
        return -1 if x &gt; y else 1
      return 0
    else:
      for i in range(min(len(x), len(y))):
        if (res := compare(x[i], y[i])) != 0:
          return res
      if len(x) != len(y):
        return -1 if len(x) &gt; len(y) else 1
      return 0

list_all = [[[2]],[[6]]]
m = 1

with open("INPUT") as f:
  left = []
  right = []
  index = 0
  iSum = 0
  for line in f:
    if line == '\n':
      index += 1
      tmp = compare(left,right)
      if tmp != -1:
        iSum += index
    else:
      left = right
      right = read(line[:-1])
      list_all.append(right)
  print(f"Prvni {iSum}")
  s = sorted(list_all, key=cmp_to_key(lambda x, y : -compare(x,y)))
  for i in range(len(s)):
    if s[i] == [[2]]:
      m *= (i+1)
    if s[i] == [[6]]:
      m *= (i+1)
      print(f"Druhy: {m}")
      break
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-14"><a class="header" href="#advent-of-code---year-2022-day-14">Advent of code - Year 2022 Day 14</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/14">day 14</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-11"><a class="header" href="#mainpy-11">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def read(s):
  tmp = s.split(' -&gt; ')
  ret = []
  for t in tmp:
    nr = t.split(',')
    ret.append((int(nr[0]), int(nr[1])))
  return ret

d = set()

def addd(r, lo):
  index = 0
  while index+1 &lt; len(r):
    f = r[index]
    s = r[index+1]
    index += 1
    for i in range(min(f[0], s[0]), max(f[0],s[0])+1):
      for j in range(min(f[1], s[1]), max(f[1],s[1])+1):
        d.add((i,j))
        if j &gt; lo:
          lo = j
  return lo

def sand(lo):
  s = (500, 0)
  while s[1] &lt;= lo:
    if (s[0], s[1]+1) in d:
      if (s[0]-1, s[1] + 1) in d:
        if (s[0] + 1, s[1] + 1) in d:
          d.add(s)
          return 1
        s = (s[0] + 1, s[1] + 1)
        continue
      s = (s[0] - 1, s[1] + 1)
      continue
    s = (s[0], s[1] + 1)
  return 0

def sand2(lo):
  s = (500, 0)
  if s in d:
    return 0
  floor = lo + 2
  while s[1] &lt; floor:
    if (s[0], s[1]+1) in d or s[1]+1 == floor:
      if (s[0]-1, s[1] + 1) in d or s[1] +1  == floor:
        if (s[0] + 1, s[1] + 1) in d or s[1] +1 == floor:
          d.add(s)
          return 1
        s = (s[0] + 1, s[1] + 1)
        continue
      s = (s[0] - 1, s[1] + 1)
      continue
    s = (s[0], s[1] + 1)
  return 0

with open("INPUT") as f:
  lo = 0
  summ = 0
  for line in f:
    r = read(line[:-1])
    lo = addd(r, lo)
  while (sand(lo) == 1):
    summ += 1
  print(f"Prvni: {summ}")
  while sand2(lo) == 1:
    summ += 1
  print(f"Druhy: {summ}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2022-day-15"><a class="header" href="#advent-of-code---year-2022-day-15">Advent of code - Year 2022 Day 15</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2022/day/15">day 15</a>. Go back to year <a href="aoc/2022.html">2022</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-12"><a class="header" href="#mainpy-12">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

# Solution is relatively slow

class Sensor:
  def __init__(self, x, y, bx, by):
    self.x = x
    self.y = y
    self.bx = bx
    self.by = by
  def map(self, m, minx, maxx, addd, index):
    for i in range(len(m)):
      if abs(self.y - (index)) + abs(self.x - (i + minx)) &lt;= self.length():
        m[i] = True
  def map2(self, i, j):
    if abs(self.x - i) + abs(self.y - j) &lt;= self.length():
      return False, self.length() - abs(self.x - i) - abs(self.y - j)
    return True, 0
  def length(self):
    return abs(self.x-self.bx) + abs(self.y - self.by)

sensors = []
se = set()
be = set()

def read():
  with open("INPUT") as f:
    minx = 9000000
    maxx = -9000000
    for line in f:
      t = line.split(' ')
      s = Sensor(int(t[2][2:-1]), int(t[3][2:-1]), int(t[8][2:-1]), int(t[9][2:-1]))
      sensors.append(s)
      minx = min(s.x, s.bx, minx)
      maxx = max(s.x, s.bx, maxx)
      se.add((s.x,s.y))
      be.add((s.bx, s.by))
    return minx, maxx

def compute(index, minx, maxx):
  addd = max([s.length() for s in sensors])
  minx -= addd
  maxx += addd
  m = [ False for _ in range(minx, maxx+1)]
  for s in sensors:
    s.map(m, minx, maxx, addd, index)
  summ = 0
  for i, c in enumerate(m):
    if(i + minx, index) in be or (i+minx, index) in se:
      continue
    if c:
      summ += 1
  print(f"Prvni: {summ}")

def compute2(fr, to):
  mset = set()
  for i in range(to - fr + 1):
    j = 0
    while j &lt; (to - fr):
      found = True
      for s in sensors:
        f, shift = s.map2(i,j)
        found = found and f
        if not found:
          j += shift
          break
      j += 1
      if found:
        j -= 1
        print(f"Druhy: {i*4000000 + j}")
        return

minx, maxx = read()
compute(2000000, minx, maxx)
compute2(0, 4000000)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023"><a class="header" href="#advent-of-code---year-2023">Advent of code - Year 2023</a></h1>
<p>This contains tasks from the <a href="https://adventofcode.com/2023">year 2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="days-5"><a class="header" href="#days-5">Days</a></h3>
<ul>
<li><a href="aoc/2023-1.html">Day 1</a></li>
<li><a href="aoc/2023-2.html">Day 2</a></li>
<li><a href="aoc/2023-3.html">Day 3</a></li>
<li><a href="aoc/2023-4.html">Day 4</a></li>
<li><a href="aoc/2023-5.html">Day 5</a></li>
<li><a href="aoc/2023-6.html">Day 6</a></li>
<li><a href="aoc/2023-7.html">Day 7</a></li>
<li><a href="aoc/2023-8.html">Day 8</a></li>
<li><a href="aoc/2023-9.html">Day 9</a></li>
<li><a href="aoc/2023-11.html">Day 11</a></li>
<li><a href="aoc/2023-12.html">Day 12</a></li>
<li><a href="aoc/2023-13.html">Day 13</a></li>
<li><a href="aoc/2023-14.html">Day 14</a></li>
<li><a href="aoc/2023-15.html">Day 15</a></li>
<li><a href="aoc/2023-16.html">Day 16</a></li>
<li><a href="aoc/2023-17.html">Day 17</a></li>
<li><a href="aoc/2023-18.html">Day 18</a></li>
<li><a href="aoc/2023-19.html">Day 19</a></li>
<li><a href="aoc/2023-21.html">Day 21</a></li>
<li><a href="aoc/2023-22.html">Day 22</a></li>
<li><a href="aoc/2023-23.html">Day 23</a></li>
<li><a href="aoc/2023-24.html">Day 24</a></li>
<li><a href="aoc/2023-25.html">Day 25</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-1"><a class="header" href="#advent-of-code---year-2023-day-1">Advent of code - Year 2023 Day 1</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/1">day 1</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-13"><a class="header" href="#info-13">Info</a></h3>
<h4 id="part-1-13"><a class="header" href="#part-1-13">Part 1</a></h4>
<p>In the first part we delete all non-digits characters and found the first and last one.</p>
<h4 id="part-2-13"><a class="header" href="#part-2-13">Part 2</a></h4>
<p>In the second part we also replace written digits as numbers, but keep overlaps. Then again find the first and last digit.</p>
<h2 id="mainrs-13"><a class="header" href="#mainrs-13">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use regex::Regex;

fn read_file(filepath: &amp;str) -&gt; Vec&lt;String&gt; {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let lines: Vec&lt;String&gt; = binding.split('\n')
      .filter(|l| l.len() &gt; 0)
      .map(|l| l.to_string()).collect();
  lines
}

fn part1() {
  let lines = read_file("INPUT");
  let regex = Regex::new(r"[^1-9]").unwrap();
  let mut total: u32 = 0;
  for line in lines {
    let numbers = regex.replace_all(&amp;line, "");
    total += 10 * numbers.chars().nth(0).unwrap().to_digit(10).unwrap();
    total += numbers.chars().nth(numbers.len() - 1).unwrap().to_digit(10).unwrap();
  }
  println!("Part 1: {}", total);
}

fn part2() {
  let lines = read_file("INPUT");
  const LEN: usize = 9;
  let origin: [&amp;str; LEN] = [r"one", r"two", r"three", r"four", r"five", r"six", r"seven", r"eight", r"nine"];
  let new: [&amp;str; LEN] = ["o1ne", "t2wo", "th3ree", "fo4ur", "fi5ve", "s6ix", "se7ven", "ei8ght", "ni9ne"];
  let regex = Regex::new(r"[^1-9]").unwrap();
  let mut total: u32 = 0;
  for line in lines {
    let mut numbers = line.clone();
    for i in 0 .. LEN {
      let nr = Regex::new(origin[i]).unwrap();
      numbers = nr.replace_all(&amp;numbers, new[i]).to_string();
    }
    numbers = regex.replace_all(&amp;numbers, "").to_string();
    total += 10 * numbers.chars().nth(0).unwrap().to_digit(10).unwrap();
    total += numbers.chars().nth(numbers.len() - 1).unwrap().to_digit(10).unwrap();
  }
  println!("Part 2: {}", total);
}

fn main() {
  println!("Year 2023 day 1 - Trebuchet?!");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-2"><a class="header" href="#advent-of-code---year-2023-day-2">Advent of code - Year 2023 Day 2</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/2">day 2</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-14"><a class="header" href="#info-14">Info</a></h3>
<h4 id="part-1-14"><a class="header" href="#part-1-14">Part 1</a></h4>
<p>In both parts we use regexes to find red, blue and green numbers. In the first part we compare these values to the limits.</p>
<h4 id="part-2-14"><a class="header" href="#part-2-14">Part 2</a></h4>
<p>In the second part we compute the maximums.</p>
<h2 id="mainrs-14"><a class="header" href="#mainrs-14">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use regex::Regex;
use std::cmp::max;

type Colors = (i64, i64, i64);

fn read_file(filepath: &amp;str) -&gt; Vec&lt;String&gt; {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let lines: Vec&lt;String&gt; = binding.split('\n')
    .filter(|c| c.len() &gt; 0)
    .map(|c| c.to_string()).collect();
  lines
}

fn get_colors(line: &amp;str) -&gt; (i64, Vec&lt;Colors&gt;) {
  let re_game = Regex::new(r"Game ([0-9]+)").unwrap();
  let game = re_game.captures(line).unwrap()[1].parse::&lt;i64&gt;().unwrap();
  let mut colors: Vec&lt;Colors&gt; = vec!();
  let re_red = Regex::new(r"([0-9]+) red").unwrap();
  let re_blue = Regex::new(r"([0-9]+) blue").unwrap();
  let re_green = Regex::new(r"([0-9]+) green").unwrap();
  for part in line.split(';') {
    let mut red = 0_i64;
    for (_, [number]) in re_red.captures_iter(part).map(|c| c.extract()) {
      red += number.parse::&lt;i64&gt;().unwrap();
    }
    let mut blue = 0_i64;
    for (_, [number]) in re_blue.captures_iter(part).map(|c| c.extract()) {
      blue += number.parse::&lt;i64&gt;().unwrap();
    }
    let mut green = 0_i64;
    for (_, [number]) in re_green.captures_iter(part).map(|c| c.extract()) {
      green += number.parse::&lt;i64&gt;().unwrap();
    }
    colors.push((red, green, blue));
  }
  (game, colors)
}

fn part1() {
  let lines = read_file("INPUT");
  let limits: [i64; 3] = [12, 13, 14];
  let mut total: i64 = 0;
  for line in lines {
    let (game, colors) = get_colors(&amp;line);
    let feasible: bool = colors.into_iter()
        .map(|(r, g, b)| r &lt;= limits[0] &amp;&amp; g &lt;= limits[1] &amp;&amp; b &lt;= limits[2])
        .fold(true, |acc, x| acc &amp;&amp; x);
    if feasible {
      total += game;
    }
  }
  println!("Part 1: {}", total);
}

fn part2() {
  let lines = read_file("INPUT");
  let mut total: i64 = 0;
  for line in lines {
    let (_game, colors) = get_colors(&amp;line);
    let maxes = colors.into_iter()
      .fold((0,0,0), |acc, (r, g, b)| (max(acc.0, r), max(acc.1, g), max(acc.2, b)));
    total += maxes.0 * maxes.1 * maxes.2;
  }
  println!("Part 2: {}", total);
}

fn main() {
  println!("Year 2023 day 2 - Cube Conundrum");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-3"><a class="header" href="#advent-of-code---year-2023-day-3">Advent of code - Year 2023 Day 3</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/3">day 3</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-13"><a class="header" href="#mainpy-13">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

triplets = [[] for _ in range(3)]
first_sum = 0
second_sum = 0

GEAR = "*"
TAIL = -1

def is_special(char):
  return char != '.' and not char.isdigit()

def transform_row(row):
  """ Get the numbers and put it in the begining position
      and as the tail insert -1. Otherwise 0. """
  number = 0
  index = 0
  new_row = [0 for _ in row]
  for i in range(len(row)):
    if row[i].isdigit():
      if number == 0:
        index = i
      number = number * 10 + int(row[i])
    else:
      new_row[index] = number
      for j in range(index+1, i):
        new_row[j] = TAIL
      index = i
      number = 0
  return new_row

def get_number(row, index, r_index):
  """ Get the number at this index in the row. """
  if index &lt; 0 or index &gt;= len(row):
    return (0, -1)
  i = 0
  while row[index - i] == TAIL:
    i += 1
  return (row[index - i], index - i, r_index)

def scan_gears(t_triplets, triplets):
  """ Scan the gears for the middle triplet. """
  my_sum = 0
  for i in range(len(triplets[1])):
    if triplets[1][i] == GEAR:
      numbers = [get_number(t_triplets[0], i-1, 0),
                 get_number(t_triplets[0], i  , 0),
                 get_number(t_triplets[0], i+1, 0),
                 get_number(t_triplets[1], i-1, 1),
                 get_number(t_triplets[1], i+1, 1),
                 get_number(t_triplets[2], i-1, 2),
                 get_number(t_triplets[2], i  , 2),
                 get_number(t_triplets[2], i+1, 2)]
      numbers = filter(lambda part : part[0] &gt; 0, numbers)
      numbers = list(dict.fromkeys(numbers))
      if len(numbers) == 2:
        my_sum = my_sum + numbers[0][0] * numbers[1][0]
  return my_sum

def sum_middle(row, scan):
  """ Sum those numbers that are scanned.
      At least one scan throughout the number. """
  number = 0
  my_sum = 0
  scanned = False
  for i in range(len(row)):
    if row[i].isdigit():
      number = number * 10 + int(row[i])
      if scan[i]:
        scanned = scan[i]
    else:
      if scanned:
        my_sum = my_sum + number
      number = 0
      scanned = False
  if scanned and number != 0:
    my_sum = my_sum + number
  return my_sum

def scan_middle(triplets):
  """ Scan the middle row if each char has
      special character near him. """
  scanning = [False for _ in triplets[1]]
  for i in range(len(triplets[1])):
    if i &gt; 0 and is_special(triplets[1][i-1]):
      scanning[i] = True
    elif i &lt; len(triplets[1]) - 1 and is_special(triplets[1][i+1]):
      scanning[i] = True
    for j in range(i - 1, i+2):
      for t in [triplets[0], triplets[2]]:
        if j &gt;= 0 and j &lt; len(t) and is_special(t[j]):
          scanning[i] = True
  return sum_middle(triplets[1], scanning)

with open('INPUT') as f:
  for line in f:
    triplets[0], triplets[1] = triplets[1], triplets[2]
    triplets[2] = [c for c in line.strip()]
    first_sum += scan_middle(triplets)
    second_sum += scan_gears([transform_row(triplets[0]), transform_row(triplets[1]), transform_row(triplets[2])], triplets)
  triplets[0], triplets[1], triplets[2] = triplets[1], triplets[2], []
  first_sum += scan_middle(triplets)
  second_sum += scan_gears([transform_row(triplets[0]), transform_row(triplets[1]), transform_row(triplets[2])], triplets)

print(f"First part: {first_sum}")
print(f"Second sum: {second_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-4"><a class="header" href="#advent-of-code---year-2023-day-4">Advent of code - Year 2023 Day 4</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/4">day 4</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-14"><a class="header" href="#mainpy-14">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

# Out of curiosity I got the time my solution.
import time

first_sum = 0
second_sum = 0

tic = time.perf_counter()

with open('INPUT') as f:
  multiples = [1]
  for line in f:
    if len(multiples) == 0:
      multiples.append(1)
    hand = line.strip().split(":")
    types = hand[1].strip().split("|")
    winning = types[0].strip().split(" ")
    winning = filter(lambda nr : len(nr) &gt; 0, winning)
    win_set = set([int(w) for w in winning])
    having = types[1].strip().split(" ")
    having = filter(lambda nr : len(nr) &gt; 0, having)
    hav_set = set([int(h) for h in having])
    res = win_set.intersection(hav_set)
    for i in range(len(res)):
      if i + 1 &gt;= len(multiples):
        multiples.append(1)
      multiples[i+1] += multiples[0]
    second_sum += multiples[0]
    multiples.pop(0)
    points = 0
    if len(res) &gt; 0:
      points = 2 ** (len(res) - 1)
    first_sum += points

toc = time.perf_counter()

print(f"First part: {first_sum}")
print(f"Second part: {second_sum}")
print(f"Time: {((toc - tic) * 1000):3f} ms")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-5"><a class="header" href="#advent-of-code---year-2023-day-5">Advent of code - Year 2023 Day 5</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/5">day 5</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-15"><a class="header" href="#mainpy-15">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

seeds = []
range_seeds = []
"""
[(begining, size, True/False), ...
Each time we split one tuple.
"""

def interval(f, f_beg, t_beg, size):
  if f &gt;= f_beg and f &lt;= f_beg + size:
    return ((f - f_beg) + t_beg, True)
  return (0, False)

def range_interval(f, f_size, f_beg, t_beg, size):
  beg_inside = f &gt;= f_beg and f &lt;= f_beg + size
  end_inside = f + f_size &gt;= f_beg and f + f_size &lt;= f_beg + size
  outside = f &lt; f_beg and f + f_size &gt; f_beg + size

  interval_beg = f
  interval_end = f + f_size
  from_begining = f_beg
  from_end = f_beg + size
  shift = - f_beg + t_beg

  if beg_inside and end_inside:
    return [((f - f_beg) + t_beg, f_size, True)]
  elif beg_inside:
    return [(interval_beg + shift, from_end - interval_beg + 1, True), (from_end + 1, interval_end - from_end - 1, False)]
  elif end_inside:
    return [(from_begining + shift, interval_end - from_begining, True), (interval_beg, from_begining - interval_beg, False)]
  elif outside:
    return [(from_begining + shift, size, True), (interval_beg, from_begining - interval_beg + 1, False), (from_end, interval_end - from_end + 1, False)]
  else:
    return []

def reset(seeds):
  for i in range(len(seeds)):
    seeds[i] = (seeds[i][0], False)

def reset_range(seeds):
  for i in range(len(seeds)):
    seeds[i] = (seeds[i][0], seeds[i][1], False)

with open('INPUT') as f:
  for line in f:
    parts = line.strip().split(" ")
    if parts[0] == "seeds:":
      for i in range(1, len(parts)):
        seeds.append((int(parts[i]), False))
      for i in range(1, len(parts), 2):
        range_seeds.append((int(parts[i]), int(parts[i+1]), False))
    elif len(parts[0]) == 0 or not parts[0][0].isdigit():
      reset(seeds)
      reset_range(range_seeds)
    else:
      t_beg = int(parts[0])
      f_beg = int(parts[1])
      size = int(parts[2])
      for i in range(len(seeds)):
        if not seeds[i][1]:
          ret = interval(seeds[i][0], f_beg, t_beg, size)
          if ret[1]:
            seeds[i] = ret
      for i in range(len(range_seeds)):
        if not range_seeds[i][2]:
          ret = range_interval(range_seeds[i][0], range_seeds[i][1], f_beg, t_beg, size)
          if ret != []:
            range_seeds.pop(i)
          for j in range(len(ret)):
            range_seeds.insert(i, ret[j])

real_seeds = [x[0] for x in seeds]
real_range_seeds = [x[0] for x in range_seeds]
print(f"First part: {min(real_seeds)}")  
print(f"Second part: {min(real_range_seeds)}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-6"><a class="header" href="#advent-of-code---year-2023-day-6">Advent of code - Year 2023 Day 6</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/6">day 6</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-16"><a class="header" href="#mainpy-16">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

times = []
records = []
tot_time = 0
tot_record = 0

first_sum = 1
second_sum = 0

def ignore_space(string):
  num = 0
  for c in string:
    if c.isdigit():
      num = num * 10 + int(c)
  return num

with open('INPUT') as f:
  for line in f:
    parts = list(filter(lambda part : len(part) &gt; 0, line.strip().split(" ")))
    splitted_line = line.strip().split(":")
    if splitted_line[0] == "Time":
      times = [int(x) for x in parts[1:]]
      tot_time = ignore_space(splitted_line[1].strip())
    else:
      records = [int(x) for x in parts[1:]]
      tot_record = ignore_space(splitted_line[1].strip())

for i in range(len(times)):
  counter = 0
  for t in range(times[i]):
    speed = t
    remaining_time = times[i] - t
    travel = speed * remaining_time
    if travel &gt; records[i]:
      counter += 1
  first_sum *= counter


"""
This may not be fast, but it will do.
"""

for t in range(tot_time):
  speed = t
  remaining_time = tot_time - t
  travel = speed * remaining_time
  if travel &gt; tot_record:
    second_sum += 1

print(f"First part: {first_sum}")
print(f"Second sum: {second_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-7"><a class="header" href="#advent-of-code---year-2023-day-7">Advent of code - Year 2023 Day 7</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/7">day 7</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="maincpp-2"><a class="header" href="#maincpp-2">main.cpp</a></h2>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;

const char JOKER = 'J';

std::map&lt;char, int&gt; mapping = { {'A', 12},
                              {'K', 11},
                              {'Q', 10},
                              {'J',  9},
                              {'T',  8},
                              {'9',  7},
                              {'8',  6},
                              {'7',  5},
                              {'6',  4},
                              {'5',  3},
                              {'4',  2},
                              {'3',  1},
                              {'2',  0} };

struct Hand{
  std::string hand;
  int bet;
  int rating;
  void compute_rating(){
    std::map&lt;char, int&gt; counters = { {'A', 0}, {'K', 0}, {'Q', 0}, {'J', 0},
                                     {'T', 0}, {'9', 0}, {'8', 0}, {'7', 0},
                                     {'6', 0}, {'5', 0}, {'4', 0}, {'3', 0},
                                     {'2', 0} };
    for(size_t i = 0; i &lt; hand.size(); ++i)
      ++counters[hand[i]];
    size_t fives = 0;
    size_t fours = 0;
    size_t threes = 0;
    size_t twos = 0;
    for(auto&amp;&amp; [key, counter] : counters){
      if(counter == 5) ++fives;
      else if(counter == 4) ++fours;
      else if (counter == 3) ++threes;
      else if (counter == 2) ++twos;
    }
    if(fives == 1) rating = 6;
    else if(fours == 1) rating = 5;
    else if(threes == 1 &amp;&amp; twos == 1) rating = 4;
    else if (threes == 1) rating = 3;
    else if (twos == 2) rating = 2;
    else if (twos == 1) rating = 1;
    else rating = 0;
  }
  void compute_joker_rating(){
    std::map&lt;char, int&gt; counters = { {'A', 0}, {'K', 0}, {'Q', 0}, {'J', 0},
                                     {'T', 0}, {'9', 0}, {'8', 0}, {'7', 0},
                                     {'6', 0}, {'5', 0}, {'4', 0}, {'3', 0},
                                     {'2', 0}, {'J' , 0} };
    for(size_t i = 0; i &lt; hand.size(); ++i)
      ++counters[hand[i]];
    size_t jokers = counters[JOKER];
    char max;
    int m = -1;
    for(auto&amp;&amp; [key, counter] : counters){
      if(key == JOKER) continue;
      else if(m &lt; counter){
        m = counter;
        max = key;
      }
    }
    size_t fives = 0;
    size_t fours = 0;
    size_t threes = 0;
    size_t twos = 0;
    for(auto&amp;&amp; [key, counter] : counters){
      if(key == JOKER) continue;
      if(key == max){
        if(counter + jokers == 5) ++fives;
        else if(counter + jokers == 4) ++fours;
        else if (counter + jokers == 3) ++threes;
        else if (counter + jokers == 2) ++twos;
      }
      else{
        if(counter == 5) ++fives;
        else if(counter == 4) ++fours;
        else if (counter == 3) ++threes;
        else if (counter == 2) ++twos;
      }
    }
    if(fives == 1) rating = 6;
    else if(fours == 1) rating = 5;
    else if(threes == 1 &amp;&amp; twos == 1) rating = 4;
    else if (threes == 1) rating = 3;
    else if (twos == 2) rating = 2;
    else if (twos == 1) rating = 1;
    else rating = 0;
  }
  void read(const std::string&amp; line){
    std::stringstream ss;
    for(size_t i = 0; i &lt; line.size(); ++i){
      if(line[i] == ' '){
        bet = std::stoi(line.substr(i+1));
        break;
      }
      else ss &lt;&lt; line[i];
    }
    hand = ss.str();
  }
};

bool operator&lt;(const Hand&amp; h1, const Hand&amp; h2){
  if(h1.rating &lt; h2.rating)
    return true;
  else if(h2.rating &lt; h1.rating)
    return false;
  else{
    size_t i = 0;
    for(; mapping[h1.hand[i]] == mapping[h2.hand[i]] &amp;&amp; i &lt; h1.hand.size(); ++i){}
    if (mapping[h1.hand[i]] &gt; mapping[h2.hand[i]])
      return false;
    return true;
  }
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Hand&amp; h){
  os &lt;&lt; "Hand: " &lt;&lt; h.hand &lt;&lt; " rating: " &lt;&lt; h.rating &lt;&lt; " bet: " &lt;&lt; h.bet;
  return os;
}

void read_file(const std::string&amp; file, std::vector&lt;Hand&gt;&amp; hands){
  std::ifstream ifs;
  ifs.open(file);
  std::string line;
  while(getline(ifs, line)){
    Hand h;
    h.read(line);
    hands.push_back(h);
  }
}

int sum(const std::vector&lt;Hand&gt;&amp; hands){
  int my_sum = 0;
  for(size_t i = 0; i &lt; hands.size(); ++i){
    my_sum += (i+1) * hands[i].bet;
  }
  return my_sum;
}

int main(int argc, char** argv){
  std::vector&lt;Hand&gt; hands;
  read_file("INPUT", hands);
  for(auto&amp;&amp; h : hands)
    h.compute_rating();
  std::sort(hands.begin(), hands.end());
  std::cout &lt;&lt; "First part: " &lt;&lt; sum(hands) &lt;&lt; std::endl;
  for(auto&amp;&amp; h : hands)
    h.compute_joker_rating();
  mapping[JOKER] = -1;
  std::sort(hands.begin(), hands.end());
  std::cout &lt;&lt; "Second part: " &lt;&lt; sum(hands) &lt;&lt; std::endl;
  
  return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-8"><a class="header" href="#advent-of-code---year-2023-day-8">Advent of code - Year 2023 Day 8</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/8">day 8</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-17"><a class="header" href="#mainpy-17">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

""" Initialization. """
moves = ""
mapping = dict()
move = {'L' : 0, 'R' : 1}
starting_nodes = list()
ending_nodes = list()
start = 'AAA'
end = 'ZZZ'

""" Read input. """
with open('INPUT') as f:
  for line in f:
    if len(line.strip()) != 0:
      if moves == "":
        moves = line.strip()
      else:
        from_to = line.strip().split(" = ")
        mapping[from_to[0]] = from_to[1][1:-1].split(", ")
        if from_to[0][-1] == 'A':
          starting_nodes.append(from_to[0])
        elif from_to[0][-1] == 'Z':
          ending_nodes.append(from_to[0])

def find(moves, mapping, move, point, end):
  """ Find path from point to some point in the end.
      Using moves and given mapping. """
  counter = 0
  while True:
    for c in moves:
      point = mapping[point][move[c]]
      counter += 1
      if point in end:
        return counter

def gcd(a, b):
  """ Greatest common denominator. """
  if a &lt; b:
    a, b = b, a
  while b != 0:
    t = b
    b = a % b
    a = t
  return a

def lcm(a, b):
  """ Least common multiple. """
  return (a * b) / gcd(a, b)

def lcm_list(lengths):
  """ Least common multiple for more numbers. """
  numbers = [j for j in lengths]
  while len(numbers) &gt; 1:
    first, second = numbers[0], numbers[1]
    numbers.pop(0)
    numbers.pop(0)
    numbers.append(lcm(first, second))
  return int(numbers[0])

def find_common(moves, mapping, move, starting_nodes, ending_nodes):
  """ Find common number for multiple paths. """
  lengths = set()
  for point in starting_nodes:
    lengths.add(find(moves, mapping, move, point, ending_nodes))
  return lcm_list(lengths)

print(f"First part: {find(moves, mapping, move, start, [end])}")
print(f"Second part: {find_common(moves, mapping, move, starting_nodes, ending_nodes)}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-9"><a class="header" href="#advent-of-code---year-2023-day-9">Advent of code - Year 2023 Day 9</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/9">day 9</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-18"><a class="header" href="#mainpy-18">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

first_sum = 0
second_sum = 0

def all_zero(array):
  return all([x == 0 for x in array])

def diffs(array):
  new_array = []
  for i in range(len(array) - 1):
    new_array.append(array[i+1] - array[i])
  return new_array

def create_history(array):
  hist = [array]
  while not all_zero(hist[-1]):
    hist.append(diffs(hist[-1]))
  return hist

def propagate(hist):
  hist[-1].append(0)
  for i in range(1, len(hist)):
    size = len(hist) - i - 1
    hist[size].append(hist[size + 1][-1] + hist[size][-1])
  return hist

def propagate_first(hist):
  hist[-1].insert(0, 0)
  for i in range(1, len(hist)):
    size = len(hist) - i - 1
    hist[size].insert(0, hist[size][0] - hist[size + 1][0])

with open('INPUT') as f:
  for line in f:
    hist = create_history([int(x) for x in line.strip().split(" ")])
    propagate(hist)
    propagate_first(hist)
    first_sum += hist[0][-1]
    second_sum += hist[0][0]

print(f"First part: {first_sum}")
print(f"Second part: {second_sum}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-11"><a class="header" href="#advent-of-code---year-2023-day-11">Advent of code - Year 2023 Day 11</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/11">day 11</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-19"><a class="header" href="#mainpy-19">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

original_map = []

def find_galaxies(original_map):
  galaxies = []
  for i in range(len(original_map)):
    for j in range(len(original_map[i])):
      if original_map[i][j] == "#":
        galaxies.append((i,j))
  return galaxies

def empty_list(array):
  return all([x == "." for x in array])

def empty(original_map):
  rows = []
  columns = []
  for i in range(len(original_map)):
    if empty_list(original_map[i]):
      columns.append(i)
  for j in range(len(original_map[0])):
    if empty_list([original_map[x][j] for x in range(len(original_map))]):
      rows.append(j)
  return rows, columns

def expand(gal, rows, columns, addition):
  for i in range(len(gal)):
    add = 0
    original = True
    for r in rows:
      if r &lt; gal[i][1]:
        add += addition
      else:
        gal[i] = (gal[i][0], gal[i][1] + add)
        original = False
        break
    if original:
      gal[i] = (gal[i][0], gal[i][1] + add)
    add = 0
    original = True
    for c in columns:
      if c &lt; gal[i][0]:
        add += addition
      else:
        gal[i] = (gal[i][0] + add, gal[i][1])
        original = False
        break
    if original:
      gal[i] = (gal[i][0] + add, gal[i][1])

def length(gal):
  total = 0
  for i in range(len(gal)):
    for j in range(i + 1, len(gal)):
      dist = abs(gal[i][0] - gal[j][0]) + abs(gal[i][1] - gal[j][1])
      total += dist
  return total

with open('INPUT') as f:
  for line in f:
    original_map.append([x for x in line.strip()])

galaxies = find_galaxies(original_map)
rows, columns = empty(original_map)
expand(galaxies, rows, columns, 2 - 1)
print(f"First part: {length(galaxies)}")
galaxies = find_galaxies(original_map)
expand(galaxies, rows, columns, 1_000_000 - 1)
print(f"Second part: {length(galaxies)}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-12"><a class="header" href="#advent-of-code---year-2023-day-12">Advent of code - Year 2023 Day 12</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/12">day 12</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-20"><a class="header" href="#mainpy-20">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def count_placements(groups, clusters, cache = dict()):
  key = "|".join(map(str, groups))
  key += "#" + ":".join(clusters)
  if key in cache:
    return cache[key]

  if not groups:
    for cluster in clusters:
      if '#' in cluster:
        return 0
    return 1
  if not clusters:
    return 0
  ret = 0
  cluster = clusters[0]
  group = groups[0]
  len_cluster = len(cluster)
  if group &gt; len_cluster and '#' in cluster:
    return 0
  for i in range(len_cluster - group + 1):
    left = cluster[:i]
    if '#' in left:
      continue
    right = cluster[i + group:]
    if right.startswith('#'):
      continue
    new_clusters = clusters[1:]
    if len(right) &gt; 1:
      new_clusters.insert(0, right[1:])
    ret += count_placements(groups[1:], new_clusters, cache)

  if '#' not in cluster:
    ret += count_placements(groups, clusters[1:], cache)

  cache[key] = ret

  return ret


def compute(expand):
  total = 0
  with open('INPUT', 'r') as file:
    for line in file:
      springs, groups_str = line.strip().split()
      groups = [int(x) for x in groups_str.split(",")]
      if expand:
        springs = "?".join(5 * [springs])
        groups = 5 * groups
      clusters = [s for s in springs.split('.') if s]
      delta = count_placements(groups, clusters)
      total += delta
  return total

def part1():
  return compute(False)

def part2():
  return compute(True)

print(f"First part: {part1()}")
print(f"Second part: {part2()}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-13"><a class="header" href="#advent-of-code---year-2023-day-13">Advent of code - Year 2023 Day 13</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/13">day 13</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h2 id="mainpy-21"><a class="header" href="#mainpy-21">main.py</a></h2>
<pre><code class="language-py">#!/usr/bin/env python3

def differences(array1, array2):
  return sum([array1[i] != array2[i] for i in range(len(array1))])

def column_symmetry(matrix, smudges):
  for i in range(1, len(matrix[0])):
    shift = 0
    total = 0
    while i - shift - 1 &gt;= 0 and i + shift &lt;= len(matrix[0]) - 1 and total &lt;= smudges:
      first_column = [matrix[j][i + shift] for j in range(len(matrix))]
      second_column = [matrix[j][i - shift - 1] for j in range(len(matrix))]
      total += differences(first_column, second_column)
      shift += 1
    if total == smudges:
      return i
  return 0

def row_symmetry(matrix, smudges):
  for i in range(1, len(matrix)):
    shift = 0
    total = 0
    while i - shift - 1 &gt;= 0 and i + shift &lt;= len(matrix) - 1 and total &lt;= smudges:
      first_row = matrix[i + shift]
      second_row = matrix[i - shift - 1]
      total += differences(first_row, second_row)
      shift += 1
    if total == smudges:
      return i
  return 0

def compute(matrix, smudges):
  ret = 0
  if smudges:
    ret = column_symmetry(matrix, 1)
    ret += row_symmetry(matrix, 1) * 100
  else:
    ret = column_symmetry(matrix, 0)
    ret += row_symmetry(matrix, 0) * 100
  return ret

def find_mirror(smudges):
  with open('INPUT') as f:
    total = 0
    matrix = []
    for line in f:
      if line.strip() == "":
        total += compute(matrix, smudges)
        matrix = []
      else:
        matrix.append([x for x in line.strip()])
    total += compute(matrix, smudges)
    return total

if __name__ == "__main__":
  print(f"First part: {find_mirror(False)}")
  print(f"Second part: {find_mirror(True)}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-14"><a class="header" href="#advent-of-code---year-2023-day-14">Advent of code - Year 2023 Day 14</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/14">day 14</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-15"><a class="header" href="#info-15">Info</a></h3>
<h4 id="part-1-15"><a class="header" href="#part-1-15">Part 1</a></h4>
<p>In the first part we create a grid of all stones and shift it to one north side and then compute it.</p>
<h4 id="part-2-15"><a class="header" href="#part-2-15">Part 2</a></h4>
<p>In the second part we cycle the shifts counterclockwis and always remember current number of cycle and how the map looked. If we encounter the same situation we take a shortcut by skipping all repeating cycles and only finish the last ones.</p>
<h2 id="mainrs-15"><a class="header" href="#mainrs-15">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::collections::HashMap;

const NOT_FREE : usize = usize::MAX;

#[derive(PartialEq)]
enum Side{
  North,
  South,
  West,
  East
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Vec&lt;char&gt;&gt;{
  let contents = fs::read_to_string(filepath);
  let mut matrix: Vec&lt;Vec&lt;char&gt;&gt; = vec![];
  let mut line: Vec&lt;char&gt; = vec!();
  for c in contents.expect("REASON").chars(){
    if c != '\n'{
      line.push(c);
    }
    else{
      matrix.push(line.clone());
      line.clear();
    }
  }
  return matrix;
}

fn compute_position(row: usize, column: usize, by_row: bool, reverse: bool, shift: usize) -&gt; (usize, usize, bool){
  if by_row{
    if !reverse{
      return (row + shift, column, false);
    }
    else{
      return (row - shift, column, row - shift == 0);
    }
  }
  if !reverse{
    return (row, column + shift, false);
  }
  else{
    return (row, column - shift, column - shift == 0);
  }
}

fn shift_array(matrix: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;, row_start : usize, column_start : usize, by_row: bool, reverse: bool){
  let mut shift: usize = 0;
  let mut free: usize = NOT_FREE;
  let (mut row, mut column, mut last) = compute_position(row_start, column_start, by_row, reverse, shift);
  while row &lt; matrix.len() &amp;&amp; column &lt; matrix[row].len(){
    if matrix[row][column] == '.' &amp;&amp; free == NOT_FREE{
      if by_row{
        free = row;
      }
      else {
        free = column;
      }
    }
    else if matrix[row][column] == '#'{
      free = NOT_FREE;
    }
    else if matrix[row][column] == 'O' &amp;&amp; free != NOT_FREE{
      if by_row {
        matrix[free][column] = 'O';
        matrix[row][column] = '.';
      }
      else{
        matrix[row][free] = 'O';
        matrix[row][column] = '.';
      }
      if reverse{
        free = free - 1;
      }
      else{
        free = free + 1;
      }
    }
    shift += 1;
    if last{
      return;
    }
    (row, column, last) = compute_position(row_start, column_start, by_row, reverse, shift);
  }
}

fn shift_side(matrix: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;, side: Side){
  match side{
    Side::North =&gt; {
      for i in 0..matrix[0].len(){
        shift_array(matrix, 0, i, true, false);
      }
    },
    Side::South =&gt; {
      for i in 0..matrix[0].len(){
        shift_array(matrix, matrix.len() - 1, i, true, true);
      }
    },
    Side::East =&gt; {
      for i in 0..matrix[0].len(){
        shift_array(matrix, i, matrix[i].len() - 1, false, true);
      }
    },
    Side::West =&gt; {
      for i in 0..matrix[0].len(){
        shift_array(matrix, i, 0, false, false);
      }
    },
  }
}

fn cycle(matrix: &amp;mut Vec&lt;Vec&lt;char&gt;&gt;){
  shift_side(matrix, Side::North);
  shift_side(matrix, Side::West);
  shift_side(matrix, Side::South);
  shift_side(matrix, Side::East);
}

fn compute(matrix: &amp;Vec&lt;Vec&lt;char&gt;&gt;) -&gt; usize{
  let size: usize = matrix.len();
  let mut ret: usize = 0;
  for i in 0..size{
    for j in 0..matrix[i].len(){
      if matrix[i][j] == 'O'{
        ret += size;
        ret -= i
      }
    }
  }
  return ret;
}

fn insert_to_history(matrix: &amp; Vec&lt;Vec&lt;char&gt;&gt;, history: &amp;mut HashMap&lt;String, i64&gt;, cycle: i64) -&gt; i64{
  let mut key: String = String::from("");
  for i in 0..matrix.len(){
    for j in 0..matrix[i].len(){
      key.push(matrix[i][j]);
    }
  }
  if history.contains_key(&amp;key){
    return history[&amp;key];
  }
  history.insert(key, cycle);
  return -1;
}

fn part1() {
  let mut matrix = read_file("INPUT");
  shift_side(&amp;mut matrix, Side::North);
  println!("Part 1: {}", compute(&amp;matrix));
}

fn part2() {
  let mut matrix = read_file("INPUT");
  let mut history: HashMap&lt;String, i64&gt; = HashMap::new();
  let cycles:i64 = 1_000_000_000;
  for i in 0..cycles{
    cycle(&amp;mut matrix);
    let rep: i64 = insert_to_history(&amp;matrix, &amp;mut history, i);
    if rep != -1{
      let m: i64 = (1_000_000_000 - rep) % (i - rep) - 1;
      for _ in 0..m{
        cycle(&amp;mut matrix);
      }
      println!("Part 2: {}", compute(&amp;matrix));
      return;
    }
  }
  println!("Part 2: {}", compute(&amp;matrix));
}

fn main() {
  println!("Year 2023 day 14 - Parabolic Reflector Dish");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-15"><a class="header" href="#advent-of-code---year-2023-day-15">Advent of code - Year 2023 Day 15</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/15">day 15</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-16"><a class="header" href="#info-16">Info</a></h3>
<h4 id="part-1-16"><a class="header" href="#part-1-16">Part 1</a></h4>
<p>In the first part we just straightforwardly compute the given acii hash.</p>
<h4 id="part-2-16"><a class="header" href="#part-2-16">Part 2</a></h4>
<p>In the second part we create  <code>hash_map</code> from vector and linked list. Then proceed the given instructions wit hthe ascii hash.</p>
<h2 id="mainrs-16"><a class="header" href="#mainrs-16">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::collections::LinkedList;

fn read_file(filepath: &amp;str) -&gt; Vec&lt;String&gt;{
  let contents = fs::read_to_string(filepath);
  let mut strings: Vec&lt;String&gt; = vec!();
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  for line in lines{
    let inputs = line.split(',');
    for input in inputs{
      if input != ""{
        strings.push(input.to_string());
      }
    }
  }
  return strings;
}

fn ascii_hash(string: &amp;str) -&gt; i32{
  let mut hash: i32 = 0;
  for c in string.chars(){
    let ascii = c as i32;
    hash = ((hash + ascii) * 17) % 256;
  }
  return hash;
}

fn insert_to_map(hash_map: &amp;mut Vec&lt;LinkedList&lt;(String, i32)&gt;&gt;, lens: i32, key: &amp;str){
  let hash = ascii_hash(key) as usize;
  for element in &amp;mut hash_map[hash]{
    if element.0 == key{
      element.1 = lens;
      return;
    }
  }
  hash_map[hash].push_back((key.to_string(), lens));
}

fn remove_from_map(hash_map: &amp;mut Vec&lt;LinkedList&lt;(String, i32)&gt;&gt;, key: &amp;str){
  let hash = ascii_hash(key) as usize;
  let mut j: usize = 0;
  for element in &amp;mut hash_map[hash]{
    if element.0 == key{
      let mut last = hash_map[hash].split_off(j);
      last.pop_front();
      hash_map[hash].append(&amp;mut last);
      return;
    }
    j += 1;
  }
}

fn init_hash_map(size: i32) -&gt; Vec&lt;LinkedList&lt;(String, i32)&gt;&gt;{
  let mut hash_map: Vec&lt;LinkedList&lt;(String, i32)&gt;&gt; = vec!();
  for _ in 0..size{
    hash_map.push(LinkedList::new());
  }
  return hash_map;
}


fn part1() {
  let strings = read_file("INPUT");
  let mut total = 0;
  for string in strings{
    total += ascii_hash(&amp;string);
  }
  println!("Part 1: {}", total);
}

fn part2() {
  let mut hash_map = init_hash_map(256);
  let strings = read_file("INPUT");
  let mut total = 0;
  for string in strings{
    if string.chars().nth(string.len() - 1) == Some('-'){
      let key = &amp;string[0..string.len() - 1];
      remove_from_map(&amp;mut hash_map, key);
    }
    else if string.chars().nth(string.len() - 2) == Some('='){
      let lens = string.chars().nth(string.len() - 1).unwrap() as i32 - '0' as i32;
      let key = &amp;string[0..string.len() - 2];
      insert_to_map(&amp;mut hash_map, lens, key);
    }
  }
  for i in 0..hash_map.len(){
    let mut j = 0;
    for element in &amp;hash_map[i]{
      total += (i + 1) * (j + 1) * (element.1 as usize);
      j += 1;
    }
  }
  println!("Part 2: {}", total);
}

fn main() {
  println!("Year 2023 day 15 - Lens Library");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-16"><a class="header" href="#advent-of-code---year-2023-day-16">Advent of code - Year 2023 Day 16</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/16">day 16</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-17"><a class="header" href="#info-17">Info</a></h3>
<h4 id="part-1-17"><a class="header" href="#part-1-17">Part 1</a></h4>
<p>We simply recursively simulate beam step-by-step. We use hashmap to memorize already visited places in grid with the same directions.</p>
<h4 id="part-2-17"><a class="header" href="#part-2-17">Part 2</a></h4>
<p>We reuse the codebase and run he simulation from every possible place and find the maximum.</p>
<h2 id="mainrs-17"><a class="header" href="#mainrs-17">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::collections::HashMap;

type Grid&lt;T&gt; = Vec&lt;Vec&lt;T&gt;&gt;;

/** Read the input file and return the matrix and empty visited map. */
fn read_file(filepath: &amp;str) -&gt; (Grid&lt;char&gt;, Grid&lt;bool&gt;){
  let contents = fs::read_to_string(filepath);
  let mut matrix: Grid&lt;char&gt; = vec![];
  let mut visited: Grid&lt;bool&gt; = vec![];
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  for line in lines{
    let mut matrix_line: Vec&lt;char&gt; = vec!();
    let mut visited_line: Vec&lt;bool&gt; = vec!();
    for c in line.chars(){
      matrix_line.push(c);
      visited_line.push(false);
    }
    matrix.push(matrix_line);
    visited.push(visited_line);
  }
  return (matrix, visited);
}

/** Get the key to the hash function. */
fn get_key(position: (usize, usize), movement: (i32, i32)) -&gt; String{
  let mut key = String::from("");
  key += &amp;position.0.to_string();
  key.push(':');
  key += &amp;position.1.to_string();
  key.push('|');
  key += &amp;movement.0.to_string();
  key.push(':');
  key += &amp;movement.1.to_string();
  return key;
}

/** Move one tile in a matrix. Also check and if it was used do not go there again. */
fn step(matrix: &amp;Vec&lt;Vec&lt;char&gt;&gt;, visited: &amp;mut Vec&lt;Vec&lt;bool&gt;&gt;, position: (usize, usize), movement: (i32, i32), history: &amp;mut HashMap&lt;String, bool&gt;){
  if position.0 &gt;= matrix.len() || position.1 &gt;= matrix[position.0].len(){
    return;
  }
  let key = get_key(position, movement);
  if history.contains_key(&amp;key){
    return;
  }
  history.insert(key, true);
  visited[position.0][position.1] = true;
  match matrix[position.0][position.1]{
    '/' =&gt; {
      let new_movement = (-movement.1, -movement.0);
      let new_position = ((position.0 as i32 + new_movement.0) as usize, (position.1 as i32 + new_movement.1) as usize);
      step(matrix, visited, new_position, new_movement, history);
      },
    '\\' =&gt; {
      let new_movement = (movement.1, movement.0);
      let new_position = ((position.0 as i32 + new_movement.0) as usize, (position.1 as i32 + new_movement.1) as usize);
      step(matrix, visited, new_position, new_movement, history);
      },
    '|' =&gt; {
      if movement.0 == -1 || movement.0 == 1{
          let new_position = ((position.0 as i32 + movement.0) as usize, (position.1 as i32 + movement.1) as usize);
          step(matrix, visited, new_position, movement, history);
        }
        else{
          let mut new_position = ((position.0 as i32 + 1) as usize, position.1);
          step(matrix, visited, new_position, (1, 0), history);
          new_position = ((position.0 as i32 - 1) as usize, position.1);
          step(matrix, visited, new_position, (-1, 0), history);
        }
      },
    '-' =&gt; {
        if movement.1 == -1 || movement.1 == 1{
          let new_position = ((position.0 as i32 + movement.0) as usize, (position.1 as i32 + movement.1) as usize);
          step(matrix, visited, new_position, movement, history);
        }
        else{
          let mut new_position = (position.0, (position.1 as i32 + 1) as usize);
          step(matrix, visited, new_position, (0, 1), history);
          new_position = (position.0, (position.1 as i32 - 1) as usize);
          step(matrix, visited, new_position, (0, -1), history);
        }
      },
    '.' =&gt; {
      let new_position = ((position.0 as i32 + movement.0) as usize, (position.1 as i32 + movement.1) as usize);
      step(matrix, visited, new_position, movement, history);
      },
    _ =&gt; {},
  }
}

/** Count the visited places. */
fn count_visited(visited: &amp;Vec&lt;Vec&lt;bool&gt;&gt;) -&gt; i64{
  let mut total: i64 = 0;
  for line in visited{
    for c in line{
      if *c{
        total += 1;
      }
    }
  }
  return total;
}

/** Try one possibility. */
fn try_one(matrix: &amp; Vec&lt;Vec&lt;char&gt;&gt;, visited: &amp;Vec&lt;Vec&lt;bool&gt;&gt;, position: (usize, usize), movement: (i32, i32)) -&gt; i64{
  let mut v = visited.clone();
  let mut h: HashMap&lt;String, bool&gt; = HashMap::new();
  step(&amp;matrix, &amp;mut v, position, movement, &amp;mut h);
  return count_visited(&amp;v);
}

/** Move in the matrix. */
fn part1() {
  let (matrix, mut visited) = read_file("INPUT");
  let mut history: HashMap&lt;String, bool&gt; = HashMap::new();
  step(&amp;matrix, &amp;mut visited, (0,0), (0,1), &amp;mut history);
  println!("Part 1: {}", count_visited(&amp;visited));
}

/** Try all posibilitie. */
fn part2() {
  let (matrix, visited) = read_file("INPUT");
  let mut max: i64 = 0;
  for i in 1..matrix.len() - 1{
    let c = try_one(&amp;matrix, &amp;visited, (i,0), (0,1));
    if c &gt; max{ max = c; }
    let c = try_one(&amp;matrix, &amp;visited, (matrix.len() - 1 - i,0), (0,-1));
    if c &gt; max{ max = c; }
  }
  for i in 1..matrix[0].len() - 1{
    let c = try_one(&amp;matrix, &amp;visited, (0,i), (1,0));
    if c &gt; max{ max = c; }
    let c = try_one(&amp;matrix, &amp;visited, (0,matrix.len() - 1 - i), (-1,0));
    if c &gt; max{ max = c; }
  }
  let c = try_one(&amp;matrix, &amp;visited, (0,0), (1,0));
  if c &gt; max{ max = c; }
  let c = try_one(&amp;matrix, &amp;visited, (0,0), (0,1));
  if c &gt; max{ max = c; }
  let c = try_one(&amp;matrix, &amp;visited, (matrix.len(),matrix[0].len()), (-1,0));
  if c &gt; max{ max = c; }
  let c = try_one(&amp;matrix, &amp;visited, (matrix.len(),matrix[0].len()), (0,-1));
  if c &gt; max{ max = c; }
  println!("Part 2: {}", max);
}

fn main() {
  println!("Year 2023 day 16 - The Floor Will Be Lava");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-17"><a class="header" href="#advent-of-code---year-2023-day-17">Advent of code - Year 2023 Day 17</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/17">day 17</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-18"><a class="header" href="#info-18">Info</a></h3>
<h4 id="part-1-18"><a class="header" href="#part-1-18">Part 1</a></h4>
<p>We record every single step by its position, direction, all other possibilities. Then we use heap for the shortest paths and hashmap to record alreeady visited nodes.</p>
<h4 id="part-2-18"><a class="header" href="#part-2-18">Part 2</a></h4>
<p>We also introduce a minimal number of nodes in one direction, then we rewrite the code so it can work for both parts.</p>
<h2 id="mainrs-18"><a class="header" href="#mainrs-18">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::cmp::Reverse;
use std::collections::{BinaryHeap, HashMap};

type Grid&lt;T&gt; = Vec&lt;Vec&lt;T&gt;&gt;;
type Position = (usize, usize);

fn read_file(filepath: &amp;str) -&gt; Grid&lt;usize&gt;{
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  let mut grid: Grid&lt;usize&gt; = vec![];
  for line in lines{
    let mut grid_line: Vec&lt;usize&gt; = vec!();
    for c in line.chars(){
      grid_line.push(c.to_digit(10).unwrap() as usize);
    }
    if grid_line.len() &gt; 0{
      grid.push(grid_line);
    }
  }
  return grid;
}

#[derive(Clone, Copy, Eq, Hash, PartialEq, Ord, PartialOrd)]
enum Direction{
  Up,
  Down,
  Right,
  Left,
}

#[derive(Clone, Copy, Eq, Hash, PartialEq, Ord, PartialOrd)]
struct State {
  position: Position,
  remaining_up: usize,
  remaining_right: usize,
  remaining_down: usize,
  remaining_left: usize,
  direction: Direction,
  moves_in_current_direction: usize,
}

fn get_neighbouring_states(state: State, map: &amp;Grid&lt;usize&gt;, min: usize, max: usize) -&gt; Vec&lt;State&gt; {
  let mut neighbours: Vec&lt;State&gt; = vec!();

  if state.moves_in_current_direction &lt; min {
  match state.direction {
      Direction::Up =&gt; {
        if state.position.0 &gt;= 1 {
          neighbours.push(State {
              position: (state.position.0 - 1, state.position.1),
              remaining_up: state.remaining_up - 1,
              remaining_right: max,
              remaining_down: max,
              remaining_left: max,
              direction: Direction::Up,
              moves_in_current_direction: state.moves_in_current_direction + 1,
          });
        }
        return neighbours;
        }
      Direction::Right =&gt; {
        if state.position.1 &lt; map[0].len() - 1 {
          neighbours.push(State {
              position: (state.position.0, state.position.1 + 1),
              remaining_up: max,
              remaining_right: state.remaining_right - 1,
              remaining_down: max,
              remaining_left: max,
              direction: Direction::Right,
              moves_in_current_direction: state.moves_in_current_direction + 1,
          });
        }
        return neighbours;
      }
      Direction::Down =&gt; {
        if state.position.0 &lt; map.len() - 1 {
          neighbours.push(State {
              position: (state.position.0 + 1, state.position.1),
              remaining_up: max,
              remaining_right: max,
              remaining_down: state.remaining_down - 1,
              remaining_left: max,
              direction: Direction::Down,
              moves_in_current_direction: state.moves_in_current_direction + 1,
          });
        }
        return neighbours;
      }
      Direction::Left =&gt; {
        if state.position.1 &gt;= 1 {
          neighbours.push(State {
              position: (state.position.0, state.position.1 - 1),
              remaining_up: max,
              remaining_right: max,
              remaining_down: max,
              remaining_left: state.remaining_left - 1,
              direction: Direction::Left,
              moves_in_current_direction: state.moves_in_current_direction + 1,
          });
        }
        return neighbours;
      }
    }
  }

  if state.remaining_up &gt;= 1 &amp;&amp; state.position.0 &gt;= 1 &amp;&amp; state.direction != Direction::Down {
    neighbours.push(State {
        position: (state.position.0 - 1, state.position.1),
        remaining_up: state.remaining_up - 1,
        remaining_right: max,
        remaining_down: max,
        remaining_left: max,
        direction: Direction::Up,
        moves_in_current_direction: if state.direction == Direction::Up {
           state.moves_in_current_direction + 1
        } else {
           1
        },
    });
  }

  if state.remaining_right &gt;= 1
  &amp;&amp; state.position.1 &lt; map[0].len() - 1
  &amp;&amp; state.direction != Direction::Left {
    neighbours.push(State {
      position: (state.position.0, state.position.1 + 1),
      remaining_up: max,
      remaining_right: state.remaining_right - 1,
      remaining_down: max,
      remaining_left: max,
      direction: Direction::Right,
      moves_in_current_direction: if state.direction == Direction::Right {
         state.moves_in_current_direction + 1
      } else { 1 }, });
  }

  if state.remaining_down &gt;= 1
  &amp;&amp; state.position.0 &lt; map.len() - 1
  &amp;&amp; state.direction != Direction::Up {
    neighbours.push(State {
      position: (state.position.0 + 1, state.position.1),
      remaining_up: max,
      remaining_right: max,
      remaining_down: state.remaining_down - 1,
      remaining_left: max,
      direction: Direction::Down,
      moves_in_current_direction: if state.direction == Direction::Down {
         state.moves_in_current_direction + 1
      } else { 1 }, });
  }

  if state.remaining_left &gt;= 1 &amp;&amp; state.position.1 &gt;= 1 &amp;&amp; state.direction != Direction::Right {
    neighbours.push(State {
      position: (state.position.0, state.position.1 - 1),
      remaining_up: max,
      remaining_right: max,
      remaining_down: max,
      remaining_left: state.remaining_left - 1,
      direction: Direction::Left,
      moves_in_current_direction: if state.direction == Direction::Left {
         state.moves_in_current_direction + 1
      } else { 1 }, });
  }

  neighbours
}

fn get_cost(map: &amp;Grid&lt;usize&gt;, source: Position, destination: Position, min: usize, max: usize) -&gt; usize {
  let mut costs: HashMap&lt;State, usize&gt; = HashMap::new();
  let mut heap: BinaryHeap&lt;Reverse&lt;(usize, State)&gt;&gt; = BinaryHeap::new();

  let start_state_right = State {
    position: source,
    remaining_up: max,
    remaining_right: max,
    remaining_down: max,
    remaining_left: max,
    direction: Direction::Right,
    moves_in_current_direction: 0,
  };
  let start_state_down = State {
    position: source,
    remaining_up: max,
    remaining_right: max,
    remaining_down: max,
    remaining_left: max,
    direction: Direction::Down,
    moves_in_current_direction: 0,
  };

  costs.insert(start_state_right, 0);
  costs.insert(start_state_down, 0);
  heap.push(Reverse((0, start_state_right)));
  heap.push(Reverse((0, start_state_down)));

  while let Some(Reverse((curr_cost, curr_state))) = heap.pop() {
    if curr_state.position == destination &amp;&amp; curr_state.moves_in_current_direction &gt;= min {
      return curr_cost;
    }

    if curr_cost &gt; *costs.get(&amp;curr_state).unwrap_or(&amp;usize::MAX) {
      continue;
    }

    let neighbours = get_neighbouring_states(curr_state, map, min, max);

    for neighbour in neighbours {
      let next_pos = neighbour.position;
      let next_cost = curr_cost + map[next_pos.0][next_pos.1];
      if next_cost &lt; *costs.get(&amp;neighbour).unwrap_or(&amp;usize::MAX) {
        heap.push(Reverse((next_cost, neighbour)));
        costs.insert(neighbour, next_cost);
      }
    }
  }
  usize::MAX
}

fn part1() {
  let grid = read_file("INPUT");
  println!("Part 1: {}", get_cost(&amp;grid, (0,0), (grid.len() - 1, grid.len() - 1), 0, 3));
}

fn part2() {
  let grid = read_file("INPUT");
  println!("Part 2: {}", get_cost(&amp;grid, (0,0), (grid.len() - 1, grid.len() - 1), 4, 10));
}

fn main() {
  println!("Year 2023 day 17 - Clumsy Crucible");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-18"><a class="header" href="#advent-of-code---year-2023-day-18">Advent of code - Year 2023 Day 18</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/18">day 18</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-19"><a class="header" href="#info-19">Info</a></h3>
<h4 id="part-1-19"><a class="header" href="#part-1-19">Part 1</a></h4>
<p>We can simply calculate the whole grid. Then create the outline and after that recursively fill in the polygon from a starting node. This solution is actually in here anymore.</p>
<h4 id="part-2-19"><a class="header" href="#part-2-19">Part 2</a></h4>
<p>Again we use <a href="https://en.wikipedia.org/wiki/Pick%27s_theorem">Pick's Theorem</a>. And <a href="https://docs.rs/geo/latest/geo/">geo</a> library to create a polygon from the instruction set and compute the area using the library. Then we procede with the use of the theoem.</p>
<h2 id="mainrs-19"><a class="header" href="#mainrs-19">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use geo::{Coord, Polygon, Area, coord, LineString};

type Point&lt;T&gt; = (T,T);
type Instruction = (char, i32);

fn read_file(filepath: &amp;str) -&gt; (Vec&lt;Instruction&gt;, Vec&lt;String&gt;) {
  let mut instructions: Vec&lt;Instruction&gt; = vec!();
  let mut strings: Vec&lt;String&gt; = vec!();
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  for line in lines {
    if line != "" {
      let mut parts = line.split(' ');
      let instruction = (parts.next().unwrap().chars().nth(0).unwrap(),
                 parts.next().unwrap().parse::&lt;i32&gt;().unwrap());
      instructions.push(instruction);
      strings.push(parts.next().unwrap().to_string());
    }
  }
  return (instructions, strings);
}

fn step(instruction: &amp;Instruction, point: &amp;Point&lt;i32&gt;) -&gt; Point&lt;i32&gt; {
  match instruction.0 {
    '0' | 'R' =&gt; (point.0, point.1 + instruction.1),
    '1' | 'D' =&gt; (point.0 + instruction.1, point.1),
    '2' |'L' =&gt; (point.0, point.1 - instruction.1),
    '3' | 'U' =&gt; (point.0 - instruction.1, point.1),
    _   =&gt; (point.0, point.1),
  }
}

fn calculate_area(points: &amp;Vec&lt;Point&lt;i32&gt;&gt;) -&gt; f64 {
  let mut coordinates: Vec&lt;Coord&gt; = vec!();
  for point in points {
    coordinates.push(coord! {x: point.0 as f64, y: point.1 as f64 });
  }
  let line_string = LineString::new(coordinates);
  let polygon = Polygon::new(line_string, Vec::new());
  polygon.unsigned_area()
}

fn compute_from_instructions(instructions: &amp;Vec&lt;Instruction&gt;) -&gt; i64 {
  let mut points: Vec&lt;Point&lt;i32&gt;&gt; = vec!();
  let mut point: Point&lt;i32&gt; = (0,0);
  let mut b: i64 = 0;
  for instruction in instructions {
    points.push(point);
    point = step(instruction, &amp;mut point);
    b += instruction.1 as i64;
  }
  let area = calculate_area(&amp;points) as i64;
  2 + b + (area - b/2 - 1)
}

fn parse_string(string: &amp;str) -&gt; Instruction {
  let len: usize = string.len() - 2;
  let hex_string = &amp;string[2 .. len];
  let num = i32::from_str_radix(&amp;hex_string, 16).unwrap();
  (string.chars().nth(len).unwrap(), num)
}

fn part1() {
  let (instructions, _) = read_file("INPUT");
  println!("Part 1: {}", compute_from_instructions(&amp;instructions));
}

fn part2() {
  let (_, strings) = read_file("INPUT");
  let instructions: Vec&lt;Instruction&gt; = strings.into_iter()
                                              .map(|string| { parse_string(&amp;string) })
                                              .collect();
  println!("Part 2: {}", compute_from_instructions(&amp;instructions));
}

fn main() {
  println!("Year 2023 day 18 - Lavaduct Lagoon");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-19"><a class="header" href="#advent-of-code---year-2023-day-19">Advent of code - Year 2023 Day 19</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/19">day 19</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-20"><a class="header" href="#info-20">Info</a></h3>
<p>The main key was to parse properly the given input. That is why the code today is pretty long.</p>
<h4 id="part-1-20"><a class="header" href="#part-1-20">Part 1</a></h4>
<p>After that we just use hash table to memorize given states. Than we process each request from left to right until it is satisfied.</p>
<h4 id="part-2-20"><a class="header" href="#part-2-20">Part 2</a></h4>
<p>In the second part we had to use the same aproach only to compute the intervals not just single numbers. But it is very similiar, since we just split parts on each comparison and recursively called to the next step.</p>
<h2 id="mainrs-20"><a class="header" href="#mainrs-20">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::collections::HashMap;
use std::cmp::{min, max};

const X: usize = 0;
const M: usize = 1;
const A: usize = 2;
const S: usize = 3;
const INV: usize = 5;

type Part = [i64; 4];

type BoundPart = [(i64,i64); 4];

enum Compare {
  LessThan,
  MoreThan,
  True,
}

struct Rule {
  considering: usize,
  compare: Compare,
  number: i64,
  next_state: String,
  accepting: bool,
  rejecting: bool,
}

type State = Vec&lt;Rule&gt;;

fn get_considering(c: char) -&gt; usize {
  match c {
    'x' =&gt; return X,
    'm' =&gt; return M,
    'a' =&gt; return A,
    's' =&gt; return S,
     _  =&gt; return INV,
   }
 }

fn parse_rule(line: &amp;str) -&gt; Rule {
  let splitted = line.split(':');
  let parts: Vec&lt;&amp;str&gt; = splitted.collect();
  if parts.len() == 1 as usize {
    let new_state = parts[0];
    if new_state == "A" {
      return Rule {considering: INV,
        compare: Compare::True,
        number: 0,
        next_state: "".to_string(),
        accepting: true,
        rejecting: false};
    }
    else if new_state == "R" {
      return Rule {considering: INV,
        compare: Compare::True,
        number: 0,
        next_state: "".to_string(),
        accepting: false,
        rejecting: true};
    }
    else {
      return Rule {considering: INV,
        compare: Compare::True,
        number: 0,
        next_state: new_state.to_string(),
        accepting: false,
        rejecting: false};
    }
  }
  let binding = parts[0].to_string();
  let considering = get_considering(binding.chars().nth(0).unwrap());
  let compare: Compare;
  match binding.chars().nth(1).unwrap() {
    '&lt;' =&gt; compare = Compare::LessThan,
    '&gt;' =&gt; compare = Compare::MoreThan,
    _   =&gt; compare = Compare::True,
  }
  let number = i64::from_str_radix(&amp;binding[2 ..], 10).unwrap();
  let new_state = parts[1].to_string();
  if new_state == "A" {
    return Rule {considering: considering,
      compare: compare,
      number: number,
      next_state: "".to_string(),
      accepting: true,
      rejecting: false};
  }
  else if new_state == "R" {
    return Rule {considering: considering,
      compare: compare,
      number: number,
      next_state: "".to_string(),
      accepting: false,
      rejecting: true};
  }
  else {
    return Rule {considering: considering,
      compare: compare,
      number: number,
      next_state: new_state,
      accepting: false,
      rejecting: false};
  }
}

fn parse_state(line: &amp;str) -&gt; (String, State) {
  let mut parts = line.split('{');
  let string = parts.next().unwrap().to_string();
  let mut rules: Vec&lt;Rule&gt; = vec!();
  let binding = parts.next().unwrap().to_string();
  let rule = &amp;binding[0 .. binding.len() - 1];
  for r in rule.split(',') {
    rules.push(parse_rule(r));
  }
  (string, rules)
}

fn parse_part(line: &amp;str) -&gt; Part {
  let interior = &amp;line[1 .. line.len() - 1];
  let values: Vec&lt;&amp;str&gt; = interior.split(',').collect();
  let mut part: Part = [0; 4];
  for val in values {
    match val.chars().nth(0).unwrap() {
      'x' =&gt; part[X] = i64::from_str_radix(&amp;val[2 ..], 10).unwrap(),
      'm' =&gt; part[M] = i64::from_str_radix(&amp;val[2 ..], 10).unwrap(),
      'a' =&gt; part[A] = i64::from_str_radix(&amp;val[2 ..], 10).unwrap(),
      's' =&gt; part[S] = i64::from_str_radix(&amp;val[2 ..], 10).unwrap(),
       _  =&gt; todo!(),
    }
  }
  part
}

fn read_file(filepath: &amp;str) -&gt; (HashMap&lt;String, State&gt;, Vec&lt;Part&gt;) {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  let mut parts: Vec&lt;Part&gt; = vec!();
  let mut hash_map: HashMap&lt;String, State&gt; = HashMap::new();
  let mut first_part: bool = true;
  for line in lines{
    if line == "" {
      first_part = false;
    }
    else if first_part {
      let (string, state) = parse_state(&amp;line);
      hash_map.insert(string, state);
    }
    else {
      parts.push(parse_part(line));
    }
  }
  (hash_map, parts)
}

fn process_part(hash_map: &amp;HashMap&lt;String, State&gt;, part: Part) -&gt; i64 {
  let mut string = "in";
  let ret: i64 = part[X] + part[M] + part[A] + part[S];
  loop {
    let state = &amp;hash_map[string];
    for rule in state {
      match rule.compare {
        Compare::LessThan =&gt; {
          if part[rule.considering] &lt; rule.number {
            if rule.accepting {
              return ret;
            }
            else if rule.rejecting {
              return 0;
            }
            string = &amp;rule.next_state;
            break;
          }
        }
        Compare::MoreThan =&gt; {
          if part[rule.considering] &gt; rule.number {
            if rule.accepting {
              return ret;
            }
            else if rule.rejecting {
              return 0;
            }
            string = &amp;rule.next_state;
            break;
          }
        }
        Compare::True =&gt; {
          if rule.accepting {
            return ret;
          }
          else if rule.rejecting {
            return 0;
          }
          string = &amp;rule.next_state;
          break;
        }
      }
    }
  }
}

fn check_bound(bound: (i64, i64)) -&gt; bool {
  bound.1 &gt; bound.0
}

fn count_possibilites(bounds: &amp;BoundPart) -&gt; i64 {
  let res = (bounds[X].1 - bounds[X].0) * (bounds[M].1 - bounds[M].0) * (bounds[A].1 - bounds[A].0) * (bounds[S].1 - bounds[S].0);
  res
}

fn process_bounds(hash_map: &amp;HashMap&lt;String, State&gt;, bounds: &amp;mut BoundPart, string: &amp;str) -&gt; i64 {
  let mut total: i64 = 0;
  let state = &amp;hash_map[string];
  for rule in state {
    match rule.compare {
      Compare::LessThan =&gt; {
        let part1 = (bounds[rule.considering].0, rule.number);
        let mut new_bounds = [bounds[X], bounds[M], bounds[A], bounds[S]];
        bounds[rule.considering] = (max(rule.number, bounds[rule.considering].0), bounds[rule.considering].1);
        new_bounds[rule.considering] = part1;
        if check_bound(part1){
          if rule.accepting {
            total += count_possibilites(&amp;new_bounds);
          }
          else if rule.rejecting {
            total += 0;
          }
          else {
            total += process_bounds(hash_map, &amp;mut new_bounds, &amp;rule.next_state);
          }
        }
      }
      Compare::MoreThan =&gt; {
        let part1 = (rule.number + 1, bounds[rule.considering].1);
        let mut new_bounds = [bounds[X], bounds[M], bounds[A], bounds[S]];
        bounds[rule.considering] = (bounds[rule.considering].0, min(rule.number + 1, bounds[rule.considering].1));
        new_bounds[rule.considering] = part1;
        if check_bound(part1){
          if rule.accepting {
            total += count_possibilites(&amp;new_bounds);
          }
          else if rule.rejecting {
            total += 0;
          }
          else {
            total += process_bounds(hash_map, &amp;mut new_bounds, &amp;rule.next_state);
          }
        }
      }
      Compare::True =&gt; {
        let mut new_bounds = [bounds[X], bounds[M], bounds[A], bounds[S]];
        if rule.accepting {
          total += count_possibilites(&amp;bounds);
        }
        else if rule.rejecting {
          total += 0;
        }
        else {
          total += process_bounds(hash_map, &amp;mut new_bounds, &amp;rule.next_state);
        }
      }
    }
  }
  total
}

fn part1() {
  let (hash_map, parts) = read_file("INPUT");
  let results: Vec&lt;i64&gt; = parts.into_iter().map(|p| process_part(&amp;hash_map, p)).collect();
  println!("Part 1: {}", results.iter().sum::&lt;i64&gt;());
}

fn part2() {
  let (hash_map, _) = read_file("INPUT");
  let mut part: BoundPart = [(1, 4001); 4];
  println!("Part 2: {}", process_bounds(&amp;hash_map, &amp;mut part, "in"));
}

fn main() {
  println!("Year 2023 day 19 - Aplenty");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-21"><a class="header" href="#advent-of-code---year-2023-day-21">Advent of code - Year 2023 Day 21</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/21">day 21</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-21"><a class="header" href="#info-21">Info</a></h3>
<h4 id="part-1-21"><a class="header" href="#part-1-21">Part 1</a></h4>
<p>For the first part we have more options.</p>
<ol>
<li>Completely brute force it. It is just <code>64</code> steps. <strong>:D</strong></li>
<li>Remember two sets: Odd visited and even visited. Then see the number of even visited with the limit <code>64</code>.</li>
<li>Use <code>bfs</code> algorithm to compute distances to every place. Then just filter out these that were visited in an even steep and is under the limit of <code>64</code>.</li>
</ol>
<h4 id="part-2-21"><a class="header" href="#part-2-21">Part 2</a></h4>
<p>The second part uses the implemented <code>bfs</code>. We are not able to compute it for all <code>26501365</code> steps. But there is some quite nice math behind the input. Firstly it is a square and there is a straight line from the middle to each side. Every neighbouring blocks switch <strong>even</strong>/<strong>odd</strong> parity. And lastly we campute the corners.</p>
<p>This is just simplified steps of the computation. I actually didn't come up with that on my own, but one can see it make sense due to the nice input. By which we can have some assumptions.</p>
<h2 id="mainrs-21"><a class="header" href="#mainrs-21">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::collections::{HashSet, VecDeque};

type Grid&lt;T&gt; = Vec&lt;Vec&lt;T&gt;&gt;;
type Position = (usize, usize);

const ROCK: i64 = -3;
const EMPTY: i64 = -1;

fn read_file(filepath: &amp;str) -&gt; (Grid&lt;bool&gt;, Position) {
  let contents = fs::read_to_string(filepath);
  let mut garden: Grid&lt;bool&gt; = vec![];
  let mut start: Position = (0,0);
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  let mut i: usize = 0;
  for line in lines{
    let mut garden_line: Vec&lt;bool&gt; = vec!();
    let mut j: usize = 0;
    for c in line.chars(){
      garden_line.push(c != '#');
      if c == 'S' {
        start = (i,j);
      }
      j += 1;
    }
    if garden_line.len() &gt; 0 {
      garden.push(garden_line);
    }
    i += 1;
  }
  (garden, start)
}

fn add(a: usize, b: i8) -&gt; usize {
  (a as i64 + b as i64) as usize
}

fn bfs(garden: &amp;Grid&lt;bool&gt;, position: Position) -&gt; Grid&lt;i64&gt; {
  let mut distances: Grid&lt;i64&gt; = vec![];
  for g in garden {
    distances.push(vec![EMPTY; g.len()])
  }

  let mut visited: HashSet&lt;Position&gt; = HashSet::new();
  visited.insert(position);
  let neighbors: [(i8, i8); 4] = [(1, 0), (-1,0), (0,1), (0,-1)];
  let mut queue: VecDeque&lt;(Position, i64)&gt; = VecDeque::new();
  queue.push_back((position, 0));

  while !queue.is_empty() {
    let (pos, counter) = queue.pop_front().unwrap();
    if !garden[pos.0][pos.1] {
      distances[pos.0][pos.1] = ROCK;
      continue;
    }
    else {
      distances[pos.0][pos.1] = counter;
    }
    for n in neighbors {
      let new_pos = (add(pos.0,n.0), add(pos.1,n.1));
      if new_pos.0 &gt;= garden.len() || new_pos.1 &gt;= garden[new_pos.0].len() {
        continue;
      }
      if !visited.contains(&amp;new_pos) {
        queue.push_back((new_pos, counter + 1));
        visited.insert(new_pos);
      }
    }
  }
  distances
}

fn part1() {
  let (garden, start) = read_file("INPUT");
  let dist = bfs(&amp;garden, start);
  let limit: i64 = 64;
  let total = dist.into_iter()
        .map(|vec| vec.into_iter()
          .filter(|x| x % 2 == 0 &amp;&amp; x != &amp;ROCK &amp;&amp; x &lt;= &amp;limit)
          .count())
        .fold(0, |acc, sum| acc + sum);
  println!("Part 1: {}", total);
}

fn part2() {
  let (garden, start) = read_file("INPUT");
  let dist = bfs(&amp;garden, start);
  let magical_const: usize = 26501365;
  let n: usize = magical_const / garden.len();
  let limit: i64 = magical_const as i64 % garden.len() as i64;
  let full_even = dist.clone().into_iter()
        .map(|vec| vec.into_iter()
          .filter(|x| x % 2 == 0 &amp;&amp; x != &amp;ROCK)
          .count())
        .fold(0, |acc, sum| acc + sum);
  let full_odd = dist.clone().into_iter()
        .map(|vec| vec.into_iter()
          .filter(|x| x % 2 == 1 &amp;&amp; x != &amp;ROCK)
          .count())
        .fold(0, |acc, sum| acc + sum);
  let corner_odd = dist.clone().into_iter()
        .map(|vec| vec.into_iter()
          .filter(|x| x % 2 == 1 &amp;&amp; x != &amp;ROCK &amp;&amp; x &gt; &amp;limit)
          .count())
        .fold(0, |acc, sum| acc + sum);
  let corner_even = dist.clone().into_iter()
        .map(|vec| vec.into_iter()
          .filter(|x| x % 2 == 0 &amp;&amp; x != &amp;ROCK &amp;&amp; x &gt; &amp;limit)
          .count())
        .fold(0, |acc, sum| acc + sum);
  
  let total = (n+1)*(n+1) * full_odd
      + n*n * full_even
      - (n+1) * corner_odd
      + n * corner_even;
  println!("Part 2: {}", total);
}

fn main() {
  println!("Year 2023 day 21 - Step Counter");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-22"><a class="header" href="#advent-of-code---year-2023-day-22">Advent of code - Year 2023 Day 22</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/22">day 22</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-22"><a class="header" href="#info-22">Info</a></h3>
<h4 id="part-1-22"><a class="header" href="#part-1-22">Part 1</a></h4>
<p>In the first part we parse the input than sort the bricks by their <code>z</code> value. After that we simply squish the bricks together (or <code>compress</code> them) so they won't  levitate anymore. After that we compute how they are dependent on each other, or in other words how they <strong>support</strong> each other. Lastly we compute these that follows the rules and left out the others.</p>
<h4 id="part-2-22"><a class="header" href="#part-2-22">Part 2</a></h4>
<p>We use the already written code to construct such bricks. After that we look on every brick and remove it. Then see if any bricks that were supported by this will fall (so the <strong>interection</strong> with the <code>supported_by</code> contains all of them. Then we follow on these bricks until they stay in place.</p>
<h2 id="mainrs-22"><a class="header" href="#mainrs-22">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::collections::{HashSet, HashMap, VecDeque};

struct Brick {
  x: (i64, i64),
  y: (i64, i64),
  z: (i64, i64),
  supports: HashSet&lt;usize&gt;,
  supported_by: HashSet&lt;usize&gt;,
}

fn parse_numbers(line: &amp;str) -&gt; (i64, i64, i64) {
  let parts: Vec&lt;&amp;str&gt; = line.split(',').into_iter().collect();
  (i64::from_str_radix(&amp;parts[0], 10).unwrap(),
   i64::from_str_radix(&amp;parts[1], 10).unwrap(),
   i64::from_str_radix(&amp;parts[2], 10).unwrap())
}

fn parse_brick(line: &amp;str) -&gt; Brick {
  let parts: Vec&lt;&amp;str&gt; = line.split('~').into_iter().collect();
  let (x1, y1, z1) = parse_numbers(parts[0]);
  let (x2, y2, z2) = parse_numbers(parts[1]);
  Brick { x: (x1, x2),
        y: (y1, y2),
        z: (z1, z2),
        supported_by: HashSet::new(),
        supports: HashSet::new()}
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Brick&gt; {
  let contents = fs::read_to_string(filepath);
  let mut bricks: Vec&lt;Brick&gt; = vec!();
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  for line in lines{
    if line != "" {
      bricks.push(parse_brick(line));
    }
  }
  bricks
}

fn overlap(b1: &amp;Brick, b2: &amp;Brick) -&gt; bool {
  b1.x.0 &lt;= b2.x.1 &amp;&amp; b1.x.1 &gt;= b2.x.0 &amp;&amp; b1.y.0 &lt;= b2.y.1 &amp;&amp; b1.y.1 &gt;= b2.y.0
}

fn compress_bricks(bricks: &amp;mut Vec&lt;Brick&gt;) {
  for i in 0 .. bricks.len() {
    let mut max: i64 = 0;
    for j in 0 .. i {
      if bricks[j].z.1 &gt; max &amp;&amp; overlap(&amp;bricks[i], &amp;bricks[j]) {
        max = bricks[j].z.1;
      }
    }
    max += 1;
    bricks[i].z.1 = bricks[i].z.1 - bricks[i].z.0 + max;
    bricks[i].z.0 = max;
  }
}

fn create_supports(bricks: &amp;mut Vec&lt;Brick&gt;) {
  for i in 0 .. bricks.len() {
    for j in 0 .. bricks.len() {
      if bricks[j].z.1 == bricks[i].z.0 - 1 &amp;&amp; overlap(&amp;bricks[i], &amp;bricks[j]) {
        bricks[i].supported_by.insert(j);
      }
      if bricks[i].z.1 + 1 == bricks[j].z.0 &amp;&amp; overlap(&amp;bricks[i], &amp;bricks[j]) {
        bricks[i].supports.insert(j);
      }
    }
  }
}

fn count_overlaps(bricks: &amp;mut Vec&lt;Brick&gt;) -&gt; usize {
  let mut hash_map: HashMap&lt;usize, bool&gt; = HashMap::new();
  for i in 0 .. bricks.len() {
    if bricks[i].supported_by.len() &gt; 1 {
      for s in &amp;bricks[i].supported_by {
        if !hash_map.contains_key(s) {
          hash_map.insert(*s, true);
        }
      }
    }
    else {
      for s in &amp;bricks[i].supported_by {
        hash_map.insert(*s, false);
      }
    }
    if bricks[i].supports.len() == 0 {
      if !hash_map.contains_key(&amp;i) {
        hash_map.insert(i, true);
      }
    }
  }
  hash_map.into_iter().filter(|a| a.1).count()
}

fn count_disintegration(bricks: &amp;Vec&lt;Brick&gt;) -&gt; usize {
  let mut total: usize = 0;
  for i in 0 .. bricks.len() {
    let mut set: HashSet&lt;usize&gt; = HashSet::new();
    let mut queue: VecDeque&lt;usize&gt; = VecDeque::new();
    set.insert(i);
    queue.push_back(i);
    while !queue.is_empty() {
      let brick = queue.pop_front().unwrap();
      for b in &amp;bricks[brick].supports {
        if set.intersection(&amp;bricks[*b].supported_by).count() == bricks[*b].supported_by.len() {
          if !set.contains(b) {
            queue.push_back(*b);
            set.insert(*b);
          }
        }
      }
    }
    total += set.len() - 1;
  }
  total
}

fn part1() {
  let mut bricks = read_file("INPUT");
  bricks.sort_by(|a, b| a.z.cmp(&amp;b.z));
  compress_bricks(&amp;mut bricks);
  create_supports(&amp;mut bricks);
  println!("Part 1: {}", count_overlaps(&amp;mut bricks));
}

fn part2() {
  let mut bricks = read_file("INPUT");
  bricks.sort_by(|a, b| a.z.cmp(&amp;b.z));
  compress_bricks(&amp;mut bricks);
  create_supports(&amp;mut bricks);
  println!("Part 2: {}", count_disintegration(&amp;bricks));
}

fn main() {
  println!("Year 2023 day 22 - Sand Slabs");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-23"><a class="header" href="#advent-of-code---year-2023-day-23">Advent of code - Year 2023 Day 23</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/23">day 23</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-23"><a class="header" href="#info-23">Info</a></h3>
<h4 id="part-1-23"><a class="header" href="#part-1-23">Part 1</a></h4>
<p>First part is pretty simple and fast. We just recursively go through the map and follow the slopes. We are trying every possibility and then find the maximum.</p>
<h4 id="part-2-23"><a class="header" href="#part-2-23">Part 2</a></h4>
<p>For the second part they are at least two approaches.</p>
<ol>
<li>Use the same code just ignore the slopes and try every possibilty. As one may see this is not quite the best way to do it. But as it turns out you will wait way less than an hour, so it si doable.</li>
<li>The second more complex way is to actually compress each path and create a simplified graph. Then again try every possibility. it will still take probably some time, but there is less vertices and edges to consider.</li>
</ol>
<p>In my code I just used the brute force, because after a lunch the result was already processed.</p>
<h2 id="mainrs-23"><a class="header" href="#mainrs-23">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::collections::HashSet;

const EMPTY: char = '.';
const NON_EMPTY: char = '#';

type Grid&lt;T&gt; = Vec&lt;Vec&lt;T&gt;&gt;;
type Position = (usize, usize);

fn read_file(filepath: &amp;str) -&gt; Grid&lt;char&gt; {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  let mut map: Grid&lt;char&gt; = vec![];
  for line in lines{
    let map_line: Vec&lt;char&gt; = line.chars().collect();
    if map_line.len() &gt; 0 {
      map.push(map_line);
    }
  }
  map
}

fn find_start_end(map: &amp;Grid&lt;char&gt;) -&gt; (Position, Position) {
  let mut start: Position = (0,0);
  let mut end: Position = (0,0);
  for i in 0 .. map[0].len() {
    if map[0][i] == EMPTY {
      start = (0, i);
      break;
    }
  }
  for i in 0 .. map[map.len() - 1].len() {
    if map[map.len() - 1][i] == EMPTY {
      end = (map.len() - 1, i);
      break;
    }
  }
  (start, end)
}

fn add(a: Position, b: (i8, i8)) -&gt; Position {
  ((a.0 as i64 + b.0 as i64) as usize, (a.1 as i64 + b.1 as i64) as usize)
}

fn step(map: &amp;Grid&lt;char&gt;, position: Position, ignore_slopes: bool) -&gt; Vec&lt;Position&gt; {
  let mut positions: Vec&lt;Position&gt; = vec!();
  const LEN: usize = 4;
  let neighbors: [(i8, i8); LEN] = [(0,-1), (0,1), (1,0), (-1,0)];
  let slopes: [char; LEN] = ['&lt;', '&gt;', 'v', '^'];
  for i in 0 .. LEN {
    let pos: Position = add(position, neighbors[i]);
    if pos.0 &lt; map.len() &amp;&amp; pos.1 &lt; map[pos.0].len() {
      if ignore_slopes &amp;&amp; map[pos.0][pos.1] != NON_EMPTY {
        positions.push(pos);
      }
      else if !ignore_slopes &amp;&amp; (map[pos.0][pos.1] == EMPTY || map[pos.0][pos.1] == slopes[i]) {
        positions.push(pos);
      }
    }
  }
  positions
}

fn longest_path(map: &amp;Grid&lt;char&gt;, visited: &amp;mut HashSet&lt;Position&gt;, pos: Position, max: &amp;mut u64, len: u64, end: &amp;Position, ignore_slopes: bool) {
  if pos == *end {
    if *max &lt; len {
      *max = len;
    }
    return;
  }
  let neighbors = step(map, pos, ignore_slopes);
  for n in neighbors {
    if !visited.contains(&amp;n) {
      visited.insert(n);
      longest_path(map, visited, n, max, len+1, end, ignore_slopes);
      visited.remove(&amp;n);
    }
  }
}

fn part1() {
  let map = read_file("INPUT");
  let (start, end) = find_start_end(&amp;map);
  let mut set: HashSet&lt;Position&gt; = HashSet::new();
  let mut max: u64 = 0;
  longest_path(&amp;map, &amp;mut set, start, &amp;mut max, 0, &amp;end, false);
  println!("Part 1: {}", max);
}

fn part2() {
  let map = read_file("INPUT");
  let (start, end) = find_start_end(&amp;map);
  let mut set: HashSet&lt;Position&gt; = HashSet::new();
  let mut max: u64 = 0;
  longest_path(&amp;map, &amp;mut set, start, &amp;mut max, 0, &amp;end, true);
  println!("Part 2: {}", max);
}

fn main() {
  println!("Year 2023 day 23 - A Long Walk");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-24"><a class="header" href="#advent-of-code---year-2023-day-24">Advent of code - Year 2023 Day 24</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/24">day 24</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-24"><a class="header" href="#info-24">Info</a></h3>
<h4 id="part-1-24"><a class="header" href="#part-1-24">Part 1</a></h4>
<p>First part was somewhat easy since we only take a look at two dimensional matrix and finc the solution if there is any. After that check the bounds and return right answer.</p>
<h4 id="part-2-24"><a class="header" href="#part-2-24">Part 2</a></h4>
<p>In the second part we used <a href="https://docs.rs/z3/latest/z3/">z3</a> proving system to set the variables and solve the problem.</p>
<h2 id="mainrs-24"><a class="header" href="#mainrs-24">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use z3::ast::{Ast, Int};
use z3::{Config, Context, Solver};

struct HailStone {
  x: i64,
  y: i64,
  z: i64,
  xv: i64,
  yv: i64,
  zv: i64,
}

fn parse_hail_stone(line: &amp;str) -&gt; HailStone {
  let pos_vel: Vec&lt;&amp;str&gt; = line.split(" @ ").collect();
  let pos: Vec&lt;i64&gt; = pos_vel[0].split(", ").map(|x| i64::from_str_radix(x, 10).unwrap()).collect();
  let vel: Vec&lt;i64&gt; = pos_vel[1].split(", ").map(|x| i64::from_str_radix(x, 10).unwrap()).collect();
  HailStone {
    x: pos[0],
    y: pos[1],
    z: pos[2],
    xv: vel[0],
    yv: vel[1],
    zv: vel[2],
  }
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;HailStone&gt; {
  let contents = fs::read_to_string(filepath);
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  let mut hail_stones: Vec&lt;HailStone&gt; = vec!();
  for line in lines{
    if line != "" {
      hail_stones.push(parse_hail_stone(line));
    }
  }
  hail_stones
}

fn colission(hs1: &amp;HailStone, hs2: &amp;HailStone, limits: (i64, i64)) -&gt; bool {
  let det = (-hs1.xv) * hs2.yv - hs2.xv * (-hs1.yv);
  if det == 0 {
    return false;
  } else {
    let time1 = ((hs1.x - hs2.x) * hs2.yv - (hs1.y - hs2.y) * hs2.xv) / det;
    let time2 = ((-hs1.xv) * (hs1.y - hs2.y) - (-hs1.yv) * (hs1.x - hs2.x)) / det;
    let point = (hs1.x + hs1.xv * time1, hs1.y + hs1.yv * time1);
    return point.0 &gt;= limits.0 &amp;&amp; point.0 &lt;= limits.1 &amp;&amp; point.1 &gt;= limits.0 &amp;&amp; point.1 &lt;= limits.1 &amp;&amp; time1 &gt;= 0 &amp;&amp; time2 &gt;= 0;
  }
}

fn number_of_collisions(hail_stones: &amp;Vec&lt;HailStone&gt;, limits: (i64, i64)) -&gt; u64 {
  let mut total: u64 = 0;
  for i in 0 .. hail_stones.len() {
    for j in i + 1 .. hail_stones.len() {
      if colission(&amp;hail_stones[i], &amp;hail_stones[j], limits) {
        total += 1;
      }
    }
  }
  total
}

fn perfect_shot(hailstones: &amp;Vec&lt;HailStone&gt;) -&gt; i64{
  let cfg = Config::new();
  let ctx = Context::new(&amp;cfg);
  let solver = Solver::new(&amp;ctx);
  let px = Int::new_const(&amp;ctx, "px");
  let py = Int::new_const(&amp;ctx, "py");
  let pz = Int::new_const(&amp;ctx, "pz");
  let vx = Int::new_const(&amp;ctx, "vx");
  let vy = Int::new_const(&amp;ctx, "vy");
  let vz = Int::new_const(&amp;ctx, "vz");
  for hailstone in hailstones {
    let pxn = Int::from_i64(&amp;ctx, hailstone.x);
    let pyn = Int::from_i64(&amp;ctx, hailstone.y);
    let pzn = Int::from_i64(&amp;ctx, hailstone.z);
    let vxn = Int::from_i64(&amp;ctx, hailstone.xv);
    let vyn = Int::from_i64(&amp;ctx, hailstone.yv);
    let vzn = Int::from_i64(&amp;ctx, hailstone.zv);
    let tn = Int::fresh_const(&amp;ctx, "t");
    solver.assert(&amp;(&amp;pxn + &amp;vxn * &amp;tn)._eq(&amp;(&amp;px + &amp;vx * &amp;tn)));
    solver.assert(&amp;(&amp;pyn + &amp;vyn * &amp;tn)._eq(&amp;(&amp;py + &amp;vy * &amp;tn)));
    solver.assert(&amp;(&amp;pzn + &amp;vzn * &amp;tn)._eq(&amp;(&amp;pz + &amp;vz * &amp;tn)));
  }
  solver.check();
  let model = solver.get_model().unwrap();
  let x = model.get_const_interp(&amp;px).unwrap().as_i64().unwrap();
  let y = model.get_const_interp(&amp;py).unwrap().as_i64().unwrap();
  let z = model.get_const_interp(&amp;pz).unwrap().as_i64().unwrap();
  x + y + z
}

fn part1() {
  let hail_stones = read_file("INPUT");
  println!("Part 1: {}", number_of_collisions(&amp;hail_stones, (200_000_000_000_000, 400_000_000_000_000)));
}

fn part2() {
  let hail_stones = read_file("INPUT");
  println!("Part 2: {}", perfect_shot(&amp;hail_stones));
}

fn main() {
  println!("Year 2023 day 24 - Never Tell Me The Odds");
  part1();
  part2();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advent-of-code---year-2023-day-25"><a class="header" href="#advent-of-code---year-2023-day-25">Advent of code - Year 2023 Day 25</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/25">day 25</a>. Go back to year <a href="aoc/2023.html">2023</a>. Go back to <a href="aoc/../adventofcode.html">AOC</a>.</p>
<h3 id="info-25"><a class="header" href="#info-25">Info</a></h3>
<h4 id="part-1-25"><a class="header" href="#part-1-25">Part 1</a></h4>
<p>The first part is done by <a href="https://graphviz.org/doc/info/lang.html">graphviz dot language</a>. So the code creates a file <code>graph.dot</code> than you run <code>dot -Kneato -Tsvg graph.dot -o graph.svg</code>. You find the three pairs forming the min cut and manually insert it into the code. Then you ran the code again.</p>
<p>The alternate algorithm is to use <a href="https://en.wikipedia.org/wiki/Karger%27s_algorithm">Karger-Steins</a> approximation algorithm. This I didn't make.</p>
<h4 id="part-2-25"><a class="header" href="#part-2-25">Part 2</a></h4>
<p><strong>PUSH THE RED BUTTON.</strong></p>
<h2 id="mainrs-25"><a class="header" href="#mainrs-25">main.rs</a></h2>
<pre><code class="language-rs">use std::fs;
use std::io::Write;
use std::collections::{HashSet, VecDeque};

struct Wire {
  start: String,
  ends: Vec&lt;String&gt;,
}

fn parse_wire(line: &amp;str) -&gt; Wire {
  let from_to: Vec&lt;&amp;str&gt; = line.split(": ").collect();
  let mut wire = Wire{start: from_to[0].to_string(), ends: vec!()};
  let parts: Vec&lt;&amp;str&gt; = from_to[1].split(' ').collect();
  for p in parts {
    wire.ends.push(p.to_string());
  }
  wire
}

fn read_file(filepath: &amp;str) -&gt; Vec&lt;Wire&gt; {
  let contents = fs::read_to_string(filepath);
  let mut wires: Vec&lt;Wire&gt; = vec!();
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  for line in lines{
    if line != "" {
      wires.push(parse_wire(line));
    }
  }
  wires
}

fn create_graphviz(filepath: &amp;str, wires: &amp;Vec&lt;Wire&gt;) {
  let file = fs::File::create(filepath);
  match writeln!(file.as_ref().expect("REASON"), "{}", "graph AOC25 {") {
    Ok(()) =&gt; {},
    Err(..) =&gt; return,
  }
  for wire in wires {
    for end in &amp;wire.ends {
      match writeln!(file.as_ref().expect("REASON"), "{}", format!("  {} -- {};", wire.start, end)) {
      Ok(()) =&gt; {},
      Err(..) =&gt; return,
      }
    }
  }
  match writeln!(file.as_ref().expect("REASON"), "{}", "}") {
    Ok(()) =&gt; {},
    Err(..) =&gt; return,
  }
}

fn is_forb(w1: &amp;str, w2: &amp;str, forb: &amp;[(&amp;str, &amp;str); 3]) -&gt; bool {
  for f in forb {
    if (f.0 == w1 &amp;&amp; f.1 == w2) || (f.1 == w1 &amp;&amp; f.0 == w2) {
      return true;
    }
  }
  false 
}

fn partitions(wires: &amp;Vec&lt;Wire&gt;, forb: &amp;[(&amp;str, &amp;str); 3]) -&gt; u64 {
  let mut found: HashSet&lt;String&gt; = HashSet::new();
  let mut queue: VecDeque&lt;String&gt; = VecDeque::new();
  found.insert(wires[0].start.clone());
  queue.push_back(wires[0].start.clone());
  while !queue.is_empty() {
    let wire = queue.pop_front().unwrap();
    for w in wires {
      if wire == w.start {
        for e in &amp;w.ends {
          if !is_forb(&amp;wire, &amp;e.clone(), forb) &amp;&amp; !found.contains(&amp;e.clone()) {
            found.insert(e.clone());
            queue.push_back(e.clone());
          }
        }
      }
      else if w.ends.clone().into_iter().filter(|e| &amp;wire == e).count() &gt; 0 {
        for e in &amp;w.ends {
          if &amp;wire == e &amp;&amp; !is_forb(&amp;w.start, &amp;e.clone(), forb) &amp;&amp; !found.contains(&amp;w.start) {
            found.insert(w.start.clone());
            queue.push_back(w.start.clone());
          }
        }
      }
    }
  }
  let mut all: HashSet&lt;String&gt; = HashSet::new();
  for w in wires {
    all.insert(w.start.clone());
    for e in &amp;w.ends {
      all.insert(e.clone());
    }
  }
  (found.len() * (all.len() - found.len())) as u64
}

fn part1() {
  let wires = read_file("INPUT");
  create_graphviz("graph.dot", &amp;wires);
  // This is only my solution. Run `dot -Kneato -Tsvg graph.dot -o graph.svg` to create your graph.
  let forb: [(&amp;str, &amp;str); 3] = [("dlv", "tqh"), ("ngp", "bmd"), ("tqr", "grd")];
  println!("Run `dot -Kneato -Tsvg graph.dot -o graph.svg` to see three edges.");
  println!("Part 1: {}", partitions(&amp;wires, &amp;forb));
}

fn part2() {
  println!("Part 2: {}", "PUSH THE RED BUTTON.");
}

fn main() {
  println!("Year 2023 day 25 - Snowverload");
  part1();
  part2();
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
