<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Year 2023 day 20 - Personal page</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Personal page</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="advent-of-code---year-2023-day-20"><a class="header" href="#advent-of-code---year-2023-day-20">Advent of code - Year 2023 Day 20</a></h1>
<p>This is a solution of the <a href="https://adventofcode.com/2023/day/20">day 20</a>. Go back to year <a href="2023.html">2023</a>. Go back to <a href="../adventofcode.html">AOC</a>.</p>
<h3 id="info"><a class="header" href="#info">Info</a></h3>
<h4 id="part-1"><a class="header" href="#part-1">Part 1</a></h4>
<p>In the first part you run the bfs to firstly find predecessors. Then you have the whole graph represented. After you run once again bfs with some different cases for the logic to work.</p>
<h4 id="part-2"><a class="header" href="#part-2">Part 2</a></h4>
<p>The second part is easier to solve by hand. You may create a <code>graph.dot</code> in <a href="https://graphviz.org/doc/info/lang.html">graphviz dot language</a> and then by running <code>dot -Kdot -Tsvg graph.dot -o graph.svg</code> create a picture of the graph. There are 4 modules that behave like a binary counters. For each you represent it by a binary number; 1 if the edge goes to the conjection and 0 otherwise. After you represent it you use LCM for them and that is the answer.</p>
<h2 id="mainrs"><a class="header" href="#mainrs">main.rs</a></h2>
<pre><code class="language-rs">use std::collections::{HashMap, HashSet, VecDeque};
use std::fs;
use std::io::Write;

const BROADCASTER: &amp;str = "broadcaster";
const RX: &amp;str = "rx";

#[derive(Debug, Eq, PartialEq, Clone)]
enum NodeType {
    FlipFlop,
    Conjuction,
    Broadcast,
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum Pulse {
    Low,
    High,
}

#[derive(Debug, Clone)]
struct Node {
    name: String,
    node_type: NodeType,
    on: bool,
    next_nodes: Vec&lt;String&gt;,
    predecessors: HashMap&lt;String, Pulse&gt;,
}

fn parse_node(line: &amp;str) -&gt; Node {
    let parts: Vec&lt;&amp;str&gt; = line.split(" -&gt; ").collect();
    let node_type: NodeType;
    match parts[0].chars().nth(0).unwrap() {
        '%' =&gt; node_type = NodeType::FlipFlop,
        '&amp;' =&gt; node_type = NodeType::Conjuction,
        _ =&gt; node_type = NodeType::Broadcast,
    }
    let name: String;
    if node_type != NodeType::Broadcast {
        name = parts[0][1..].to_string();
    } else {
        name = parts[0].to_string();
    }
    let next_nodes: Vec&lt;String&gt; = parts[1].split(", ").map(|n| n.to_string()).collect();
    Node {
        name: name,
        node_type: node_type,
        on: false,
        next_nodes: next_nodes,
        predecessors: HashMap::new(),
    }
}

fn read_file(filepath: &amp;str) -&gt; HashMap&lt;String, Node&gt; {
    let mut hash_map: HashMap&lt;String, Node&gt; = HashMap::new();
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let lines = binding.split('\n');
    for line in lines {
        if line != "" {
            let node = parse_node(line);
            let name = &amp;node.name;
            hash_map.insert(name.to_string(), node);
        }
    }
    hash_map.insert(
        RX.to_string(),
        Node {
            name: RX.to_string(),
            node_type: NodeType::Broadcast,
            on: false,
            next_nodes: vec![],
            predecessors: HashMap::new(),
        },
    );
    return hash_map;
}

fn find_predecessors(hash_map: &amp;mut HashMap&lt;String, Node&gt;) {
    let mut name = BROADCASTER.to_string();
    let mut set: HashSet&lt;String&gt; = HashSet::new();
    let mut queue: VecDeque&lt;String&gt; = VecDeque::new();
    queue.push_back(name.clone());
    while !queue.is_empty() {
        name = queue.pop_front().unwrap().to_string();
        if set.contains(&amp;name) {
            continue;
        }
        set.insert(name.clone());
        let next_nodes = &amp;hash_map[&amp;name].next_nodes.clone();
        for n in next_nodes {
            if let Some(new_node) = hash_map.get_mut(n) {
                new_node.predecessors.insert(name.clone(), Pulse::Low);
                queue.push_back(n.clone());
            }
        }
    }
}

fn create_graphviz(hash_map: &amp;HashMap&lt;String, Node&gt;, filepath: &amp;str) {
    let file = fs::File::create(filepath);
    match writeln!(file.as_ref().expect("REASON"), "{}", "digraph AOC {") {
        Ok(()) =&gt; {}
        Err(..) =&gt; return,
    }
    for n in hash_map {
        let mut color: &amp;str;
        match n.1.node_type {
            NodeType::Broadcast =&gt; color = "red",
            NodeType::Conjuction =&gt; color = "blue",
            NodeType::FlipFlop =&gt; color = "green",
        }
        if n.1.name == RX {
            color = "orange";
        }
        match writeln!(
            file.as_ref().expect("REASON"),
            "{}",
            format!("  {} [color={}]", n.1.name, color)
        ) {
            Ok(()) =&gt; {}
            Err(..) =&gt; return,
        }
    }
    let mut name = BROADCASTER.to_string();
    let mut set: HashSet&lt;String&gt; = HashSet::new();
    let mut queue: VecDeque&lt;String&gt; = VecDeque::new();
    queue.push_back(name.clone());
    while !queue.is_empty() {
        name = queue.pop_front().unwrap().to_string();
        if set.contains(&amp;name) {
            continue;
        }
        set.insert(name.clone());
        let next_nodes = &amp;hash_map[&amp;name].next_nodes.clone();
        for n in next_nodes {
            match writeln!(
                file.as_ref().expect("REASON"),
                "{}",
                format!("  {} -&gt; {};", name, n)
            ) {
                Ok(()) =&gt; {}
                Err(..) =&gt; return,
            }
            queue.push_back(n.clone());
        }
    }
    match writeln!(file.as_ref().expect("REASON"), "{}", "}") {
        Ok(()) =&gt; {}
        Err(..) =&gt; return,
    }
}

fn all_highs(hash_map: &amp;HashMap&lt;String, Pulse&gt;) -&gt; bool {
    hash_map
        .into_iter()
        .map(|x| x.1 == &amp;Pulse::High)
        .fold(true, |acc, x| acc &amp;&amp; x)
}

fn bfs(hash_map: &amp;mut HashMap&lt;String, Node&gt;) -&gt; (i64, i64) {
    let mut lows: i64 = 1;
    let mut highs: i64 = 0;
    let mut name = BROADCASTER.to_string();
    let mut pulse: Pulse = Pulse::Low;
    let mut queue: VecDeque&lt;(String, Pulse)&gt; = VecDeque::new();
    queue.push_back((name.clone(), pulse));
    while !queue.is_empty() {
        (name, pulse) = queue.pop_front().unwrap();
        let next_nodes = &amp;hash_map[&amp;name].next_nodes.clone();
        match &amp;hash_map[&amp;name].node_type {
            NodeType::FlipFlop =&gt; {
                if pulse == Pulse::Low {
                    hash_map.get_mut(&amp;name).unwrap().on = !&amp;hash_map[&amp;name].on;
                    if hash_map[&amp;name].on {
                        pulse = Pulse::High;
                    } else {
                        pulse = Pulse::Low;
                    }
                } else {
                    continue;
                }
            }
            NodeType::Conjuction =&gt; {
                if all_highs(&amp;hash_map[&amp;name].predecessors) {
                    pulse = Pulse::Low;
                } else {
                    pulse = Pulse::High;
                }
            }
            NodeType::Broadcast =&gt; pulse = pulse,
        }
        if pulse == Pulse::High {
            highs += next_nodes.len() as i64;
        } else {
            lows += next_nodes.len() as i64;
        }
        for n in next_nodes {
            if let Some(new_node) = hash_map.get_mut(n) {
                new_node.predecessors.insert(name.clone(), pulse.clone());
                queue.push_back((n.clone(), pulse.clone()));
            }
        }
    }
    (lows, highs)
}

fn gcd(mut a: u64, mut b: u64) -&gt; u64 {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a
}

fn lcm(a: u64, b: u64) -&gt; u64 {
    (a * b) / gcd(a, b)
}

fn lcm_vec(vec: &amp;Vec&lt;u64&gt;) -&gt; u64 {
    vec.into_iter().fold(1, |acc, x| lcm(*x, acc))
}

fn part1() {
    let mut hash_map = read_file("INPUT");
    find_predecessors(&amp;mut hash_map);
    let mut total_lows: i64 = 0;
    let mut total_highs: i64 = 0;
    for _ in 0..1000 {
        let (low, high) = bfs(&amp;mut hash_map);
        total_lows += low;
        total_highs += high;
    }
    println!("Part 1: {}", total_lows * total_highs);
}

fn part2() {
    let hash_map = read_file("INPUT");
    create_graphviz(&amp;hash_map, "graph.dot");
    // This is actually only my result.
    let vec: Vec&lt;u64&gt; = [
        0b111111010011,
        0b111100000111,
        0b111100100101,
        0b111011010101,
    ]
    .to_vec();
    println!("This is just my solution, yours can be found by looking at the graph in graph.dot.");
    println!("Try running: dot -Kdot -Tsvg graph.dot -o graph.svg to see the graph.");
    println!("Simply create binary numbers for each module; 1 if it goes in and 0 otherwise.");
    println!("Part 2: {}", lcm_vec(&amp;vec));
}

fn main() {
    println!("Year 2023 day 20 - Pulse Propagation");
    part1();
    part2();
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../aoc/2023-19.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../aoc/2023-21.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../aoc/2023-19.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../aoc/2023-21.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
