---
layout: page
title: Day 15
parent: Year 2023
grand_parent: advent of code
permalink: /aoc/2023/15/
---

This is a solution of the day 15.


# main.py

```py
#!/usr/bin/env python3

from enum import Enum

EQUALS = "="
DASH = "-"

MULTIPLIER = 17
DIVISOR = 256


class OperationType(Enum):
    ADD = "add"
    REMOVE = "remove"


class Box:
    def __init__(self):
        self.content = {}

    def add_lens(self, label: str, focal_length: int):
        self.content[label] = focal_length

    def remove_lens(self, label: str):
        self.content.pop(label, None)

    def box_power(self) -> int:
        return sum(
            slot * focal_length
            for slot, (_, focal_length) in enumerate(self.content.items(), 1)
        )


class Operation:
    def __init__(self, op: Enum, label: str, focal_length=None):
        self.op = op
        self.label = label
        self.hash = Operation.hash_string(label)
        self.focal_length = focal_length

    @staticmethod
    def hash_string(string: str) -> int:
        value = 0
        for char in string:
            value = (value + ord(char)) * MULTIPLIER % DIVISOR
        return value


class ReflectorDish:
    def __init__(self):
        self.sequence: list[Operation] = []
        self.boxes = [Box() for _ in range(DIVISOR)]

    @staticmethod
    def parse_step(string: str) -> Operation:
        if EQUALS in string:
            label, focal_length_str = string.split(EQUALS)
            return Operation(OperationType.ADD, label, int(focal_length_str))
        elif DASH in string:
            label = string.split(DASH)[0]
            return Operation(OperationType.REMOVE, label)

    def parse_input(self, input_data: list):
        for string in input_data:
            self.sequence.append(ReflectorDish.parse_step(string))

    def initialize_sequence(self):
        for operation in self.sequence:
            if operation.op == OperationType.ADD:
                self.boxes[operation.hash].add_lens(
                    operation.label, operation.focal_length
                )
            else:
                self.boxes[operation.hash].remove_lens(operation.label)

    def calculate_focusing_power(self) -> int:
        for i, box in enumerate(self.boxes, 1):
            print(i * box.box_power())
        return sum(i * box.box_power() for i, box in enumerate(self.boxes, 1))


def part_one(data: list) -> int:
    return sum(Operation.hash_string(string) for string in data)


def main():
    with open("INPUT") as f:
        input_data = f.read().split(",")

    print(part_one(input_data))

    reflector_dish = ReflectorDish()
    reflector_dish.parse_input(input_data)
    reflector_dish.initialize_sequence()
    print(reflector_dish.calculate_focusing_power())


if __name__ == "__main__":
    main()

```
# main.rs

```rs
use std::fs;
use std::collections::LinkedList;

fn read_file(filepath: &str) -> Vec<String>{
  let contents = fs::read_to_string(filepath);
  let mut strings: Vec<String> = vec!();
  let binding = contents.expect("REASON");
  let lines = binding.split('\n');
  for line in lines{
    let inputs = line.split(',');
    for input in inputs{
      if input != ""{
        strings.push(input.to_string());
      }
    }
  }
  return strings;
}

fn ascii_hash(string: &str) -> i32{
  let mut hash: i32 = 0;
  for c in string.chars(){
    let ascii = c as i32;
    hash = ((hash + ascii) * 17) % 256;
  }
  return hash;
}

fn insert_to_map(hash_map: &mut Vec<LinkedList<(String, i32)>>, lens: i32, key: &str){
  let hash = ascii_hash(key) as usize;
  for element in &mut hash_map[hash]{
    if element.0 == key{
      element.1 = lens;
      return;
    }
  }
  hash_map[hash].push_back((key.to_string(), lens));
}

fn remove_from_map(hash_map: &mut Vec<LinkedList<(String, i32)>>, key: &str){
  let hash = ascii_hash(key) as usize;
  let mut j: usize = 0;
  for element in &mut hash_map[hash]{
    if element.0 == key{
      let mut last = hash_map[hash].split_off(j);
      last.pop_front();
      hash_map[hash].append(&mut last);
      return;
    }
    j += 1;
  }
}

fn init_hash_map(size: i32) -> Vec<LinkedList<(String, i32)>>{
  let mut hash_map: Vec<LinkedList<(String, i32)>> = vec!();
  for _ in 0..size{
    hash_map.push(LinkedList::new());
  }
  return hash_map;
}


fn part1(){
  let strings = read_file("INPUT");
  let mut total = 0;
  for string in strings{
    total += ascii_hash(&string);
  }
  println!("Part 1: {}", total);
}

fn part2(){
  let mut hash_map = init_hash_map(256);
  let strings = read_file("INPUT");
  let mut total = 0;
  for string in strings{
    if string.chars().nth(string.len() - 1) == Some('-'){
      let key = &string[0..string.len() - 1];
      remove_from_map(&mut hash_map, key);
    }
    else if string.chars().nth(string.len() - 2) == Some('='){
      let lens = string.chars().nth(string.len() - 1).unwrap() as i32 - '0' as i32;
      let key = &string[0..string.len() - 2];
      insert_to_map(&mut hash_map, lens, key);
    }
  }
  for i in 0..hash_map.len(){
    let mut j = 0;
    for element in &hash_map[i]{
      total += (i + 1) * (j + 1) * (element.1 as usize);
      j += 1;
    }
  }
  println!("Part 2: {}", total);
}

fn main() {
  part1();
  part2();
}
```
