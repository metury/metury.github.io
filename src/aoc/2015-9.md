# Advent of code - Year 2015 Day 9

This is a solution of the [day 9](https://adventofcode.com/2015/day/9). Go back to year [2015](2015.md). Go back to [AOC](../adventofcode.md).

### Information

#### Part 1

We will create all permutations of towns and then compute their distance, after that we find the minimal one.

#### Part 2

In the second part find the maximal one.

## main.exs

```exs
IO.puts("Year 2015 day 9 - All in a Single Night")

defmodule Perms do
  def perms([]), do: [[]]

  def perms(l) do
    for h <- l, t <- perms(l -- [h]),
      do: [h|t]
  end
end

defmodule Cycle do
  def compute(_, [_]), do: 0

  def compute(distances, [t1, t2 | towns]) do
    {_, _, dist} = Enum.find(distances, fn {t3, t4, _} -> t3 == t1 and t4 == t2 end)
    dist + compute(distances, [t2 | towns])
  end
end

if {:ok, content} = File.read("INPUT") do
  distances = Regex.scan(~r/([a-zA-Z]+) to ([a-zA-Z]+) = ([0-9]+)/, String.trim(content))
  |> Enum.map(fn [_, town1, town2, dist] -> [town1, town2, Integer.parse(dist)] end)
  |> Enum.map(fn [town1, town2, {dist, _}] -> [{town1, town2, dist}, {town2, town1, dist}] end)
  |> List.flatten()
  |> Enum.sort(fn {t1, t2, _}, {t3, t4, _} -> t1 < t3 or (t1 == t3 and t2 < t4) end)
  lengths = Enum.map(distances, fn {town  , _, _} -> town end)
  |> Enum.dedup()
  |> Perms.perms()
  |> Enum.map(fn towns -> Cycle.compute(distances, towns) end)
  {min, max} = Enum.min_max(lengths)
  IO.puts("Part 1: #{min}")
  IO.puts("Part 2: #{max}")
end
```

