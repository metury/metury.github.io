# Advent of code - Year 2015 Day 6

This is a solution of the [day 6](https://adventofcode.com/2015/day/6). Go back to year [2015](2015.md). Go back to [AOC](../adventofcode.md).

### Information

#### Part 1

We simply follow the given instructions on the `1000x1000` grid. Then compute those which are `true`.

#### Part 2

In the second part we redefine the instructions and compute the sum.

## main.rs

```rs
use regex::Regex;
use std::fs;

type Grid<T> = Vec<Vec<T>>;
type Pos = (usize, usize);

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd)]
enum InstructionType {
    TurnOff,
    TurnOn,
    Toggle,
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd)]
struct Instruction {
    start: Pos,
    end: Pos,
    instr_type: InstructionType,
}

fn read_file(filepath: &str) -> Vec<Instruction> {
    let contents = fs::read_to_string(filepath);
    let binding = contents.expect("REASON");
    let mut instructions: Vec<Instruction> = vec![];
    let input =
        Regex::new(r"(turn off|turn on|toggle) ([0-9]+),([0-9]+) through ([0-9]+),([0-9]+)")
            .unwrap();
    for (_, [ty, s1, s2, e1, e2]) in input.captures_iter(&binding).map(|c| c.extract()) {
        let instr_type: InstructionType;
        if ty == "turn off" {
            instr_type = InstructionType::TurnOff;
        } else if ty == "turn on" {
            instr_type = InstructionType::TurnOn;
        } else {
            instr_type = InstructionType::Toggle;
        }
        instructions.push(Instruction {
            instr_type: instr_type,
            start: (s1.parse().unwrap(), s2.parse().unwrap()),
            end: (e1.parse().unwrap(), e2.parse().unwrap()),
        });
    }
    instructions
}

fn part1() {
    let instructions = read_file("INPUT");
    let mut grid: Grid<bool> = vec![vec!(false; 1000); 1000];
    for ins in instructions {
        match ins.instr_type {
            InstructionType::Toggle => {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] = !grid[i][j];
                    }
                }
            }
            InstructionType::TurnOff => {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] = false;
                    }
                }
            }
            InstructionType::TurnOn => {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] = true;
                    }
                }
            }
        }
    }
    let lit_up: u64 = grid
        .into_iter()
        .map(|vec| vec.into_iter().map(|x| if x { 1 } else { 0 }).sum::<u64>())
        .sum();
    println!("Part 1: {}", lit_up);
}

fn part2() {
    let instructions = read_file("INPUT");
    let mut grid: Grid<u64> = vec![vec!(0_u64; 1000); 1000];
    for ins in instructions {
        match ins.instr_type {
            InstructionType::Toggle => {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] += 2;
                    }
                }
            }
            InstructionType::TurnOff => {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] = if grid[i][j] > 0 {
                            grid[i][j] - 1
                        } else {
                            grid[i][j]
                        };
                    }
                }
            }
            InstructionType::TurnOn => {
                for i in ins.start.0..ins.end.0 + 1 {
                    for j in ins.start.1..ins.end.1 + 1 {
                        grid[i][j] += 1;
                    }
                }
            }
        }
    }
    let lit_up: u64 = grid
        .into_iter()
        .map(|vec| vec.into_iter().sum::<u64>())
        .sum();
    println!("Part 2: {}", lit_up);
}

fn main() {
    println!("Year 2015 day 6 - Probably a Fire Hazard");
    part1();
    part2();
}
```

## main.exs

```exs
IO.puts("Year 2015 day 6 - Probably a Fire Hazard")

if {:ok, string} = File.read("INPUT") do
  array = :array.new(size: 1000 * 1000, default: false)
  result = Regex.scan(~r/((?:turn off)|(?:turn on)|(?:toggle)) ([0-9]+),([0-9]+) through ([0-9]+),([0-9]+)/, String.trim(string))
  |> Enum.map(fn [_, keyword, x, y, end_x, end_y] -> [keyword, Integer.parse(x), Integer.parse(y), Integer.parse(end_x), Integer.parse(end_y)] end)
  |> Enum.map(fn [keyword, {start_x, _}, {start_y, _}, {end_x, _}, {end_y, _}] -> {keyword, for x <- start_x..end_x, y <- start_y..end_y do 1000*x + y end} end)
  |> List.foldl(array, fn {keyword, range}, acc ->
  case keyword do
    "turn on" ->  Enum.reduce(range, acc, fn x, acc -> :array.set(x, true, acc) end)
    "turn off" ->  Enum.reduce(range, acc, fn x, acc -> :array.set(x, false, acc) end)
    "toggle" ->  Enum.reduce(range, acc, fn x, acc -> :array.set(x, not :array.get(x, acc), acc) end)
  end end)
  IO.puts("Part 1: #{Enum.count(:array.to_list(result), fn x -> x end)}")
end

if {:ok, string} = File.read("INPUT") do
  array = :array.new(size: 1000 * 1000, default: 0)
  result = Regex.scan(~r/((?:turn off)|(?:turn on)|(?:toggle)) ([0-9]+),([0-9]+) through ([0-9]+),([0-9]+)/, String.trim(string))
  |> Enum.map(fn [_, keyword, x, y, end_x, end_y] -> [keyword, Integer.parse(x), Integer.parse(y), Integer.parse(end_x), Integer.parse(end_y)] end)
  |> Enum.map(fn [keyword, {start_x, _}, {start_y, _}, {end_x, _}, {end_y, _}] -> {keyword, for x <- start_x..end_x, y <- start_y..end_y do 1000*x + y end} end)
  |> List.foldl(array, fn {keyword, range}, acc ->
  case keyword do
    "turn on" ->  Enum.reduce(range, acc, fn x, acc -> :array.set(x, :array.get(x, acc) + 1, acc) end)
    "turn off" ->  Enum.reduce(range, acc, fn x, acc -> :array.set(x, Enum.max([0, :array.get(x, acc) - 1]), acc) end)
    "toggle" ->  Enum.reduce(range, acc, fn x, acc -> :array.set(x, :array.get(x, acc) + 2, acc) end)
  end end)
  IO.puts("Part 2: #{Enum.sum(:array.to_list(result))}")
end
```

