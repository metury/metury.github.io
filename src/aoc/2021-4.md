# Advent of code - Year 2021 Day 4

This is a solution of the [day 4](https://adventofcode.com/2021/day/4). Go back to year [2021](2021.md). Go back to [AOC](../adventofcode.md).

### Information

#### Part 1

In the first part we iterate over the numbers and fill in the bingo cards and check if it is winning, if so compute the value and multiply it by the drawn number.

#### Part 2

In the second part use the same procedure, only cycle through the winning boards, since multiple boards can win in with the same number.


## main.go

```go
package main

import (
  "fmt"
  "log"
  "os"
  "strconv"
  "strings"
  "time"
)

type Box struct {
  value int
  mark  bool
}

type Bingo [5][5]Box

func empty_bingo() Bingo {
  var bingo Bingo
  return bingo
}

func read_file(file_path string) ([]int, []Bingo) {
  content, err := os.ReadFile(file_path)
  if err != nil {
    log.Fatal(err)
  }
  counter := 0
  var numbers []int
  var bingos []Bingo
  for _, line := range strings.Split(string(content), "\n") {
    if len(line) == 0 {
      continue
    }
    space_splited := strings.Split(line, " ")
    comma_splited := strings.Split(line, ",")
    if len(comma_splited) > 1 {
      for _, nbr_string := range comma_splited {
        nr, _ := strconv.Atoi(nbr_string)
        numbers = append(numbers, nr)
      }
    } else {
      if counter%5 == 0 {
        bingos = append(bingos, empty_bingo())
      }
      j := 0
      for i := 0; i < len(space_splited); i++ {
        if len(space_splited[i]) == 0 {
          continue
        }
        nr, _ := strconv.Atoi(space_splited[i])
        bingos[counter/5][counter%5][j] = Box{nr, false}
        j++
      }
      counter++
    }
  }
  return numbers, bingos
}

func is_winning(bingo Bingo) bool {
  for i, row := range bingo {
    is_row_winning := true
    is_column_winning := true
    for j, ele := range row {
      is_row_winning = is_row_winning && ele.mark
      is_column_winning = is_column_winning && bingo[j][i].mark
    }
    if is_row_winning || is_column_winning {
      return true
    }
  }
  return false
}

func value_of_bingo(bingo Bingo) int {
  result := 0
  for _, row := range bingo {
    for _, ele := range row {
      if !ele.mark {
        result += ele.value
      }
    }
  }
  return result
}

func draw_number(bingos []Bingo, number int) (int, int, bool) {
  for k, bingo := range bingos {
    for i, row := range bingo {
      for j, ele := range row {
        if number == ele.value {
          bingos[k][i][j].mark = true
        }
      }
    }
    if is_winning(bingos[k]) {
      return number * value_of_bingo(bingos[k]), k, true
    }
  }
  return 0, -1, false
}

func part1() {
  var result int
  start := time.Now()
  numbers, bingos := read_file("INPUT")
  for _, number := range numbers {
    val, _, win := draw_number(bingos, number)
    if win {
      result = val
      break
    }
  }
  end := time.Now()
  fmt.Println("Part 1 [", end.Sub(start), "]:", result)
}

func part2() {
  var result int
  start := time.Now()
  numbers, bingos := read_file("INPUT")
  for _, number := range numbers {
    val, index, win := draw_number(bingos, number)
    for win {
      bingos = append(bingos[:index], bingos[index+1:]...)
      result = val
      val, index, win = draw_number(bingos, number)
    }
  }
  end := time.Now()
  fmt.Println("Part 2 [", end.Sub(start), "]:", result)
}

func main() {
  fmt.Println("Year 2021 day 4 - Giant Squid")
  part1()
  part2()
}
```

